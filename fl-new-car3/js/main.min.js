/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@fancyapps/ui/dist/carousel/carousel.esm.js":
/*!******************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/dist/carousel/carousel.esm.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Carousel": () => (/* binding */ H),
/* harmony export */   "Panzoom": () => (/* binding */ M)
/* harmony export */ });
const t=(t,e=1e4)=>(t=parseFloat(t+"")||0,Math.round((t+Number.EPSILON)*e)/e),e=function(t,i){return!(!t||t===document.body||i&&t===i)&&(function(t){if(!(t&&t instanceof Element&&t.offsetParent))return!1;const e=t.scrollHeight>t.clientHeight,i=window.getComputedStyle(t).overflowY,s=-1!==i.indexOf("hidden"),n=-1!==i.indexOf("visible");return e&&!s&&!n}(t)?t:e(t.parentElement,i))},i=function(t){var e=(new DOMParser).parseFromString(t,"text/html").body;if(e.childElementCount>1){for(var i=document.createElement("div");e.firstChild;)i.appendChild(e.firstChild);return i}return e.firstChild},s=t=>`${t||""}`.split(" ").filter((t=>!!t)),n=(t,e,i)=>{s(e).forEach((e=>{t&&t.classList.toggle(e,i||!1)}))};class o{constructor(t){Object.defineProperty(this,"pageX",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"pageY",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"clientX",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"clientY",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"time",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"nativePointer",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.nativePointer=t,this.pageX=t.pageX,this.pageY=t.pageY,this.clientX=t.clientX,this.clientY=t.clientY,this.id=self.Touch&&t instanceof Touch?t.identifier:-1,this.time=Date.now()}}const a={passive:!1};class r{constructor(t,{start:e=(()=>!0),move:i=(()=>{}),end:s=(()=>{})}){Object.defineProperty(this,"element",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"startCallback",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"moveCallback",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"endCallback",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"currentPointers",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"startPointers",{enumerable:!0,configurable:!0,writable:!0,value:[]}),this.element=t,this.startCallback=e,this.moveCallback=i,this.endCallback=s;for(const t of["onPointerStart","onTouchStart","onMove","onTouchEnd","onPointerEnd","onWindowBlur"])this[t]=this[t].bind(this);this.element.addEventListener("mousedown",this.onPointerStart,a),this.element.addEventListener("touchstart",this.onTouchStart,a),this.element.addEventListener("touchmove",this.onMove,a),this.element.addEventListener("touchend",this.onTouchEnd),this.element.addEventListener("touchcancel",this.onTouchEnd)}onPointerStart(t){if(!t.buttons||0!==t.button)return;const e=new o(t);this.currentPointers.some((t=>t.id===e.id))||this.triggerPointerStart(e,t)&&(window.addEventListener("mousemove",this.onMove),window.addEventListener("mouseup",this.onPointerEnd),window.addEventListener("blur",this.onWindowBlur))}onTouchStart(t){for(const e of Array.from(t.changedTouches||[]))this.triggerPointerStart(new o(e),t);window.addEventListener("blur",this.onWindowBlur)}onMove(t){const e=this.currentPointers.slice(),i="changedTouches"in t?Array.from(t.changedTouches||[]).map((t=>new o(t))):[new o(t)],s=[];for(const t of i){const e=this.currentPointers.findIndex((e=>e.id===t.id));e<0||(s.push(t),this.currentPointers[e]=t)}s.length&&this.moveCallback(t,this.currentPointers.slice(),e)}onPointerEnd(t){t.buttons>0&&0!==t.button||(this.triggerPointerEnd(t,new o(t)),window.removeEventListener("mousemove",this.onMove),window.removeEventListener("mouseup",this.onPointerEnd),window.removeEventListener("blur",this.onWindowBlur))}onTouchEnd(t){for(const e of Array.from(t.changedTouches||[]))this.triggerPointerEnd(t,new o(e))}triggerPointerStart(t,e){return!!this.startCallback(e,t,this.currentPointers.slice())&&(this.currentPointers.push(t),this.startPointers.push(t),!0)}triggerPointerEnd(t,e){const i=this.currentPointers.findIndex((t=>t.id===e.id));i<0||(this.currentPointers.splice(i,1),this.startPointers.splice(i,1),this.endCallback(t,e,this.currentPointers.slice()))}onWindowBlur(){this.clear()}clear(){for(;this.currentPointers.length;){const t=this.currentPointers[this.currentPointers.length-1];this.currentPointers.splice(this.currentPointers.length-1,1),this.startPointers.splice(this.currentPointers.length-1,1),this.endCallback(new Event("touchend",{bubbles:!0,cancelable:!0,clientX:t.clientX,clientY:t.clientY}),t,this.currentPointers.slice())}}stop(){this.element.removeEventListener("mousedown",this.onPointerStart,a),this.element.removeEventListener("touchstart",this.onTouchStart,a),this.element.removeEventListener("touchmove",this.onMove,a),this.element.removeEventListener("touchend",this.onTouchEnd),this.element.removeEventListener("touchcancel",this.onTouchEnd),window.removeEventListener("mousemove",this.onMove),window.removeEventListener("mouseup",this.onPointerEnd),window.removeEventListener("blur",this.onWindowBlur)}}function l(t,e){return e?Math.sqrt(Math.pow(e.clientX-t.clientX,2)+Math.pow(e.clientY-t.clientY,2)):0}function h(t,e){return e?{clientX:(t.clientX+e.clientX)/2,clientY:(t.clientY+e.clientY)/2}:t}const c=t=>"object"==typeof t&&null!==t&&t.constructor===Object&&"[object Object]"===Object.prototype.toString.call(t),d=(t,...e)=>{const i=e.length;for(let s=0;s<i;s++){const i=e[s]||{};Object.entries(i).forEach((([e,i])=>{const s=Array.isArray(i)?[]:{};t[e]||Object.assign(t,{[e]:s}),c(i)?Object.assign(t[e],d(s,i)):Array.isArray(i)?Object.assign(t,{[e]:[...i]}):Object.assign(t,{[e]:i})}))}return t},u=function(t,e){return t.split(".").reduce(((t,e)=>"object"==typeof t?t[e]:void 0),e)};class g{constructor(t={}){Object.defineProperty(this,"options",{enumerable:!0,configurable:!0,writable:!0,value:t}),Object.defineProperty(this,"events",{enumerable:!0,configurable:!0,writable:!0,value:new Map}),this.setOptions(t);for(const t of Object.getOwnPropertyNames(Object.getPrototypeOf(this)))t.startsWith("on")&&"function"==typeof this[t]&&(this[t]=this[t].bind(this))}setOptions(t){this.options=t?d({},this.constructor.defaults,t):{};for(const[t,e]of Object.entries(this.option("on")||{}))this.on(t,e)}option(t,...e){let i=u(t,this.options);return i&&"function"==typeof i&&(i=i.call(this,this,...e)),i}optionFor(t,e,i,...s){let n=u(e,t);var o;"string"!=typeof(o=n)||isNaN(o)||isNaN(parseFloat(o))||(n=parseFloat(n)),"true"===n&&(n=!0),"false"===n&&(n=!1),n&&"function"==typeof n&&(n=n.call(this,this,t,...s));let a=u(e,this.options);return a&&"function"==typeof a?n=a.call(this,this,t,...s,n):void 0===n&&(n=a),void 0===n?i:n}cn(t){const e=this.options.classes;return e&&e[t]||""}localize(t,e=[]){t=String(t).replace(/\{\{(\w+).?(\w+)?\}\}/g,((t,e,i)=>{let s="";return i?s=this.option(`${e[0]+e.toLowerCase().substring(1)}.l10n.${i}`):e&&(s=this.option(`l10n.${e}`)),s||(s=t),s}));for(let i=0;i<e.length;i++)t=t.split(e[i][0]).join(e[i][1]);return t=t.replace(/\{\{(.*?)\}\}/g,((t,e)=>e))}on(t,e){let i=[];"string"==typeof t?i=t.split(" "):Array.isArray(t)&&(i=t),this.events||(this.events=new Map),i.forEach((t=>{let i=this.events.get(t);i||(this.events.set(t,[]),i=[]),i.includes(e)||i.push(e),this.events.set(t,i)}))}off(t,e){let i=[];"string"==typeof t?i=t.split(" "):Array.isArray(t)&&(i=t),i.forEach((t=>{const i=this.events.get(t);if(Array.isArray(i)){const t=i.indexOf(e);t>-1&&i.splice(t,1)}}))}emit(t,...e){[...this.events.get(t)||[]].forEach((t=>t(this,...e))),"*"!==t&&this.emit("*",t,...e)}}Object.defineProperty(g,"version",{enumerable:!0,configurable:!0,writable:!0,value:"5.0.19"}),Object.defineProperty(g,"defaults",{enumerable:!0,configurable:!0,writable:!0,value:{}});class p extends g{constructor(t={}){super(t),Object.defineProperty(this,"plugins",{enumerable:!0,configurable:!0,writable:!0,value:{}})}attachPlugins(t={}){const e=new Map;for(const[i,s]of Object.entries(t)){const t=this.option(i),n=this.plugins[i];n||!1===t?n&&!1===t&&(n.detach(),delete this.plugins[i]):e.set(i,new s(this,t||{}))}for(const[t,i]of e)this.plugins[t]=i,i.attach();this.emit("attachPlugins")}detachPlugins(t){t=t||Object.keys(this.plugins);for(const e of t){const t=this.plugins[e];t&&t.detach(),delete this.plugins[e]}return this.emit("detachPlugins"),this}}var f;!function(t){t[t.Init=0]="Init",t[t.Error=1]="Error",t[t.Ready=2]="Ready",t[t.Panning=3]="Panning",t[t.Mousemove=4]="Mousemove",t[t.Destroy=5]="Destroy"}(f||(f={}));const m=["a","b","c","d","e","f"],b={content:null,width:"auto",height:"auto",panMode:"drag",touch:!0,dragMinThreshold:3,lockAxis:!1,mouseMoveFactor:1,mouseMoveFriction:.12,zoom:!0,pinchToZoom:!0,panOnlyZoomed:"auto",minScale:1,maxScale:2,friction:.25,dragFriction:.35,decelFriction:.05,click:"toggleZoom",dblClick:!1,wheel:"zoom",wheelLimit:7,spinner:!0,bounds:"auto",infinite:!1,rubberband:!0,bounce:!0,maxVelocity:75,transformParent:!1,classes:{content:"f-panzoom__content",isLoading:"is-loading",canZoomIn:"can-zoom_in",canZoomOut:"can-zoom_out",isDraggable:"is-draggable",isDragging:"is-dragging",inFullscreen:"in-fullscreen",htmlHasFullscreen:"with-panzoom-in-fullscreen"},l10n:{PANUP:"Move up",PANDOWN:"Move down",PANLEFT:"Move left",PANRIGHT:"Move right",ZOOMIN:"Zoom in",ZOOMOUT:"Zoom out",TOGGLEZOOM:"Toggle zoom level",TOGGLE1TO1:"Toggle zoom level",ITERATEZOOM:"Toggle zoom level",ROTATECCW:"Rotate counterclockwise",ROTATECW:"Rotate clockwise",FLIPX:"Flip horizontally",FLIPY:"Flip vertically",FITX:"Fit horizontally",FITY:"Fit vertically",RESET:"Reset",TOGGLEFS:"Toggle fullscreen"}},v='<div class="f-spinner"><svg viewBox="0 0 50 50"><circle cx="25" cy="25" r="20"></circle><circle cx="25" cy="25" r="20"></circle></svg></div>',y=t=>t&&null!==t&&t instanceof Element&&"nodeType"in t,x=(t,e)=>{t&&s(e).forEach((e=>{t.classList.remove(e)}))},w=(t,e)=>{t&&s(e).forEach((e=>{t.classList.add(e)}))},P={a:1,b:0,c:0,d:1,e:0,f:0};let T=null,S=null;class M extends p{get isTouchDevice(){return null===S&&(S=window.matchMedia("(hover: none)").matches),S}get isMobile(){return null===T&&(T=/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)),T}get panMode(){return"mousemove"!==this.options.panMode||this.isTouchDevice?"drag":"mousemove"}get panOnlyZoomed(){const t=this.options.panOnlyZoomed;return"auto"===t?this.isTouchDevice:t}get isInfinite(){return this.option("infinite")}get angle(){return 180*Math.atan2(this.current.b,this.current.a)/Math.PI||0}get targetAngle(){return 180*Math.atan2(this.target.b,this.target.a)/Math.PI||0}get scale(){const{a:t,b:e}=this.current;return Math.sqrt(t*t+e*e)||1}get targetScale(){const{a:t,b:e}=this.target;return Math.sqrt(t*t+e*e)||1}get minScale(){return this.option("minScale")||1}get fullScale(){const{contentRect:t}=this;return t.fullWidth/t.fitWidth||1}get maxScale(){return this.fullScale*(this.option("maxScale")||1)||1}get coverScale(){const{containerRect:t,contentRect:e}=this,i=Math.max(t.height/e.fitHeight,t.width/e.fitWidth)||1;return Math.min(this.fullScale,i)}get isScaling(){return Math.abs(this.targetScale-this.scale)>1e-5&&!this.isResting}get isContentLoading(){const t=this.content;return!!(t&&t instanceof HTMLImageElement)&&!t.complete}get isResting(){if(this.isBouncingX||this.isBouncingY)return!1;for(const t of m){const e="e"==t||"f"===t?.001:1e-5;if(Math.abs(this.target[t]-this.current[t])>e)return!1}return!(!this.ignoreBounds&&!this.checkBounds().inBounds)}constructor(t,e={},s={}){var n;if(super(e),Object.defineProperty(this,"pointerTracker",{enumerable:!0,configurable:!0,writable:!0,value:null}),Object.defineProperty(this,"resizeObserver",{enumerable:!0,configurable:!0,writable:!0,value:null}),Object.defineProperty(this,"updateTimer",{enumerable:!0,configurable:!0,writable:!0,value:null}),Object.defineProperty(this,"clickTimer",{enumerable:!0,configurable:!0,writable:!0,value:null}),Object.defineProperty(this,"rAF",{enumerable:!0,configurable:!0,writable:!0,value:null}),Object.defineProperty(this,"isTicking",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"friction",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"ignoreBounds",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"isBouncingX",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"isBouncingY",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"clicks",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"trackingPoints",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"pwt",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"cwd",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"pmme",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"state",{enumerable:!0,configurable:!0,writable:!0,value:f.Init}),Object.defineProperty(this,"isDragging",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"container",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"content",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"spinner",{enumerable:!0,configurable:!0,writable:!0,value:null}),Object.defineProperty(this,"containerRect",{enumerable:!0,configurable:!0,writable:!0,value:{width:0,height:0,innerWidth:0,innerHeight:0}}),Object.defineProperty(this,"contentRect",{enumerable:!0,configurable:!0,writable:!0,value:{top:0,right:0,bottom:0,left:0,fullWidth:0,fullHeight:0,fitWidth:0,fitHeight:0,width:0,height:0}}),Object.defineProperty(this,"dragStart",{enumerable:!0,configurable:!0,writable:!0,value:{x:0,y:0,top:0,left:0,time:0}}),Object.defineProperty(this,"dragOffset",{enumerable:!0,configurable:!0,writable:!0,value:{x:0,y:0,time:0}}),Object.defineProperty(this,"current",{enumerable:!0,configurable:!0,writable:!0,value:Object.assign({},P)}),Object.defineProperty(this,"target",{enumerable:!0,configurable:!0,writable:!0,value:Object.assign({},P)}),Object.defineProperty(this,"velocity",{enumerable:!0,configurable:!0,writable:!0,value:{a:0,b:0,c:0,d:0,e:0,f:0}}),Object.defineProperty(this,"lockedAxis",{enumerable:!0,configurable:!0,writable:!0,value:!1}),!t)throw new Error("Container Element Not Found");this.container=t,this.initContent(),this.attachPlugins(Object.assign(Object.assign({},M.Plugins),s)),this.emit("init");const o=this.content;if(o.addEventListener("load",this.onLoad),o.addEventListener("error",this.onError),this.isContentLoading){if(this.option("spinner")){t.classList.add(this.cn("isLoading"));const e=i(v);!t.contains(o)||o.parentElement instanceof HTMLPictureElement?this.spinner=t.appendChild(e):this.spinner=(null===(n=o.parentElement)||void 0===n?void 0:n.insertBefore(e,o))||null}this.emit("beforeLoad")}else queueMicrotask((()=>{this.enable()}))}initContent(){const{container:t}=this,e=this.cn("content");let i=this.option("content")||t.querySelector(`.${e}`);if(i||(i=t.querySelector("img,picture")||t.firstElementChild,i&&w(i,e)),i instanceof HTMLPictureElement&&(i=i.querySelector("img")),!i)throw new Error("No content found");this.content=i}onLoad(){this.spinner&&(this.spinner.remove(),this.spinner=null),this.option("spinner")&&this.container.classList.remove(this.cn("isLoading")),this.emit("afterLoad"),this.state===f.Init?this.enable():this.updateMetrics()}onError(){this.state!==f.Destroy&&(this.spinner&&(this.spinner.remove(),this.spinner=null),this.stop(),this.detachEvents(),this.state=f.Error,this.emit("error"))}attachObserver(){var t;const e=()=>Math.abs(this.containerRect.width-this.container.getBoundingClientRect().width)>.1||Math.abs(this.containerRect.height-this.container.getBoundingClientRect().height)>.1;this.resizeObserver||void 0===window.ResizeObserver||(this.resizeObserver=new ResizeObserver((()=>{this.updateTimer||(e()?(this.onResize(),this.isMobile&&(this.updateTimer=setTimeout((()=>{e()&&this.onResize(),this.updateTimer=null}),500))):this.updateTimer&&(clearTimeout(this.updateTimer),this.updateTimer=null))}))),null===(t=this.resizeObserver)||void 0===t||t.observe(this.container)}detachObserver(){var t;null===(t=this.resizeObserver)||void 0===t||t.disconnect()}attachEvents(){const{container:t}=this;t.addEventListener("click",this.onClick,{passive:!1,capture:!1}),t.addEventListener("wheel",this.onWheel,{passive:!1}),this.pointerTracker=new r(t,{start:this.onPointerDown,move:this.onPointerMove,end:this.onPointerUp}),document.addEventListener("mousemove",this.onMouseMove)}detachEvents(){var t;const{container:e}=this;e.removeEventListener("click",this.onClick,{passive:!1,capture:!1}),e.removeEventListener("wheel",this.onWheel,{passive:!1}),null===(t=this.pointerTracker)||void 0===t||t.stop(),this.pointerTracker=null,document.removeEventListener("mousemove",this.onMouseMove),document.removeEventListener("keydown",this.onKeydown,!0),this.clickTimer&&(clearTimeout(this.clickTimer),this.clickTimer=null),this.updateTimer&&(clearTimeout(this.updateTimer),this.updateTimer=null)}animate(){const t=this.friction;this.setTargetForce();const e=this.option("maxVelocity");for(const i of m)t?(this.velocity[i]*=1-t,e&&!this.isScaling&&(this.velocity[i]=Math.max(Math.min(this.velocity[i],e),-1*e)),this.current[i]+=this.velocity[i]):this.current[i]=this.target[i];this.setTransform(),this.setEdgeForce(),!this.isResting||this.isDragging?this.rAF=requestAnimationFrame((()=>this.animate())):this.stop("current")}setTargetForce(){for(const t of m)"e"===t&&this.isBouncingX||"f"===t&&this.isBouncingY||(this.velocity[t]=(1/(1-this.friction)-1)*(this.target[t]-this.current[t]))}checkBounds(t=0,e=0){const{current:i}=this,s=i.e+t,n=i.f+e,o=this.getBounds(),{x:a,y:r}=o,l=a.min,h=a.max,c=r.min,d=r.max;let u=0,g=0;return l!==1/0&&s<l?u=l-s:h!==1/0&&s>h&&(u=h-s),c!==1/0&&n<c?g=c-n:d!==1/0&&n>d&&(g=d-n),Math.abs(u)<.001&&(u=0),Math.abs(g)<.001&&(g=0),Object.assign(Object.assign({},o),{xDiff:u,yDiff:g,inBounds:!u&&!g})}clampTargetBounds(){const{target:t}=this,{x:e,y:i}=this.getBounds();e.min!==1/0&&(t.e=Math.max(t.e,e.min)),e.max!==1/0&&(t.e=Math.min(t.e,e.max)),i.min!==1/0&&(t.f=Math.max(t.f,i.min)),i.max!==1/0&&(t.f=Math.min(t.f,i.max))}calculateContentDim(t=this.current){const{content:e,contentRect:i}=this,{fitWidth:s,fitHeight:n,fullWidth:o,fullHeight:a}=i;let r=o,l=a;if(this.option("zoom")||0!==this.angle){const i=!(e instanceof HTMLImageElement)&&("none"===window.getComputedStyle(e).maxWidth||"none"===window.getComputedStyle(e).maxHeight),h=i?o:s,c=i?a:n,d=this.getMatrix(t),u=new DOMPoint(0,0).matrixTransform(d),g=new DOMPoint(0+h,0).matrixTransform(d),p=new DOMPoint(0+h,0+c).matrixTransform(d),f=new DOMPoint(0,0+c).matrixTransform(d),m=Math.abs(p.x-u.x),b=Math.abs(p.y-u.y),v=Math.abs(f.x-g.x),y=Math.abs(f.y-g.y);r=Math.max(m,v),l=Math.max(b,y)}return{contentWidth:r,contentHeight:l}}setEdgeForce(){if(this.ignoreBounds||this.isDragging||"mousemove"===this.panMode||this.targetScale<this.scale)return this.isBouncingX=!1,void(this.isBouncingY=!1);const{target:t}=this,{x:e,y:i,xDiff:s,yDiff:n}=this.checkBounds();const o=this.option("maxVelocity");let a=this.velocity.e,r=this.velocity.f;0!==s?(this.isBouncingX=!0,s*a<=0?a+=.14*s:(a=.14*s,e.min!==1/0&&(this.target.e=Math.max(t.e,e.min)),e.max!==1/0&&(this.target.e=Math.min(t.e,e.max))),o&&(a=Math.max(Math.min(a,o),-1*o))):this.isBouncingX=!1,0!==n?(this.isBouncingY=!0,n*r<=0?r+=.14*n:(r=.14*n,i.min!==1/0&&(this.target.f=Math.max(t.f,i.min)),i.max!==1/0&&(this.target.f=Math.min(t.f,i.max))),o&&(r=Math.max(Math.min(r,o),-1*o))):this.isBouncingY=!1,this.isBouncingX&&(this.velocity.e=a),this.isBouncingY&&(this.velocity.f=r)}enable(){const{content:t}=this,e=new DOMMatrixReadOnly(window.getComputedStyle(t).transform);for(const t of m)this.current[t]=this.target[t]=e[t];this.updateMetrics(),this.attachObserver(),this.attachEvents(),this.state=f.Ready,this.emit("ready")}onClick(t){var e;this.isDragging&&(null===(e=this.pointerTracker)||void 0===e||e.clear(),this.trackingPoints=[],this.startDecelAnim());const i=t.target;if(!i||t.defaultPrevented)return;if(i&&i.hasAttribute("disabled"))return t.preventDefault(),void t.stopPropagation();if((()=>{const t=window.getSelection();return t&&"Range"===t.type})()&&!i.closest("button"))return;const s=i.closest("[data-panzoom-action]"),n=i.closest("[data-panzoom-change]"),o=s||n,a=o&&y(o)?o.dataset:null;if(a){const e=a.panzoomChange,i=a.panzoomAction;if((e||i)&&t.preventDefault(),e){let t={};try{t=JSON.parse(e)}catch(t){console&&console.warn("The given data was not valid JSON")}return void this.applyChange(t)}if(i)return void(this[i]&&this[i]())}if(Math.abs(this.dragOffset.x)>3||Math.abs(this.dragOffset.y)>3)return t.preventDefault(),void t.stopPropagation();const r=this.content.getBoundingClientRect();if(this.dragStart.time&&!this.canZoomOut()&&(Math.abs(r.x-this.dragStart.x)>2||Math.abs(r.y-this.dragStart.y)>2))return;this.dragStart.time=0;const l=e=>{this.option("zoom")&&e&&"string"==typeof e&&/(iterateZoom)|(toggle(Zoom|Full|Cover|Max)|(zoomTo(Fit|Cover|Max)))/.test(e)&&"function"==typeof this[e]&&(t.preventDefault(),this[e]({event:t}))},h=this.option("click",t),c=this.option("dblClick",t);c?(this.clicks++,1==this.clicks&&(this.clickTimer=setTimeout((()=>{1===this.clicks?(this.emit("click",t),!t.defaultPrevented&&h&&l(h)):(this.emit("dblClick",t),t.defaultPrevented||l(c)),this.clicks=0,this.clickTimer=null}),350))):(this.emit("click",t),!t.defaultPrevented&&h&&l(h))}addTrackingPoint(t){const e=this.trackingPoints.filter((t=>t.time>Date.now()-100));e.push(t),this.trackingPoints=e}onPointerDown(t,e,i){var s;this.pwt=0,this.dragOffset={x:0,y:0,time:0},this.trackingPoints=[];const n=this.content.getBoundingClientRect();if(this.dragStart={x:n.x,y:n.y,top:n.top,left:n.left,time:Date.now()},this.clickTimer)return!1;if("mousemove"===this.panMode&&this.targetScale>1)return t.preventDefault(),t.stopPropagation(),!1;if(!i.length){const e=t.composedPath()[0];if(["A","TEXTAREA","OPTION","INPUT","SELECT","VIDEO"].includes(e.nodeName)||e.closest("[contenteditable]")||e.closest("[data-selectable]")||e.closest("[data-draggable]")||e.closest("[data-panzoom-change]")||e.closest("[data-panzoom-action]"))return!1;null===(s=window.getSelection())||void 0===s||s.removeAllRanges()}if("mousedown"===t.type)t.preventDefault();else if(Math.abs(this.velocity.a)>.3)return!1;return this.target.e=this.current.e,this.target.f=this.current.f,this.stop(),this.isDragging||(this.isDragging=!0,this.addTrackingPoint(e),this.emit("touchStart",t)),!0}onPointerMove(i,s,n){if(!1===this.option("touch",i))return;if(!this.isDragging)return;if(s.length<2&&this.panOnlyZoomed&&t(this.targetScale)<=t(this.minScale))return;if(this.emit("touchMove",i),i.defaultPrevented)return;this.addTrackingPoint(s[0]);const{content:o}=this,a=h(n[0],n[1]),r=h(s[0],s[1]);let c=0,d=0;if(s.length>1){const t=o.getBoundingClientRect();c=a.clientX-t.left-.5*t.width,d=a.clientY-t.top-.5*t.height}const u=l(n[0],n[1]),g=l(s[0],s[1]);let p=u?g/u:1,f=r.clientX-a.clientX,m=r.clientY-a.clientY;this.dragOffset.x+=f,this.dragOffset.y+=m,this.dragOffset.time=Date.now()-this.dragStart.time;let b=t(this.targetScale)===t(this.minScale)&&this.option("lockAxis");if(b&&!this.lockedAxis)if("xy"===b||"y"===b||"touchmove"===i.type){if(Math.abs(this.dragOffset.x)<6&&Math.abs(this.dragOffset.y)<6)return void i.preventDefault();const t=Math.abs(180*Math.atan2(this.dragOffset.y,this.dragOffset.x)/Math.PI);this.lockedAxis=t>45&&t<135?"y":"x",this.dragOffset.x=0,this.dragOffset.y=0,f=0,m=0}else this.lockedAxis=b;if(e(i.target,this.content)&&(b="x",this.dragOffset.y=0),b&&"xy"!==b&&this.lockedAxis!==b&&t(this.targetScale)===t(this.minScale))return;i.cancelable&&i.preventDefault(),this.container.classList.add(this.cn("isDragging"));const v=this.checkBounds(f,m);this.option("rubberband")?("x"!==this.isInfinite&&(v.xDiff>0&&f<0||v.xDiff<0&&f>0)&&(f*=Math.max(0,.5-Math.abs(.75/this.contentRect.fitWidth*v.xDiff))),"y"!==this.isInfinite&&(v.yDiff>0&&m<0||v.yDiff<0&&m>0)&&(m*=Math.max(0,.5-Math.abs(.75/this.contentRect.fitHeight*v.yDiff)))):(v.xDiff&&(f=0),v.yDiff&&(m=0));const y=this.targetScale,x=this.minScale,w=this.maxScale;y<.5*x&&(p=Math.max(p,x)),y>1.5*w&&(p=Math.min(p,w)),"y"===this.lockedAxis&&t(y)===t(x)&&(f=0),"x"===this.lockedAxis&&t(y)===t(x)&&(m=0),this.applyChange({originX:c,originY:d,panX:f,panY:m,scale:p,friction:this.option("dragFriction"),ignoreBounds:!0})}onPointerUp(t,i,s){if(s.length)return this.dragOffset.x=0,this.dragOffset.y=0,void(this.trackingPoints=[]);this.container.classList.remove(this.cn("isDragging")),this.isDragging&&(this.addTrackingPoint(i),this.panOnlyZoomed&&this.contentRect.width-this.contentRect.fitWidth<1&&this.contentRect.height-this.contentRect.fitHeight<1&&(this.trackingPoints=[]),e(t.target,this.content)&&"y"===this.lockedAxis&&(this.trackingPoints=[]),this.emit("touchEnd",t),this.isDragging=!1,this.lockedAxis=!1,this.state!==f.Destroy&&(t.defaultPrevented||this.startDecelAnim()))}startDecelAnim(){var e;const i=this.isScaling;this.rAF&&(cancelAnimationFrame(this.rAF),this.rAF=null),this.isBouncingX=!1,this.isBouncingY=!1;for(const t of m)this.velocity[t]=0;this.target.e=this.current.e,this.target.f=this.current.f,x(this.container,"is-scaling"),x(this.container,"is-animating"),this.isTicking=!1;const{trackingPoints:s}=this,n=s[0],o=s[s.length-1];let a=0,r=0,l=0;o&&n&&(a=o.clientX-n.clientX,r=o.clientY-n.clientY,l=o.time-n.time);const h=(null===(e=window.visualViewport)||void 0===e?void 0:e.scale)||1;1!==h&&(a*=h,r*=h);let c=0,d=0,u=0,g=0,p=this.option("decelFriction");const f=this.targetScale;if(l>0){u=Math.abs(a)>3?a/(l/30):0,g=Math.abs(r)>3?r/(l/30):0;const t=this.option("maxVelocity");t&&(u=Math.max(Math.min(u,t),-1*t),g=Math.max(Math.min(g,t),-1*t))}u&&(c=u/(1/(1-p)-1)),g&&(d=g/(1/(1-p)-1)),("y"===this.option("lockAxis")||"xy"===this.option("lockAxis")&&"y"===this.lockedAxis&&t(f)===this.minScale)&&(c=u=0),("x"===this.option("lockAxis")||"xy"===this.option("lockAxis")&&"x"===this.lockedAxis&&t(f)===this.minScale)&&(d=g=0);const b=this.dragOffset.x,v=this.dragOffset.y,y=this.option("dragMinThreshold")||0;Math.abs(b)<y&&Math.abs(v)<y&&(c=d=0,u=g=0),(f<this.minScale-1e-5||f>this.maxScale+1e-5||i&&!c&&!d)&&(p=.35),this.applyChange({panX:c,panY:d,friction:p}),this.emit("decel",u,g,b,v)}onWheel(t){var e=[-t.deltaX||0,-t.deltaY||0,-t.detail||0].reduce((function(t,e){return Math.abs(e)>Math.abs(t)?e:t}));const i=Math.max(-1,Math.min(1,e));if(this.emit("wheel",t,i),"mousemove"===this.panMode)return;if(t.defaultPrevented)return;const s=this.option("wheel");"pan"===s?(t.preventDefault(),this.panOnlyZoomed&&!this.canZoomOut()||this.applyChange({panX:2*-t.deltaX,panY:2*-t.deltaY,bounce:!1})):"zoom"===s&&!1!==this.option("zoom")&&this.zoomWithWheel(t)}onMouseMove(t){this.panWithMouse(t)}onKeydown(t){"Escape"===t.key&&this.toggleFS()}onResize(){this.updateMetrics(),this.checkBounds().inBounds||this.requestTick()}setTransform(){this.emit("beforeTransform");const{current:e,target:i,content:s,contentRect:n}=this,o=Object.assign({},P);for(const s of m){const n="e"==s||"f"===s?1e3:1e5;o[s]=t(e[s],n),Math.abs(i[s]-e[s])<("e"==s||"f"===s?.51:.001)&&(e[s]=i[s])}let{a:a,b:r,c:l,d:h,e:c,f:d}=o,u=`matrix(${a}, ${r}, ${l}, ${h}, ${c}, ${d})`,g=s.parentElement instanceof HTMLPictureElement?s.parentElement:s;if(this.option("transformParent")&&(g=g.parentElement||g),g.style.transform===u)return;g.style.transform=u;const{contentWidth:p,contentHeight:f}=this.calculateContentDim();n.width=p,n.height=f,this.emit("afterTransform")}updateMetrics(e=!1){var i;if(!this||this.state===f.Destroy)return;if(this.isContentLoading)return;const s=Math.max(1,(null===(i=window.visualViewport)||void 0===i?void 0:i.scale)||1),{container:n,content:o}=this,a=o instanceof HTMLImageElement,r=n.getBoundingClientRect(),l=getComputedStyle(this.container);let h=r.width*s,c=r.height*s;const d=parseFloat(l.paddingTop)+parseFloat(l.paddingBottom),u=h-(parseFloat(l.paddingLeft)+parseFloat(l.paddingRight)),g=c-d;this.containerRect={width:h,height:c,innerWidth:u,innerHeight:g};let p=this.option("width")||"auto",m=this.option("height")||"auto";"auto"===p&&(p=parseFloat(o.dataset.width||"")||(t=>{let e=0;return e=t instanceof HTMLImageElement?t.naturalWidth:t instanceof SVGElement?t.width.baseVal.value:Math.max(t.offsetWidth,t.scrollWidth),e||0})(o)),"auto"===m&&(m=parseFloat(o.dataset.height||"")||(t=>{let e=0;return e=t instanceof HTMLImageElement?t.naturalHeight:t instanceof SVGElement?t.height.baseVal.value:Math.max(t.offsetHeight,t.scrollHeight),e||0})(o));let b=o.parentElement instanceof HTMLPictureElement?o.parentElement:o;this.option("transformParent")&&(b=b.parentElement||b);const v=b.getAttribute("style")||"";b.style.setProperty("transform","none","important"),a&&(b.style.width="",b.style.height=""),b.offsetHeight;const y=o.getBoundingClientRect();let x=y.width*s,w=y.height*s,P=0,T=0;a&&(Math.abs(p-x)>1||Math.abs(m-w)>1)&&({width:x,height:w,top:P,left:T}=((t,e,i,s)=>{const n=i/s;return n>t/e?(i=t,s=t/n):(i=e*n,s=e),{width:i,height:s,top:.5*(e-s),left:.5*(t-i)}})(x,w,p,m)),this.contentRect=Object.assign(Object.assign({},this.contentRect),{top:y.top-r.top+P,bottom:r.bottom-y.bottom+P,left:y.left-r.left+T,right:r.right-y.right+T,fitWidth:x,fitHeight:w,width:x,height:w,fullWidth:p,fullHeight:m}),b.style.cssText=v,a&&(b.style.width=`${x}px`,b.style.height=`${w}px`),this.setTransform(),!0!==e&&this.emit("refresh"),this.ignoreBounds||(t(this.targetScale)<t(this.minScale)?this.zoomTo(this.minScale,{friction:0}):this.targetScale>this.maxScale?this.zoomTo(this.maxScale,{friction:0}):this.state===f.Init||this.checkBounds().inBounds||this.requestTick()),this.updateControls()}getBounds(){const e=this.option("bounds");if("auto"!==e)return e;const{contentWidth:i,contentHeight:s}=this.calculateContentDim(this.target);let n=0,o=0,a=0,r=0;const l=this.option("infinite");if(!0===l||this.lockedAxis&&l===this.lockedAxis)n=-1/0,a=1/0,o=-1/0,r=1/0;else{let{containerRect:e,contentRect:l}=this,h=t(this.contentRect.fitWidth*this.targetScale,1e3),c=t(this.contentRect.fitHeight*this.targetScale,1e3),{innerWidth:d,innerHeight:u}=e;if(this.containerRect.width===h&&(d=e.width),this.containerRect.width===c&&(u=e.height),i>d){a=.5*(i-d),n=-1*a;let t=.5*(l.right-l.left);n+=t,a+=t}if(this.contentRect.fitWidth>d&&i<d&&(n-=.5*(this.contentRect.fitWidth-d),a-=.5*(this.contentRect.fitWidth-d)),s>u){r=.5*(s-u),o=-1*r;let t=.5*(l.bottom-l.top);o+=t,r+=t}this.contentRect.fitHeight>u&&s<u&&(n-=.5*(this.contentRect.fitHeight-u),a-=.5*(this.contentRect.fitHeight-u))}return{x:{min:n,max:a},y:{min:o,max:r}}}updateControls(){const e=this,i=e.container,{panMode:s,contentRect:o,fullScale:a,targetScale:r,coverScale:l,maxScale:h,minScale:c}=e;let d={toggleMax:r-c<.5*(h-c)?h:c,toggleCover:r-c<.5*(l-c)?l:c,toggleZoom:r-c<.5*(a-c)?a:c}[e.option("click")||""]||c,u=e.canZoomIn(),g=e.canZoomOut(),p=g&&"drag"===s;t(r)<t(c)&&!this.panOnlyZoomed&&(p=!0),(t(o.width,1)>t(o.fitWidth,1)||t(o.height,1)>t(o.fitHeight,1))&&(p=!0),t(o.width*r,1)<t(o.fitWidth,1)&&(p=!1),"mousemove"===s&&(p=!1);let f=u&&t(d)>t(r),m=!f&&!p&&g&&t(d)<t(r);n(i,this.cn("canZoomIn"),f),n(i,this.cn("canZoomOut"),m),n(i,this.cn("isDraggable"),p);for(const t of i.querySelectorAll('[data-panzoom-action="zoomIn"]'))u?(t.removeAttribute("disabled"),t.removeAttribute("tabindex")):(t.setAttribute("disabled",""),t.setAttribute("tabindex","-1"));for(const t of i.querySelectorAll('[data-panzoom-action="zoomOut"]'))g?(t.removeAttribute("disabled"),t.removeAttribute("tabindex")):(t.setAttribute("disabled",""),t.setAttribute("tabindex","-1"));for(const t of i.querySelectorAll('[data-panzoom-action="toggleZoom"],[data-panzoom-action="iterateZoom"]')){u||g?(t.removeAttribute("disabled"),t.removeAttribute("tabindex")):(t.setAttribute("disabled",""),t.setAttribute("tabindex","-1"));const e=t.querySelector("g");e&&(e.style.display=u?"":"none")}}panTo({x:t=this.target.e,y:e=this.target.f,scale:i=this.targetScale,friction:s=this.option("friction"),angle:n=0,originX:o=0,originY:a=0,flipX:r=!1,flipY:l=!1,ignoreBounds:h=!1}){this.state!==f.Destroy&&this.applyChange({panX:t-this.target.e,panY:e-this.target.f,scale:i/this.targetScale,angle:n,originX:o,originY:a,friction:s,flipX:r,flipY:l,ignoreBounds:h})}applyChange({panX:e=0,panY:i=0,scale:s=1,angle:n=0,originX:o=-this.current.e,originY:a=-this.current.f,friction:r=this.option("friction"),flipX:l=!1,flipY:h=!1,ignoreBounds:c=!1,bounce:d=this.option("bounce")}){if(this.state===f.Destroy)return;this.rAF&&(cancelAnimationFrame(this.rAF),this.rAF=null),this.friction=r||0,this.ignoreBounds=c;const{current:u}=this,g=u.e,p=u.f,b=this.getMatrix(this.target);let v=(new DOMMatrix).translate(g,p).translate(o,a).translate(e,i);if(this.option("zoom")){if(!c){const t=this.targetScale,e=this.minScale,i=this.maxScale;t*s<e&&(s=e/t),t*s>i&&(s=i/t)}v=v.scale(s)}v=v.translate(-o,-a).translate(-g,-p).multiply(b),n&&(v=v.rotate(n)),l&&(v=v.scale(-1,1)),h&&(v=v.scale(1,-1));for(const e of m)"e"!==e&&"f"!==e&&(v[e]>this.minScale+1e-5||v[e]<this.minScale-1e-5)?this.target[e]=v[e]:this.target[e]=t(v[e],1e3);(this.targetScale<this.scale||Math.abs(s-1)>.1||"mousemove"===this.panMode||!1===d)&&!c&&this.clampTargetBounds(),this.isResting||(this.state=f.Panning,this.requestTick())}stop(t=!1){if(this.state===f.Init||this.state===f.Destroy)return;const e=this.isTicking;this.rAF&&(cancelAnimationFrame(this.rAF),this.rAF=null),this.isBouncingX=!1,this.isBouncingY=!1;for(const e of m)this.velocity[e]=0,"current"===t?this.current[e]=this.target[e]:"target"===t&&(this.target[e]=this.current[e]);this.setTransform(),x(this.container,"is-scaling"),x(this.container,"is-animating"),this.isTicking=!1,this.state=f.Ready,e&&(this.emit("endAnimation"),this.updateControls())}requestTick(){this.isTicking||(this.emit("startAnimation"),this.updateControls(),w(this.container,"is-animating"),this.isScaling&&w(this.container,"is-scaling")),this.isTicking=!0,this.rAF||(this.rAF=requestAnimationFrame((()=>this.animate())))}panWithMouse(e,i=this.option("mouseMoveFriction")){if(this.pmme=e,"mousemove"!==this.panMode||!e)return;if(t(this.targetScale)<=t(this.minScale))return;this.emit("mouseMove",e);const{container:s,containerRect:n,contentRect:o}=this,a=n.width,r=n.height,l=s.getBoundingClientRect(),h=(e.clientX||0)-l.left,c=(e.clientY||0)-l.top;let{contentWidth:d,contentHeight:u}=this.calculateContentDim(this.target);const g=this.option("mouseMoveFactor");g>1&&(d!==a&&(d*=g),u!==r&&(u*=g));let p=.5*(d-a)-h/a*100/100*(d-a);p+=.5*(o.right-o.left);let f=.5*(u-r)-c/r*100/100*(u-r);f+=.5*(o.bottom-o.top),this.applyChange({panX:p-this.target.e,panY:f-this.target.f,friction:i})}zoomWithWheel(e){if(this.state===f.Destroy||this.state===f.Init)return;const i=Date.now();if(i-this.pwt<45)return void e.preventDefault();this.pwt=i;var s=[-e.deltaX||0,-e.deltaY||0,-e.detail||0].reduce((function(t,e){return Math.abs(e)>Math.abs(t)?e:t}));const n=Math.max(-1,Math.min(1,s)),{targetScale:o,maxScale:a,minScale:r}=this;let l=o*(100+45*n)/100;t(l)<t(r)&&t(o)<=t(r)?(this.cwd+=Math.abs(n),l=r):t(l)>t(a)&&t(o)>=t(a)?(this.cwd+=Math.abs(n),l=a):(this.cwd=0,l=Math.max(Math.min(l,a),r)),this.cwd>this.option("wheelLimit")||(e.preventDefault(),t(l)!==t(o)&&this.zoomTo(l,{event:e}))}canZoomIn(){return this.option("zoom")&&(t(this.contentRect.width,1)<t(this.contentRect.fitWidth,1)||t(this.targetScale)<t(this.maxScale))}canZoomOut(){return this.option("zoom")&&t(this.targetScale)>t(this.minScale)}zoomIn(t=1.25,e){this.zoomTo(this.targetScale*t,e)}zoomOut(t=.8,e){this.zoomTo(this.targetScale*t,e)}zoomToFit(t){this.zoomTo("fit",t)}zoomToCover(t){this.zoomTo("cover",t)}zoomToFull(t){this.zoomTo("full",t)}zoomToMax(t){this.zoomTo("max",t)}toggleZoom(t){this.zoomTo(this.targetScale-this.minScale<.5*(this.fullScale-this.minScale)?"full":"fit",t)}toggleMax(t){this.zoomTo(this.targetScale-this.minScale<.5*(this.maxScale-this.minScale)?"max":"fit",t)}toggleCover(t){this.zoomTo(this.targetScale-this.minScale<.5*(this.coverScale-this.minScale)?"cover":"fit",t)}iterateZoom(t){this.zoomTo("next",t)}zoomTo(t=1,{friction:e="auto",originX:i=0,originY:s=0,event:n}={}){if(this.isContentLoading||this.state===f.Destroy)return;const{targetScale:o}=this;this.stop();let a=1;if("mousemove"===this.panMode&&(n=this.pmme||n),n){const t=this.content.getBoundingClientRect(),e=n.clientX||0,o=n.clientY||0;i=e-t.left-.5*t.width,s=o-t.top-.5*t.height}const r=this.fullScale,l=this.maxScale;let h=this.coverScale;"number"==typeof t?a=t/o:("next"===t&&(r-h<.2&&(h=r),t=o<r-1e-5?"full":o<l-1e-5?"max":"fit"),a="full"===t?r/o||1:"cover"===t?h/o||1:"max"===t?l/o||1:1/o||1),e="auto"===e?a>1?.15:.25:e,this.applyChange({scale:a,originX:i,originY:s,friction:e}),n&&"mousemove"===this.panMode&&this.panWithMouse(n,e)}rotateCCW(){this.applyChange({angle:-90})}rotateCW(){this.applyChange({angle:90})}flipX(){this.applyChange({flipX:!0})}flipY(){this.applyChange({flipY:!0})}fitX(){this.stop("target");const{containerRect:t,contentRect:e,target:i}=this;this.applyChange({panX:.5*t.width-(e.left+.5*e.fitWidth)-i.e,panY:.5*t.height-(e.top+.5*e.fitHeight)-i.f,scale:t.width/e.fitWidth/this.targetScale,originX:0,originY:0,ignoreBounds:!0})}fitY(){this.stop("target");const{containerRect:t,contentRect:e,target:i}=this;this.applyChange({panX:.5*t.width-(e.left+.5*e.fitWidth)-i.e,panY:.5*t.innerHeight-(e.top+.5*e.fitHeight)-i.f,scale:t.height/e.fitHeight/this.targetScale,originX:0,originY:0,ignoreBounds:!0})}toggleFS(){const{container:t}=this,e=this.cn("inFullscreen"),i=this.cn("htmlHasFullscreen");t.classList.toggle(e);const s=t.classList.contains(e);s?(document.documentElement.classList.add(i),document.addEventListener("keydown",this.onKeydown,!0)):(document.documentElement.classList.remove(i),document.removeEventListener("keydown",this.onKeydown,!0)),this.updateMetrics(),this.emit(s?"enterFS":"exitFS")}getMatrix(t=this.current){const{a:e,b:i,c:s,d:n,e:o,f:a}=t;return new DOMMatrix([e,i,s,n,o,a])}reset(t){if(this.state!==f.Init&&this.state!==f.Destroy){this.stop("current");for(const t of m)this.target[t]=P[t];this.target.a=this.minScale,this.target.d=this.minScale,this.clampTargetBounds(),this.isResting||(this.friction=void 0===t?this.option("friction"):t,this.state=f.Panning,this.requestTick())}}destroy(){this.stop(),this.state=f.Destroy,this.detachEvents(),this.detachObserver();const{container:t,content:e}=this,i=this.option("classes")||{};for(const e of Object.values(i))t.classList.remove(e+"");e&&(e.removeEventListener("load",this.onLoad),e.removeEventListener("error",this.onError)),this.detachPlugins()}}Object.defineProperty(M,"defaults",{enumerable:!0,configurable:!0,writable:!0,value:b}),Object.defineProperty(M,"Plugins",{enumerable:!0,configurable:!0,writable:!0,value:{}});const O=function(t,e){let i=!0;return(...s)=>{i&&(i=!1,t(...s),setTimeout((()=>{i=!0}),e))}},E=(t,e)=>{let i=[];return t.childNodes.forEach((t=>{t.nodeType!==Node.ELEMENT_NODE||e&&!t.matches(e)||i.push(t)})),i},z={viewport:null,track:null,enabled:!0,slides:[],axis:"x",transition:"fade",preload:1,slidesPerPage:"auto",initialPage:0,friction:.12,Panzoom:{decelFriction:.12},center:!0,infinite:!0,fill:!0,dragFree:!1,adaptiveHeight:!1,direction:"ltr",classes:{container:"f-carousel",viewport:"f-carousel__viewport",track:"f-carousel__track",slide:"f-carousel__slide",isLTR:"is-ltr",isRTL:"is-rtl",isHorizontal:"is-horizontal",isVertical:"is-vertical",inTransition:"in-transition",isSelected:"is-selected"},l10n:{NEXT:"Next slide",PREV:"Previous slide",GOTO:"Go to slide #%d"}};var k;!function(t){t[t.Init=0]="Init",t[t.Ready=1]="Ready",t[t.Destroy=2]="Destroy"}(k||(k={}));const R=t=>{if("string"==typeof t&&(t={html:t}),!(t instanceof String||t instanceof HTMLElement)){const e=t.thumb;void 0!==e&&("string"==typeof e&&(t.thumbSrc=e),e instanceof HTMLImageElement&&(t.thumbEl=e,t.thumbElSrc=e.src,t.thumbSrc=e.src),delete t.thumb)}return Object.assign({html:"",el:null,isDom:!1,class:"",index:-1,dim:0,gap:0,pos:0,transition:!1},t)},L=(t={})=>Object.assign({index:-1,slides:[],dim:0,pos:-1},t);class A extends g{constructor(t,e){super(e),Object.defineProperty(this,"instance",{enumerable:!0,configurable:!0,writable:!0,value:t})}attach(){}detach(){}}const D={classes:{list:"f-carousel__dots",isDynamic:"is-dynamic",hasDots:"has-dots",dot:"f-carousel__dot",isBeforePrev:"is-before-prev",isPrev:"is-prev",isCurrent:"is-current",isNext:"is-next",isAfterNext:"is-after-next"},dotTpl:'<button type="button" data-carousel-page="%i" aria-label="{{GOTO}}"><span class="f-carousel__dot" aria-hidden="true"></span></button>',dynamicFrom:11,maxCount:1/0,minCount:2};class C extends A{constructor(){super(...arguments),Object.defineProperty(this,"isDynamic",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"list",{enumerable:!0,configurable:!0,writable:!0,value:null})}onRefresh(){this.refresh()}build(){let t=this.list;return t||(t=document.createElement("ul"),w(t,this.cn("list")),t.setAttribute("role","tablist"),this.instance.container.appendChild(t),w(this.instance.container,this.cn("hasDots")),this.list=t),t}refresh(){var t;const e=this.instance.pages.length,i=Math.min(2,this.option("minCount")),s=Math.max(2e3,this.option("maxCount")),o=this.option("dynamicFrom");if(e<i||e>s)return void this.cleanup();const a="number"==typeof o&&e>5&&e>=o,r=!this.list||this.isDynamic!==a||this.list.children.length!==e;r&&this.cleanup();const l=this.build();if(n(l,this.cn("isDynamic"),!!a),r)for(let t=0;t<e;t++)l.append(this.createItem(t));let h,c=0;for(const e of[...l.children]){const i=c===this.instance.page;i&&(h=e),n(e,this.cn("isCurrent"),i),null===(t=e.children[0])||void 0===t||t.setAttribute("aria-selected",i?"true":"false");for(const t of["isBeforePrev","isPrev","isNext","isAfterNext"])x(e,this.cn(t));c++}if(h=h||l.firstChild,a&&h){const t=h.previousElementSibling,e=t&&t.previousElementSibling;w(t,this.cn("isPrev")),w(e,this.cn("isBeforePrev"));const i=h.nextElementSibling,s=i&&i.nextElementSibling;w(i,this.cn("isNext")),w(s,this.cn("isAfterNext"))}this.isDynamic=a}createItem(t=0){var e;const s=document.createElement("li");s.setAttribute("role","presentation");const n=i(this.instance.localize(this.option("dotTpl"),[["%d",t+1]]).replace(/\%i/g,t+""));return s.appendChild(n),null===(e=s.children[0])||void 0===e||e.setAttribute("role","tab"),s}cleanup(){this.list&&(this.list.remove(),this.list=null),this.isDynamic=!1,x(this.instance.container,this.cn("hasDots"))}attach(){this.instance.on(["refresh","change"],this.onRefresh)}detach(){this.instance.off(["refresh","change"],this.onRefresh),this.cleanup()}}Object.defineProperty(C,"defaults",{enumerable:!0,configurable:!0,writable:!0,value:D});class j extends A{constructor(){super(...arguments),Object.defineProperty(this,"container",{enumerable:!0,configurable:!0,writable:!0,value:null}),Object.defineProperty(this,"prev",{enumerable:!0,configurable:!0,writable:!0,value:null}),Object.defineProperty(this,"next",{enumerable:!0,configurable:!0,writable:!0,value:null})}onRefresh(){const t=this.instance,e=t.pages.length,i=t.page;if(e<2)return void this.cleanup();this.build();let s=this.prev,n=this.next;s&&n&&(s.removeAttribute("disabled"),n.removeAttribute("disabled"),t.isInfinite||(i<=0&&s.setAttribute("disabled",""),i>=e-1&&n.setAttribute("disabled","")))}createButton(t){const e=this.instance,i=document.createElement("button");i.setAttribute("tabindex","0"),i.setAttribute("title",e.localize(`{{${t.toUpperCase()}}}`)),w(i,this.cn("button")+" "+this.cn("next"===t?"isNext":"isPrev"));const s=e.isRTL?"next"===t?"prev":"next":t;var n;return i.innerHTML=e.localize(this.option(`${s}Tpl`)),i.dataset[`carousel${n=t,n?n.match("^[a-z]")?n.charAt(0).toUpperCase()+n.substring(1):n:""}`]="true",i}build(){let t=this.container;t||(this.container=t=document.createElement("div"),w(t,this.cn("container")),this.instance.container.appendChild(t)),this.next||(this.next=t.appendChild(this.createButton("next"))),this.prev||(this.prev=t.appendChild(this.createButton("prev")))}cleanup(){this.prev&&this.prev.remove(),this.next&&this.next.remove(),this.container&&this.container.remove(),this.prev=null,this.next=null,this.container=null}attach(){this.instance.on(["refresh","change"],this.onRefresh)}detach(){this.instance.off(["refresh","change"],this.onRefresh),this.cleanup()}}Object.defineProperty(j,"defaults",{enumerable:!0,configurable:!0,writable:!0,value:{classes:{container:"f-carousel__nav",button:"f-button",isNext:"is-next",isPrev:"is-prev"},nextTpl:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M9 3l9 9-9 9"/></svg>',prevTpl:'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M15 3l-9 9 9 9"/></svg>'}});class F extends A{constructor(){super(...arguments),Object.defineProperty(this,"selectedIndex",{enumerable:!0,configurable:!0,writable:!0,value:null}),Object.defineProperty(this,"target",{enumerable:!0,configurable:!0,writable:!0,value:null}),Object.defineProperty(this,"nav",{enumerable:!0,configurable:!0,writable:!0,value:null})}addAsTargetFor(t){this.target=this.instance,this.nav=t,this.attachEvents()}addAsNavFor(t){this.nav=this.instance,this.target=t,this.attachEvents()}attachEvents(){this.nav&&this.target&&(this.nav.options.initialSlide=this.target.options.initialPage,this.nav.on("ready",this.onNavReady),this.nav.state===k.Ready&&this.onNavReady(this.nav),this.target.on("ready",this.onTargetReady),this.target.state===k.Ready&&this.onTargetReady(this.target))}onNavReady(t){t.on("createSlide",this.onNavCreateSlide),t.on("Panzoom.click",this.onNavClick),t.on("Panzoom.touchEnd",this.onNavTouch),this.onTargetChange()}onTargetReady(t){t.on("change",this.onTargetChange),t.on("Panzoom.refresh",this.onTargetChange),this.onTargetChange()}onNavClick(t,e,i){i.pointerType||this.onNavTouch(t,t.panzoom,i)}onNavTouch(t,e,i){var s,n;if(Math.abs(e.dragOffset.x)>3||Math.abs(e.dragOffset.y)>3)return;const o=i.target,{nav:a,target:r}=this;if(!a||!r||!o)return;const l=o.closest("[data-index]");if(i.stopPropagation(),i.preventDefault(),!l)return;const h=parseInt(l.dataset.index||"",10)||0,c=r.getPageForSlide(h),d=a.getPageForSlide(h);a.slideTo(d),r.slideTo(c,{friction:(null===(n=null===(s=this.nav)||void 0===s?void 0:s.plugins)||void 0===n?void 0:n.Sync.option("friction"))||0}),this.markSelectedSlide(h)}onNavCreateSlide(t,e){e.index===this.selectedIndex&&this.markSelectedSlide(e.index)}onTargetChange(){const{target:t,nav:e}=this;if(!t||!e)return;if(e.state!==k.Ready||t.state!==k.Ready)return;const i=t.pages[t.page].slides[0].index,s=e.getPageForSlide(i);this.markSelectedSlide(i),e.slideTo(s)}markSelectedSlide(t){const e=this.nav;e&&e.state===k.Ready&&(this.selectedIndex=t,[...e.slides].map((e=>{e.el&&e.el.classList[e.index===t?"add":"remove"]("is-nav-selected")})))}attach(){const t=this;let e=t.options.target,i=t.options.nav;e?t.addAsNavFor(e):i&&t.addAsTargetFor(i)}detach(){const t=this,e=t.nav,i=t.target;e&&(e.off("ready",t.onNavReady),e.off("createSlide",t.onNavCreateSlide),e.off("Panzoom.click",t.onNavClick),e.off("Panzoom.touchEnd",t.onNavTouch)),t.nav=null,i&&(i.off("ready",t.onTargetReady),i.off("refresh",t.onTargetChange),i.off("change",t.onTargetChange)),t.target=null}}Object.defineProperty(F,"defaults",{enumerable:!0,configurable:!0,writable:!0,value:{friction:.35}});const I={Navigation:j,Dots:C,Sync:F};class H extends p{get axis(){return this.isHorizontal?"e":"f"}get isEnabled(){return this.state===k.Ready}get isInfinite(){let t=!1;const{contentDim:e,viewportDim:i,pages:s,slides:n}=this;return s.length>=2&&e+n[0].dim>=i&&(t=this.option("infinite")),t}get isRTL(){return"rtl"===this.option("direction")}get isHorizontal(){return"x"===this.option("axis")}constructor(t,e={},i={}){if(super(),Object.defineProperty(this,"userOptions",{enumerable:!0,configurable:!0,writable:!0,value:{}}),Object.defineProperty(this,"userPlugins",{enumerable:!0,configurable:!0,writable:!0,value:{}}),Object.defineProperty(this,"bp",{enumerable:!0,configurable:!0,writable:!0,value:""}),Object.defineProperty(this,"lp",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"state",{enumerable:!0,configurable:!0,writable:!0,value:k.Init}),Object.defineProperty(this,"page",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"prevPage",{enumerable:!0,configurable:!0,writable:!0,value:null}),Object.defineProperty(this,"container",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"viewport",{enumerable:!0,configurable:!0,writable:!0,value:null}),Object.defineProperty(this,"track",{enumerable:!0,configurable:!0,writable:!0,value:null}),Object.defineProperty(this,"slides",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"pages",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"panzoom",{enumerable:!0,configurable:!0,writable:!0,value:null}),Object.defineProperty(this,"inTransition",{enumerable:!0,configurable:!0,writable:!0,value:new Set}),Object.defineProperty(this,"contentDim",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"viewportDim",{enumerable:!0,configurable:!0,writable:!0,value:0}),"string"==typeof t&&(t=document.querySelector(t)),!t||!y(t))throw new Error("No Element found");this.container=t,this.slideNext=O(this.slideNext.bind(this),150),this.slidePrev=O(this.slidePrev.bind(this),150),this.userOptions=e,this.userPlugins=i,queueMicrotask((()=>{this.processOptions()}))}processOptions(){const t=d({},H.defaults,this.userOptions);let e="";const i=t.breakpoints;if(i&&c(i))for(const[s,n]of Object.entries(i))window.matchMedia(s).matches&&c(n)&&(e+=s,d(t,n));e===this.bp&&this.state!==k.Init||(this.bp=e,this.state===k.Ready&&(t.initialSlide=this.pages[this.page].slides[0].index),this.state!==k.Init&&this.destroy(),super.setOptions(t),!1===this.option("enabled")?this.attachEvents():setTimeout((()=>{this.init()}),0))}init(){this.state=k.Init,this.emit("init"),this.attachPlugins(Object.assign(Object.assign({},H.Plugins),this.userPlugins)),this.initLayout(),this.initSlides(),this.updateMetrics(),this.setInitialPosition(),this.initPanzoom(),this.attachEvents(),this.state=k.Ready,this.emit("ready")}initLayout(){const{container:t}=this,e=this.option("classes");w(t,this.cn("container")),n(t,e.isLTR,!this.isRTL),n(t,e.isRTL,this.isRTL),n(t,e.isVertical,!this.isHorizontal),n(t,e.isHorizontal,this.isHorizontal);let i=this.option("viewport")||t.querySelector(`.${e.viewport}`);i||(i=document.createElement("div"),w(i,e.viewport),i.append(...E(t,`.${e.slide}`)),t.prepend(i));let s=this.option("track")||t.querySelector(`.${e.track}`);s||(s=document.createElement("div"),w(s,e.track),s.append(...Array.from(i.childNodes))),s.setAttribute("aria-live","polite"),i.contains(s)||i.prepend(s),this.viewport=i,this.track=s,this.emit("initLayout")}initSlides(){const{track:t}=this;if(t){this.slides=[],[...E(t,`.${this.cn("slide")}`)].forEach((t=>{if(y(t)){const e=R({el:t,isDom:!0,index:this.slides.length});this.slides.push(e),this.emit("initSlide",e,this.slides.length)}}));for(let t of this.option("slides",[])){const e=R(t);e.index=this.slides.length,this.slides.push(e),this.emit("initSlide",e,this.slides.length)}this.emit("initSlides")}}setInitialPage(){let t=0;const e=this.option("initialSlide");t="number"==typeof e?this.getPageForSlide(e):parseInt(this.option("initialPage",0)+"",10)||0,this.page=t}setInitialPosition(){if(!this.track||!this.pages.length)return;const t=this.isHorizontal;let e=this.page;this.pages[e]||(this.page=e=0);const i=this.pages[e].pos*(this.isRTL&&t?1:-1),s=t?`${i}px`:"0",n=t?"0":`${i}px`;this.track.style.transform=`translate3d(${s}, ${n}, 0) scale(1)`,this.option("adaptiveHeight")&&this.setViewportHeight()}initPanzoom(){this.panzoom&&(this.panzoom.destroy(),this.panzoom=null);const t=this.option("Panzoom")||{};this.panzoom=new M(this.viewport,d({},{content:this.track,zoom:!1,panOnlyZoomed:!1,lockAxis:this.isHorizontal?"x":"y",infinite:this.isInfinite,click:!1,dblClick:!1,touch:t=>!(this.pages.length<2&&!t.options.infinite),bounds:()=>this.getBounds(),maxVelocity:t=>Math.abs(t.target[this.axis]-t.current[this.axis])<2*this.viewportDim?100:0},t)),this.panzoom.on("*",((t,e,...i)=>{this.emit(`Panzoom.${e}`,t,...i)})),this.panzoom.on("decel",this.onDecel),this.panzoom.on("refresh",this.onRefresh),this.panzoom.on("beforeTransform",this.onBeforeTransform),this.panzoom.on("endAnimation",this.onEndAnimation)}attachEvents(){const t=this.container;t&&(t.addEventListener("click",this.onClick,{passive:!1,capture:!1}),t.addEventListener("slideTo",this.onSlideTo)),window.addEventListener("resize",this.onResize)}createPages(){let t=[];const{contentDim:e,viewportDim:i}=this;let s=this.option("slidesPerPage");("number"!=typeof s||e<=i)&&(s=1/0);let n=0,o=0,a=0;for(const e of this.slides)(!t.length||o+e.dim>i||a===s)&&(t.push(L()),n=t.length-1,o=0,a=0),t[n].slides.push(e),o+=e.dim+e.gap,a++;return t}processPages(){const e=this.pages,{contentDim:i,viewportDim:s}=this,n=this.option("center"),o=this.option("fill"),a=o&&n&&i>s&&!this.isInfinite;if(e.forEach(((t,e)=>{t.index=e,t.pos=t.slides[0].pos,t.dim=0;for(const[e,i]of t.slides.entries())t.dim+=i.dim,e<t.slides.length-1&&(t.dim+=i.gap);a&&t.pos+.5*t.dim<.5*s?t.pos=0:a&&t.pos+.5*t.dim>=i-.5*s?t.pos=i-s:n&&(t.pos+=-.5*(s-t.dim))})),e.forEach(((e,n)=>{o&&!this.isInfinite&&i>s&&(e.pos=Math.max(e.pos,0),e.pos=Math.min(e.pos,i-s)),e.pos=t(e.pos,1e3),e.dim=t(e.dim,1e3),e.pos<.1&&e.pos>-.1&&(e.pos=0)})),this.isInfinite)return e;const r=[];let l;return e.forEach((t=>{const e=Object.assign({},t);l&&e.pos===l.pos?(l.dim+=e.dim,l.slides=[...l.slides,...e.slides]):(e.index=r.length,l=e,r.push(e))})),r}getPageFromIndex(t=0){const e=this.pages.length;let i;return t=parseInt((t||0).toString())||0,i=this.isInfinite?(t%e+e)%e:Math.max(Math.min(t,e-1),0),i}getSlideMetrics(e){var i;const s=this.isHorizontal?"width":"height";let n=0,o=0,a=e.el;if(a?n=parseFloat(a.dataset[s]||"")||0:(a=document.createElement("div"),a.style.visibility="hidden",w(a,this.cn("slide")+" "+e.class),(this.track||document.body).prepend(a)),n)a.style[s]=`${n}px`,a.style["width"===s?"height":"width"]="";else{const t=Math.max(1,(null===(i=window.visualViewport)||void 0===i?void 0:i.scale)||1);n=a.getBoundingClientRect()[s]*t}const r=getComputedStyle(a);return"content-box"===r.boxSizing&&(this.isHorizontal?(n+=parseFloat(r.paddingLeft)||0,n+=parseFloat(r.paddingRight)||0):(n+=parseFloat(r.paddingTop)||0,n+=parseFloat(r.paddingBottom)||0)),o=parseFloat(r[this.isHorizontal?"marginRight":"marginBottom"])||0,e.el||a.remove(),{dim:t(n,1e3),gap:t(o,1e3)}}getBounds(){const{isInfinite:t,isRTL:e,isHorizontal:i,pages:s}=this;let n={min:0,max:0};if(t)n={min:-1/0,max:1/0};else if(s.length){const t=s[0].pos,o=s[s.length-1].pos;n=e&&i?{min:t,max:o}:{min:-1*o,max:-1*t}}return{x:i?n:{min:0,max:0},y:i?{min:0,max:0}:n}}repositionSlides(){let e,{isHorizontal:i,isRTL:s,isInfinite:n,viewport:o,viewportDim:a,contentDim:r,page:l,pages:h,slides:c,panzoom:d}=this,u=0,g=0,p=0,f=0;d?f=-1*d.current[this.axis]:h[l]&&(f=h[l].pos||0),e=i?s?"right":"left":"top",s&&i&&(f*=-1);for(const i of c)i.el?("top"===e?(i.el.style.right="",i.el.style.left=""):i.el.style.top="",i.index!==u?i.el.style[e]=0===g?"":`${t(g,1e3)}px`:i.el.style[e]="",p+=i.dim+i.gap,u++):g+=i.dim+i.gap;if(n&&p&&o){let s=getComputedStyle(o),n="padding",l=i?"Right":"Bottom",h=parseFloat(s[n+(i?"Left":"Top")]);f-=h,a+=h,a+=parseFloat(s[n+l]);for(const i of c)i.el&&(t(i.pos)<t(a)&&t(i.pos+i.dim+i.gap)<t(f)&&t(f)>t(r-a)&&(i.el.style[e]=`${t(g+p,1e3)}px`),t(i.pos+i.gap)>=t(r-a)&&t(i.pos)>t(f+a)&&t(f)<t(a)&&(i.el.style[e]=`-${t(p,1e3)}px`))}let m,b,v=[...this.inTransition];if(v.length>1&&(m=h[v[0]],b=h[v[1]]),m&&b){let i=0;for(const s of c)s.el?this.inTransition.has(s.index)&&m.slides.indexOf(s)<0&&(s.el.style[e]=`${t(i+(m.pos-b.pos),1e3)}px`):i+=s.dim+s.gap}}createSlideEl(t){const{track:e,slides:i}=this;if(!e||!t)return;if(t.el)return;const s=document.createElement("div");w(s,this.cn("slide")),w(s,t.class),w(s,t.customClass),t.html&&(s.innerHTML=t.html);const n=[];i.forEach(((t,e)=>{t.el&&n.push(e)}));const o=t.index;let a=null;if(n.length){a=i[n.reduce(((t,e)=>Math.abs(e-o)<Math.abs(t-o)?e:t))]}const r=a&&a.el?a.index<t.index?a.el.nextSibling:a.el:null;e.insertBefore(s,e.contains(r)?r:null),t.el=s,this.emit("createSlide",t)}removeSlideEl(t,e=!1){const i=t.el;if(!i)return;if(x(i,this.cn("isSelected")),t.isDom&&!e)return i.removeAttribute("aria-hidden"),i.removeAttribute("data-index"),x(i,this.cn("isSelected")),void(i.style.left="");this.emit("removeSlide",t);const s=new CustomEvent("animationend");i.dispatchEvent(s),t.el&&t.el.remove(),t.el=null}transitionTo(e=0,i=this.option("transition")){if(!i)return!1;const{pages:s,panzoom:n}=this;e=parseInt((e||0).toString())||0;const o=this.getPageFromIndex(e);if(!n||!s[o]||s.length<2||Math.abs(s[this.page].slides[0].dim-this.viewportDim)>1)return!1;const a=e>this.page?1:-1,r=this.pages[o].pos*(this.isRTL?1:-1);if(this.page===o&&t(r,1e3)===t(n.target[this.axis],1e3))return!1;this.clearTransitions();const l=n.isResting;w(this.container,this.cn("inTransition"));const h=this.pages[this.page].slides[0],c=this.pages[o].slides[0];this.inTransition.add(c.index),this.createSlideEl(c);let d=h.el,u=c.el;l||"slide"===i||(i="fadeFast",d=null);const g=this.isRTL?"next":"prev",p=this.isRTL?"prev":"next";return d&&(this.inTransition.add(h.index),h.transition=i,d.addEventListener("animationend",this.onAnimationEnd),d.classList.add(`f-${i}Out`,`to-${a>0?p:g}`)),u&&(c.transition=i,u.addEventListener("animationend",this.onAnimationEnd),u.classList.add(`f-${i}In`,`from-${a>0?g:p}`)),n.panTo({x:this.isHorizontal?r:0,y:this.isHorizontal?0:r,friction:0}),this.onChange(o),!0}manageSlideVisiblity(){const t=new Set,e=new Set,i=this.getVisibleSlides(parseFloat(this.option("preload",0)+"")||0);for(const s of this.slides)i.has(s)?t.add(s):e.add(s);for(const e of this.inTransition)t.add(this.slides[e]);for(const e of t)this.createSlideEl(e),this.lazyLoadSlide(e);for(const i of e)t.has(i)||this.removeSlideEl(i);this.markSelectedSlides(),this.repositionSlides()}markSelectedSlides(){if(!this.pages[this.page]||!this.pages[this.page].slides)return;const t="aria-hidden";let e=this.cn("isSelected");if(e)for(const i of this.slides)i.el&&(i.el.dataset.index=`${i.index}`,this.pages[this.page].slides.includes(i)?(i.el.classList.contains(e)||(w(i.el,e),this.emit("selectSlide",i)),i.el.removeAttribute(t)):(i.el.classList.contains(e)&&(x(i.el,e),this.emit("unselectSlide",i)),i.el.setAttribute(t,"true")))}flipInfiniteTrack(){const t=this.panzoom;if(!t||!this.isInfinite)return;const e="x"===this.option("axis")?"e":"f",{viewportDim:i,contentDim:s}=this;let n=t.current[e],o=t.target[e]-n,a=0,r=.5*i,l=s;this.isRTL&&this.isHorizontal?(n<-r&&(a=-1,n+=l),n>l-r&&(a=1,n-=l)):(n>r&&(a=1,n-=l),n<-l+r&&(a=-1,n+=l)),a&&(t.current[e]=n,t.target[e]=n+o)}lazyLoadSlide(t){const e=this,s=t&&t.el;if(!s)return;const n=new Set,o="f-fadeIn";s.querySelectorAll("[data-lazy-srcset]").forEach((t=>{t instanceof HTMLImageElement&&n.add(t)}));let a=Array.from(s.querySelectorAll("[data-lazy-src]"));s.dataset.lazySrc&&a.push(s),a.map((t=>{t instanceof HTMLImageElement?n.add(t):y(t)&&(t.style.backgroundImage=`url('${t.dataset.lazySrc||""}')`,delete t.dataset.lazySrc)}));const r=(t,i,s)=>{s&&(s.remove(),s=null),i.complete&&(i.classList.add(o),setTimeout((()=>{i.classList.remove(o)}),350),i.style.display=""),this.option("adaptiveHeight")&&t.el&&this.pages[this.page].slides.indexOf(t)>-1&&(e.updateMetrics(),e.setViewportHeight()),this.emit("load",t)};for(const e of n){let s=null;e.src=e.dataset.lazySrcset||e.dataset.lazySrc||"",delete e.dataset.lazySrc,delete e.dataset.lazySrcset,e.style.display="none",e.addEventListener("error",(()=>{r(t,e,s)})),e.addEventListener("load",(()=>{r(t,e,s)})),setTimeout((()=>{e.parentNode&&t.el&&(e.complete?r(t,e,s):(s=i(v),e.parentNode.insertBefore(s,e)))}),300)}}onAnimationEnd(t){var e;const i=t.target,s=i?parseInt(i.dataset.index||"",10)||0:-1,n=this.slides[s],o=t.animationName;if(!i||!n||!o)return;const a=!!this.inTransition.has(s)&&n.transition;a&&o.substring(0,a.length+2)===`f-${a}`&&this.inTransition.delete(s),this.inTransition.size||this.clearTransitions(),s===this.page&&(null===(e=this.panzoom)||void 0===e?void 0:e.isResting)&&this.emit("settle")}onDecel(t,e=0,i=0,s=0,n=0){const{isRTL:o,isHorizontal:a,axis:r,pages:l}=this,h=l.length,c=Math.abs(Math.atan2(i,e)/(Math.PI/180));let d=0;if(d=c>45&&c<135?a?0:i:a?e:0,!h)return;const u=this.option("dragFree");let g=this.page,p=o&&a?1:-1;const f=t.target[r]*p,m=t.current[r]*p;let{pageIndex:b}=this.getPageFromPosition(f),{pageIndex:v}=this.getPageFromPosition(m);u?this.onChange(b):(Math.abs(d)>5?(l[g].dim<document.documentElement["client"+(this.isHorizontal?"Width":"Height")]-1&&(g=v),g=o&&a?d<0?g-1:g+1:d<0?g+1:g-1):g=0===s&&0===n?g:v,this.slideTo(g,{transition:!1,friction:t.option("decelFriction")}))}onClick(t){const e=t.target,i=e&&y(e)?e.dataset:null;let s,n;i&&(void 0!==i.carouselPage?(n="slideTo",s=i.carouselPage):void 0!==i.carouselNext?n="slideNext":void 0!==i.carouselPrev&&(n="slidePrev")),n?(t.preventDefault(),t.stopPropagation(),e&&!e.hasAttribute("disabled")&&this[n](s)):this.emit("click",t)}onSlideTo(t){const e=t.detail||0;this.slideTo(this.getPageForSlide(e),{friction:0})}onChange(t,e=0){const i=this.page;this.prevPage=i,this.page=t,this.option("adaptiveHeight")&&this.setViewportHeight(),t!==i&&(this.markSelectedSlides(),this.emit("change",t,i,e))}onRefresh(){let t=this.contentDim,e=this.viewportDim;this.updateMetrics(),this.contentDim===t&&this.viewportDim===e||this.slideTo(this.page,{friction:0,transition:!1})}onResize(){this.option("breakpoints")&&this.processOptions()}onBeforeTransform(t){this.lp!==t.current[this.axis]&&(this.flipInfiniteTrack(),this.manageSlideVisiblity()),this.lp=t.current.e}onEndAnimation(){this.inTransition.size||this.emit("settle")}reInit(t=null,e=null){this.destroy(),this.state=k.Init,this.userOptions=t||this.userOptions,this.userPlugins=e||this.userPlugins,this.processOptions()}slideTo(t=0,{friction:e=this.option("friction"),transition:i=this.option("transition")}={}){if(this.state===k.Destroy)return;const{axis:s,isHorizontal:n,isRTL:o,pages:a,panzoom:r}=this,l=a.length,h=o&&n?1:-1;if(!r||!l)return;if(this.transitionTo(t,i))return;const c=this.getPageFromIndex(t);let d=a[c].pos;if(this.isInfinite){const e=this.contentDim,i=r.target[s]*h;if(2===l)d+=e*Math.floor(parseFloat(t+"")/2);else{const t=i;d=[d,d-e,d+e].reduce((function(e,i){return Math.abs(i-t)<Math.abs(e-t)?i:e}))}}d*=h,Math.abs(r.target[s]-d)<.1||(r.panTo({x:n?d:0,y:n?0:d,friction:e}),this.onChange(c))}slideToClosest(t){if(this.panzoom){const{pageIndex:e}=this.getPageFromPosition(this.panzoom.current[this.isHorizontal?"e":"f"]);this.slideTo(e,t)}}slideNext(){this.slideTo(this.page+1)}slidePrev(){this.slideTo(this.page-1)}clearTransitions(){this.inTransition.clear(),x(this.container,this.cn("inTransition"));const t=["to-prev","to-next","from-prev","from-next"];for(const e of this.slides){const i=e.el;if(i){i.removeEventListener("animationend",this.onAnimationEnd),i.classList.remove(...t);const s=e.transition;s&&i.classList.remove(`f-${s}Out`,`f-${s}In`)}}this.manageSlideVisiblity()}prependSlide(t){var e,i;let s=Array.isArray(t)?t:[t];for(const t of s.reverse())this.slides.unshift(R(t));for(let t=0;t<this.slides.length;t++)this.slides[t].index=t;const n=(null===(e=this.pages[this.page])||void 0===e?void 0:e.pos)||0;this.page+=s.length,this.updateMetrics();const o=(null===(i=this.pages[this.page])||void 0===i?void 0:i.pos)||0;if(this.panzoom){const t=this.isRTL?n-o:o-n;this.panzoom.target.e-=t,this.panzoom.current.e-=t,this.panzoom.requestTick()}}appendSlide(t){let e=Array.isArray(t)?t:[t];for(const t of e){const e=R(t);e.index=this.slides.length,this.slides.push(e),this.emit("initSlide",t,this.slides.length)}this.updateMetrics()}removeSlide(t){const e=this.slides.length;t=(t%e+e)%e,this.removeSlideEl(this.slides[t],!0),this.slides.splice(t,1);for(let t=0;t<this.slides.length;t++)this.slides[t].index=t;this.updateMetrics(),this.slideTo(this.page,{friction:0,transition:!1})}updateMetrics(){const{panzoom:e,viewport:i,track:s,isHorizontal:n}=this;if(!s)return;const o=n?"width":"height",a=n?"offsetWidth":"offsetHeight";if(i){let e=Math.max(i[a],t(i.getBoundingClientRect()[o],1e3)),s=getComputedStyle(i),r="padding",l=n?"Right":"Bottom";e-=parseFloat(s[r+(n?"Left":"Top")])+parseFloat(s[r+l]),this.viewportDim=e}let r,l=this.pages.length,h=0;for(const[e,i]of this.slides.entries()){let s=0,n=0;!i.el&&r?(s=r.dim,n=r.gap):(({dim:s,gap:n}=this.getSlideMetrics(i)),r=i),s=t(s,1e3),n=t(n,1e3),i.dim=s,i.gap=n,i.pos=h,h+=s,(this.isInfinite||e<this.slides.length-1)&&(h+=n)}const c=this.contentDim;h=t(h,1e3),this.contentDim=h,e&&(e.contentRect[o]=h,e.contentRect["e"===this.axis?"fullWidth":"fullHeight"]=h),this.pages=this.createPages(),this.pages=this.processPages(),this.state===k.Init&&this.setInitialPage(),this.page=Math.max(0,Math.min(this.page,this.pages.length-1)),e&&l===this.pages.length&&Math.abs(h-c)>.5&&(e.target[this.axis]=-1*this.pages[this.page].pos,e.current[this.axis]=-1*this.pages[this.page].pos,e.stop()),this.manageSlideVisiblity(),this.emit("refresh")}getProgress(e,i=!1){void 0===e&&(e=this.page);const s=this,n=s.panzoom,o=s.pages[e]||0;if(!o||!n)return 0;let a=-1*n.current.e,r=s.contentDim;var l=[t((a-o.pos)/(1*o.dim),1e3),t((a+r-o.pos)/(1*o.dim),1e3),t((a-r-o.pos)/(1*o.dim),1e3)].reduce((function(t,e){return Math.abs(e)<Math.abs(t)?e:t}));return i?l:Math.max(-1,Math.min(1,l))}setViewportHeight(){const{page:t,pages:e,viewport:i,isHorizontal:s}=this;if(!i||!e[t])return;let n=0;s&&this.track&&(this.track.style.height="auto",e[t].slides.forEach((t=>{t.el&&(n=Math.max(n,t.el.offsetHeight))}))),i.style.height=n?`${n}px`:""}getPageForSlide(t){for(const e of this.pages)for(const i of e.slides)if(i.index===t)return e.index;return-1}getVisibleSlides(t=0){var e;const i=new Set;let{contentDim:s,viewportDim:n,pages:o,page:a}=this;s=s+(null===(e=this.slides[this.slides.length-1])||void 0===e?void 0:e.gap)||0;let r=0;r=this.panzoom?-1*this.panzoom.current[this.axis]:o[a]&&o[a].pos||0,this.isInfinite&&(r-=Math.floor(r/s)*s),this.isRTL&&this.isHorizontal&&(r*=-1);const l=r-n*t,h=r+n*(t+1),c=this.isInfinite?[-1,0,1]:[0];for(const t of this.slides)for(const e of c){const n=t.pos+e*s,o=t.pos+t.dim+t.gap+e*s;n<h&&o>l&&i.add(t)}return i}getPageFromPosition(t){const{viewportDim:e,contentDim:i}=this,s=this.pages.length,n=this.slides.length,o=this.slides[n-1];let a=0,r=0,l=0;const h=this.option("center");h&&(t+=.5*e),this.isInfinite||(t=Math.max(this.slides[0].pos,Math.min(t,o.pos)));const c=i+o.gap;l=Math.floor(t/c)||0,t-=l*c;let d=o,u=this.slides.find((e=>{const i=t+(d&&!h?.5*d.dim:0);return d=e,e.pos<=i&&e.pos+e.dim+e.gap>i}));return u||(u=o),r=this.getPageForSlide(u.index),a=r+l*s,{page:a,pageIndex:r}}destroy(){if([k.Destroy].includes(this.state))return;this.state=k.Destroy;const{container:t,viewport:e,track:i,slides:s,panzoom:n}=this,o=this.option("classes");t.removeEventListener("click",this.onClick,{passive:!1,capture:!1}),t.removeEventListener("slideTo",this.onSlideTo),window.removeEventListener("resize",this.onResize),n&&(n.destroy(),this.panzoom=null),s&&s.forEach((t=>{this.removeSlideEl(t)})),this.detachPlugins(),e&&e.offsetParent&&i&&i.offsetParent&&e.replaceWith(...i.childNodes);for(const[e,i]of Object.entries(o))"container"!==e&&i&&t.classList.remove(i);this.track=null,this.viewport=null,this.page=0,this.slides=[];const a=this.events.get("ready");this.events=new Map,a&&this.events.set("ready",a)}}Object.defineProperty(H,"Panzoom",{enumerable:!0,configurable:!0,writable:!0,value:M}),Object.defineProperty(H,"defaults",{enumerable:!0,configurable:!0,writable:!0,value:z}),Object.defineProperty(H,"Plugins",{enumerable:!0,configurable:!0,writable:!0,value:I});


/***/ }),

/***/ "./node_modules/just-validate/dist/just-validate.es.js":
/*!*************************************************************!*\
  !*** ./node_modules/just-validate/dist/just-validate.es.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CustomStyleTagIds": () => (/* binding */ CustomStyleTagIds),
/* harmony export */   "GroupRules": () => (/* binding */ GroupRules),
/* harmony export */   "Rules": () => (/* binding */ Rules),
/* harmony export */   "default": () => (/* binding */ JustValidate)
/* harmony export */ });
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const EMAIL_REGEXP = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
const INTEGER_REGEXP = /^-?[0-9]\d*$/;
const PASSWORD_REGEXP = /^(?=.*[A-Za-z])(?=.*\d).{8,}$/;
const STRONG_PASSWORD_REGEXP = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
const isEmpty = (value) => {
  let newVal = value;
  if (typeof value === "string") {
    newVal = value.trim();
  }
  return !newVal;
};
const isEmail = (value) => {
  return EMAIL_REGEXP.test(value);
};
const isLengthMoreThanMax = (value, len) => {
  return value.length > len;
};
const isLengthLessThanMin = (value, len) => {
  return value.length < len;
};
const isNumber = (value) => {
  if (typeof value !== "string") {
    return false;
  }
  return !isNaN(+value) && !isNaN(parseFloat(value));
};
const isInteger = (value) => {
  return INTEGER_REGEXP.test(value);
};
const isPassword = (value) => {
  return PASSWORD_REGEXP.test(value);
};
const isStrongPassword = (value) => {
  return STRONG_PASSWORD_REGEXP.test(value);
};
const isNumberMoreThanMax = (value, len) => {
  return value > len;
};
const isNumberLessThanMin = (value, len) => {
  return value < len;
};
const isInvalidOrEmptyString = (value) => {
  return typeof value !== "string" || value === "";
};
var Rules = /* @__PURE__ */ ((Rules2) => {
  Rules2["Required"] = "required";
  Rules2["Email"] = "email";
  Rules2["MinLength"] = "minLength";
  Rules2["MaxLength"] = "maxLength";
  Rules2["Password"] = "password";
  Rules2["Number"] = "number";
  Rules2["Integer"] = "integer";
  Rules2["MaxNumber"] = "maxNumber";
  Rules2["MinNumber"] = "minNumber";
  Rules2["StrongPassword"] = "strongPassword";
  Rules2["CustomRegexp"] = "customRegexp";
  Rules2["MinFilesCount"] = "minFilesCount";
  Rules2["MaxFilesCount"] = "maxFilesCount";
  Rules2["Files"] = "files";
  return Rules2;
})(Rules || {});
var GroupRules = /* @__PURE__ */ ((GroupRules2) => {
  GroupRules2["Required"] = "required";
  return GroupRules2;
})(GroupRules || {});
var CustomStyleTagIds = /* @__PURE__ */ ((CustomStyleTagIds2) => {
  CustomStyleTagIds2["Label"] = "label";
  CustomStyleTagIds2["LabelArrow"] = "labelArrow";
  return CustomStyleTagIds2;
})(CustomStyleTagIds || {});
const defaultDictionary = [
  {
    key: Rules.Required,
    dict: {
      en: "The field is required"
    }
  },
  {
    key: Rules.Email,
    dict: {
      en: "Email has invalid format"
    }
  },
  {
    key: Rules.MaxLength,
    dict: {
      en: "The field must contain a maximum of :value characters"
    }
  },
  {
    key: Rules.MinLength,
    dict: {
      en: "The field must contain a minimum of :value characters"
    }
  },
  {
    key: Rules.Password,
    dict: {
      en: "Password must contain minimum eight characters, at least one letter and one number"
    }
  },
  {
    key: Rules.StrongPassword,
    dict: {
      en: "Password should contain minimum eight characters, at least one uppercase letter, one lowercase letter, one number and one special character"
    }
  },
  {
    key: Rules.Number,
    dict: {
      en: "Value should be a number"
    }
  },
  {
    key: Rules.MaxNumber,
    dict: {
      en: "Number should be less or equal than :value"
    }
  },
  {
    key: Rules.MinNumber,
    dict: {
      en: "Number should be more or equal than :value"
    }
  },
  {
    key: Rules.MinFilesCount,
    dict: {
      en: "Files count should be more or equal than :value"
    }
  },
  {
    key: Rules.MaxFilesCount,
    dict: {
      en: "Files count should be less or equal than :value"
    }
  },
  {
    key: Rules.Files,
    dict: {
      en: "Uploaded files have one or several invalid properties (extension/size/type etc)."
    }
  }
];
const DEFAULT_ERROR_FIELD_MESSAGE = "Value is incorrect";
const isPromise = (val) => typeof val === "object" && val !== null && "then" in val && typeof val.then === "function";
const getNodeParents = (el) => {
  let elem = el;
  const els = [];
  while (elem) {
    els.unshift(elem);
    elem = elem.parentNode;
  }
  return els;
};
const getClosestParent = (groups, parents) => {
  const reversedParents = [...parents].reverse();
  for (let i = 0, len = reversedParents.length; i < len; ++i) {
    const parent = reversedParents[i];
    for (const key in groups) {
      const group = groups[key];
      if (group.groupElem === parent) {
        return [key, group];
      }
    }
  }
  return null;
};
const getClassList = (classList) => {
  if (Array.isArray(classList)) {
    return classList.filter((cls) => cls.length > 0);
  }
  if (typeof classList === "string" && classList.trim()) {
    return [...classList.split(" ").filter((cls) => cls.length > 0)];
  }
  return [];
};
const isElement = (element) => {
  return element instanceof Element || element instanceof HTMLDocument;
};
const errorLabelCss = `.just-validate-error-label[data-tooltip=true]{position:fixed;padding:4px 8px;background:#423f3f;color:#fff;white-space:nowrap;z-index:10;border-radius:4px;transform:translateY(-5px)}.just-validate-error-label[data-tooltip=true]:before{content:'';width:0;height:0;border-left:solid 5px transparent;border-right:solid 5px transparent;border-bottom:solid 5px #423f3f;position:absolute;z-index:3;display:block;bottom:-5px;transform:rotate(180deg);left:calc(50% - 5px)}.just-validate-error-label[data-tooltip=true][data-direction=left]{transform:translateX(-5px)}.just-validate-error-label[data-tooltip=true][data-direction=left]:before{right:-7px;bottom:auto;left:auto;top:calc(50% - 2px);transform:rotate(90deg)}.just-validate-error-label[data-tooltip=true][data-direction=right]{transform:translateX(5px)}.just-validate-error-label[data-tooltip=true][data-direction=right]:before{right:auto;bottom:auto;left:-7px;top:calc(50% - 2px);transform:rotate(-90deg)}.just-validate-error-label[data-tooltip=true][data-direction=bottom]{transform:translateY(5px)}.just-validate-error-label[data-tooltip=true][data-direction=bottom]:before{right:auto;bottom:auto;left:calc(50% - 5px);top:-5px;transform:rotate(0)}`;
const TOOLTIP_ARROW_HEIGHT = 5;
const defaultGlobalConfig = {
  errorFieldStyle: {
    color: "#b81111",
    border: "1px solid #B81111"
  },
  errorFieldCssClass: "just-validate-error-field",
  successFieldCssClass: "just-validate-success-field",
  errorLabelStyle: {
    color: "#b81111"
  },
  errorLabelCssClass: "just-validate-error-label",
  successLabelCssClass: "just-validate-success-label",
  focusInvalidField: true,
  lockForm: true,
  testingMode: false,
  validateBeforeSubmitting: false
};
class JustValidate {
  constructor(form, globalConfig, dictLocale) {
    __publicField(this, "form", null);
    __publicField(this, "fields", {});
    __publicField(this, "groupFields", {});
    __publicField(this, "errors", {});
    __publicField(this, "isValid", false);
    __publicField(this, "isSubmitted", false);
    __publicField(this, "globalConfig", defaultGlobalConfig);
    __publicField(this, "errorLabels", {});
    __publicField(this, "successLabels", {});
    __publicField(this, "eventListeners", []);
    __publicField(this, "dictLocale", defaultDictionary);
    __publicField(this, "currentLocale", "en");
    __publicField(this, "customStyleTags", {});
    __publicField(this, "onSuccessCallback");
    __publicField(this, "onFailCallback");
    __publicField(this, "onValidateCallback");
    __publicField(this, "tooltips", []);
    __publicField(this, "lastScrollPosition");
    __publicField(this, "isScrollTick");
    __publicField(this, "fieldIds", /* @__PURE__ */ new Map());
    __publicField(this, "getKeyByFieldSelector", (field) => {
      return this.fieldIds.get(field);
    });
    __publicField(this, "getFieldSelectorByKey", (key) => {
      for (const [fieldSelector, k] of this.fieldIds) {
        if (key === k) {
          return fieldSelector;
        }
      }
      return void 0;
    });
    __publicField(this, "getCompatibleFields", () => {
      const fields = {};
      Object.keys(this.fields).forEach((key) => {
        let newKey = key;
        const fieldSelector = this.getFieldSelectorByKey(key);
        if (typeof fieldSelector === "string") {
          newKey = fieldSelector;
        }
        fields[newKey] = { ...this.fields[key] };
      });
      return fields;
    });
    __publicField(this, "setKeyByFieldSelector", (field) => {
      if (this.fieldIds.has(field)) {
        return this.fieldIds.get(field);
      }
      const key = String(this.fieldIds.size + 1);
      this.fieldIds.set(field, key);
      return key;
    });
    __publicField(this, "refreshAllTooltips", () => {
      this.tooltips.forEach((item) => {
        item.refresh();
      });
    });
    __publicField(this, "handleDocumentScroll", () => {
      this.lastScrollPosition = window.scrollY;
      if (!this.isScrollTick) {
        window.requestAnimationFrame(() => {
          this.refreshAllTooltips();
          this.isScrollTick = false;
        });
        this.isScrollTick = true;
      }
    });
    __publicField(this, "formSubmitHandler", (ev) => {
      ev.preventDefault();
      this.isSubmitted = true;
      this.validateHandler(ev);
    });
    __publicField(this, "handleFieldChange", (target) => {
      let foundKey;
      for (const key in this.fields) {
        const field = this.fields[key];
        if (field.elem === target) {
          foundKey = key;
          break;
        }
      }
      if (!foundKey) {
        return;
      }
      this.fields[foundKey].touched = true;
      this.validateField(foundKey, true);
    });
    __publicField(this, "handleGroupChange", (target) => {
      let foundKey;
      for (const key in this.groupFields) {
        const group = this.groupFields[key];
        if (group.elems.find((elem) => elem === target)) {
          foundKey = key;
          break;
        }
      }
      if (!foundKey) {
        return;
      }
      this.groupFields[foundKey].touched = true;
      this.validateGroup(foundKey, true);
    });
    __publicField(this, "handlerChange", (ev) => {
      if (!ev.target) {
        return;
      }
      this.handleFieldChange(ev.target);
      this.handleGroupChange(ev.target);
      this.renderErrors();
    });
    this.initialize(form, globalConfig, dictLocale);
  }
  initialize(form, globalConfig, dictLocale) {
    this.form = null;
    this.errors = {};
    this.isValid = false;
    this.isSubmitted = false;
    this.globalConfig = defaultGlobalConfig;
    this.errorLabels = {};
    this.successLabels = {};
    this.eventListeners = [];
    this.customStyleTags = {};
    this.tooltips = [];
    this.currentLocale = "en";
    if (typeof form === "string") {
      const elem = document.querySelector(form);
      if (!elem) {
        throw Error(
          `Form with ${form} selector not found! Please check the form selector`
        );
      }
      this.setForm(elem);
    } else if (form instanceof HTMLFormElement) {
      this.setForm(form);
    } else {
      throw Error(
        `Form selector is not valid. Please specify a string selector or a DOM element.`
      );
    }
    this.globalConfig = { ...defaultGlobalConfig, ...globalConfig };
    if (dictLocale) {
      this.dictLocale = [...dictLocale, ...defaultDictionary];
    }
    if (this.isTooltip()) {
      const styleTag = document.createElement("style");
      styleTag.textContent = errorLabelCss;
      this.customStyleTags[CustomStyleTagIds.Label] = document.head.appendChild(styleTag);
      this.addListener("scroll", document, this.handleDocumentScroll);
    }
  }
  getLocalisedString(rule, ruleValue, customMsg) {
    var _a;
    const search = customMsg != null ? customMsg : rule;
    let localisedStr = (_a = this.dictLocale.find((item) => item.key === search)) == null ? void 0 : _a.dict[this.currentLocale];
    if (!localisedStr) {
      if (customMsg) {
        localisedStr = customMsg;
      }
    }
    if (localisedStr && ruleValue !== void 0) {
      switch (rule) {
        case Rules.MaxLength:
        case Rules.MinLength:
        case Rules.MaxNumber:
        case Rules.MinNumber:
        case Rules.MinFilesCount:
        case Rules.MaxFilesCount:
          localisedStr = localisedStr.replace(":value", String(ruleValue));
      }
    }
    return localisedStr || customMsg || DEFAULT_ERROR_FIELD_MESSAGE;
  }
  getFieldErrorMessage(fieldRule, elem) {
    const msg = typeof fieldRule.errorMessage === "function" ? fieldRule.errorMessage(this.getElemValue(elem), this.fields) : fieldRule.errorMessage;
    return this.getLocalisedString(fieldRule.rule, fieldRule.value, msg);
  }
  getFieldSuccessMessage(successMessage, elem) {
    const msg = typeof successMessage === "function" ? successMessage(this.getElemValue(elem), this.fields) : successMessage;
    return this.getLocalisedString(void 0, void 0, msg);
  }
  getGroupErrorMessage(groupRule) {
    return this.getLocalisedString(
      groupRule.rule,
      void 0,
      groupRule.errorMessage
    );
  }
  getGroupSuccessMessage(groupRule) {
    if (!groupRule.successMessage) {
      return void 0;
    }
    return this.getLocalisedString(
      void 0,
      void 0,
      groupRule.successMessage
    );
  }
  setFieldInvalid(key, fieldRule) {
    this.fields[key].isValid = false;
    this.fields[key].errorMessage = this.getFieldErrorMessage(
      fieldRule,
      this.fields[key].elem
    );
  }
  setFieldValid(key, successMessage) {
    this.fields[key].isValid = true;
    if (successMessage !== void 0) {
      this.fields[key].successMessage = this.getFieldSuccessMessage(
        successMessage,
        this.fields[key].elem
      );
    }
  }
  setGroupInvalid(key, groupRule) {
    this.groupFields[key].isValid = false;
    this.groupFields[key].errorMessage = this.getGroupErrorMessage(groupRule);
  }
  setGroupValid(key, groupRule) {
    this.groupFields[key].isValid = true;
    this.groupFields[key].successMessage = this.getGroupSuccessMessage(groupRule);
  }
  getElemValue(elem) {
    switch (elem.type) {
      case "checkbox":
        return elem.checked;
      case "file":
        return elem.files;
      default:
        return elem.value;
    }
  }
  validateGroupRule(key, elems, groupRule) {
    switch (groupRule.rule) {
      case GroupRules.Required: {
        if (elems.every((elem) => !elem.checked)) {
          this.setGroupInvalid(key, groupRule);
        } else {
          this.setGroupValid(key, groupRule);
        }
      }
    }
  }
  validateFieldRule(key, elem, fieldRule, afterInputChanged = false) {
    const ruleValue = fieldRule.value;
    const elemValue = this.getElemValue(elem);
    if (fieldRule.plugin) {
      const result = fieldRule.plugin(
        elemValue,
        this.getCompatibleFields()
      );
      if (!result) {
        this.setFieldInvalid(key, fieldRule);
      }
      return;
    }
    switch (fieldRule.rule) {
      case Rules.Required: {
        if (isEmpty(elemValue)) {
          this.setFieldInvalid(key, fieldRule);
        }
        break;
      }
      case Rules.Email: {
        if (isInvalidOrEmptyString(elemValue)) {
          break;
        }
        if (!isEmail(elemValue)) {
          this.setFieldInvalid(key, fieldRule);
        }
        break;
      }
      case Rules.MaxLength: {
        if (ruleValue === void 0) {
          console.error(
            `Value for ${fieldRule.rule} rule for [${key}] field is not defined. The field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          break;
        }
        if (typeof ruleValue !== "number") {
          console.error(
            `Value for ${fieldRule.rule} rule for [${key}] should be a number. The field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          break;
        }
        if (isInvalidOrEmptyString(elemValue)) {
          break;
        }
        if (isLengthMoreThanMax(elemValue, ruleValue)) {
          this.setFieldInvalid(key, fieldRule);
        }
        break;
      }
      case Rules.MinLength: {
        if (ruleValue === void 0) {
          console.error(
            `Value for ${fieldRule.rule} rule for [${key}] field is not defined. The field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          break;
        }
        if (typeof ruleValue !== "number") {
          console.error(
            `Value for ${fieldRule.rule} rule for [${key}] should be a number. The field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          break;
        }
        if (isInvalidOrEmptyString(elemValue)) {
          break;
        }
        if (isLengthLessThanMin(elemValue, ruleValue)) {
          this.setFieldInvalid(key, fieldRule);
        }
        break;
      }
      case Rules.Password: {
        if (isInvalidOrEmptyString(elemValue)) {
          break;
        }
        if (!isPassword(elemValue)) {
          this.setFieldInvalid(key, fieldRule);
        }
        break;
      }
      case Rules.StrongPassword: {
        if (isInvalidOrEmptyString(elemValue)) {
          break;
        }
        if (!isStrongPassword(elemValue)) {
          this.setFieldInvalid(key, fieldRule);
        }
        break;
      }
      case Rules.Number: {
        if (isInvalidOrEmptyString(elemValue)) {
          break;
        }
        if (!isNumber(elemValue)) {
          this.setFieldInvalid(key, fieldRule);
        }
        break;
      }
      case Rules.Integer: {
        if (isInvalidOrEmptyString(elemValue)) {
          break;
        }
        if (!isInteger(elemValue)) {
          this.setFieldInvalid(key, fieldRule);
        }
        break;
      }
      case Rules.MaxNumber: {
        if (ruleValue === void 0) {
          console.error(
            `Value for ${fieldRule.rule} rule for [${key}] field is not defined. The field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          break;
        }
        if (typeof ruleValue !== "number") {
          console.error(
            `Value for ${fieldRule.rule} rule for [${key}] field should be a number. The field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          break;
        }
        if (isInvalidOrEmptyString(elemValue)) {
          break;
        }
        const num = +elemValue;
        if (Number.isNaN(num) || isNumberMoreThanMax(num, ruleValue)) {
          this.setFieldInvalid(key, fieldRule);
        }
        break;
      }
      case Rules.MinNumber: {
        if (ruleValue === void 0) {
          console.error(
            `Value for ${fieldRule.rule} rule for [${key}] field is not defined. The field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          break;
        }
        if (typeof ruleValue !== "number") {
          console.error(
            `Value for ${fieldRule.rule} rule for [${key}] field should be a number. The field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          break;
        }
        if (isInvalidOrEmptyString(elemValue)) {
          break;
        }
        const num = +elemValue;
        if (Number.isNaN(num) || isNumberLessThanMin(num, ruleValue)) {
          this.setFieldInvalid(key, fieldRule);
        }
        break;
      }
      case Rules.CustomRegexp: {
        if (ruleValue === void 0) {
          console.error(
            `Value for ${fieldRule.rule} rule for [${key}] field is not defined. This field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          return;
        }
        let regexp;
        try {
          regexp = new RegExp(ruleValue);
        } catch (e) {
          console.error(
            `Value for ${fieldRule.rule} rule for [${key}] should be a valid regexp. This field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          break;
        }
        const str = String(elemValue);
        if (str !== "" && !regexp.test(str)) {
          this.setFieldInvalid(key, fieldRule);
        }
        break;
      }
      case Rules.MinFilesCount: {
        if (ruleValue === void 0) {
          console.error(
            `Value for ${fieldRule.rule} rule for [${key}] field is not defined. This field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          break;
        }
        if (typeof ruleValue !== "number") {
          console.error(
            `Value for ${fieldRule.rule} rule for [${key}] field should be a number. The field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          break;
        }
        if (Number.isFinite(elemValue == null ? void 0 : elemValue.length) && elemValue.length < ruleValue) {
          this.setFieldInvalid(key, fieldRule);
          break;
        }
        break;
      }
      case Rules.MaxFilesCount: {
        if (ruleValue === void 0) {
          console.error(
            `Value for ${fieldRule.rule} rule for [${key}] field is not defined. This field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          break;
        }
        if (typeof ruleValue !== "number") {
          console.error(
            `Value for ${fieldRule.rule} rule for [${key}] field should be a number. The field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          break;
        }
        if (Number.isFinite(elemValue == null ? void 0 : elemValue.length) && elemValue.length > ruleValue) {
          this.setFieldInvalid(key, fieldRule);
          break;
        }
        break;
      }
      case Rules.Files: {
        if (ruleValue === void 0) {
          console.error(
            `Value for ${fieldRule.rule} rule for [${key}] field is not defined. This field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          return;
        }
        if (typeof ruleValue !== "object") {
          console.error(
            `Value for ${fieldRule.rule} rule for [${key}] field should be an object. This field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          return;
        }
        const filesConfig = ruleValue.files;
        if (typeof filesConfig !== "object") {
          console.error(
            `Value for ${fieldRule.rule} rule for [${key}] field should be an object with files array. This field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          return;
        }
        const isFilePropsInvalid = (file, fileConfig) => {
          const minSizeInvalid = Number.isFinite(fileConfig.minSize) && file.size < fileConfig.minSize;
          const maxSizeInvalid = Number.isFinite(fileConfig.maxSize) && file.size > fileConfig.maxSize;
          const nameInvalid = Array.isArray(fileConfig.names) && !fileConfig.names.includes(file.name);
          const extInvalid = Array.isArray(fileConfig.extensions) && !fileConfig.extensions.includes(
            file.name.split(".")[file.name.split(".").length - 1]
          );
          const typeInvalid = Array.isArray(fileConfig.types) && !fileConfig.types.includes(file.type);
          return minSizeInvalid || maxSizeInvalid || nameInvalid || extInvalid || typeInvalid;
        };
        if (typeof elemValue === "object" && elemValue !== null) {
          for (let fileIdx = 0, len = elemValue.length; fileIdx < len; ++fileIdx) {
            const file = elemValue.item(fileIdx);
            if (!file) {
              this.setFieldInvalid(key, fieldRule);
              break;
            }
            const filesInvalid = isFilePropsInvalid(file, filesConfig);
            if (filesInvalid) {
              this.setFieldInvalid(key, fieldRule);
              break;
            }
          }
        }
        break;
      }
      default: {
        if (typeof fieldRule.validator !== "function") {
          console.error(
            `Validator for custom rule for [${key}] field should be a function. This field will be always invalid.`
          );
          this.setFieldInvalid(key, fieldRule);
          return;
        }
        const result = fieldRule.validator(
          elemValue,
          this.getCompatibleFields()
        );
        if (typeof result !== "boolean" && typeof result !== "function") {
          console.error(
            `Validator return value for [${key}] field should be boolean or function. It will be cast to boolean.`
          );
        }
        if (typeof result === "function") {
          if (afterInputChanged) {
            this.fields[key].asyncCheckPending = true;
          } else {
            this.fields[key].asyncCheckPending = false;
            const promise = result();
            if (!isPromise(promise)) {
              console.error(
                `Validator function for custom rule for [${key}] field should return a Promise. This field will be always invalid.`
              );
              this.setFieldInvalid(key, fieldRule);
              return;
            }
            return promise.then((resp) => {
              if (!resp) {
                this.setFieldInvalid(key, fieldRule);
              }
            }).catch(() => {
              this.setFieldInvalid(key, fieldRule);
            });
          }
        }
        if (!result) {
          this.setFieldInvalid(key, fieldRule);
        }
      }
    }
  }
  isFormValid() {
    let isValid = true;
    for (let i = 0, len = Object.values(this.fields).length; i < len; ++i) {
      const item = Object.values(this.fields)[i];
      if (item.isValid === void 0) {
        isValid = void 0;
        break;
      }
      if (item.isValid === false) {
        isValid = false;
        break;
      }
    }
    for (let i = 0, len = Object.values(this.groupFields).length; i < len; ++i) {
      const item = Object.values(this.groupFields)[i];
      if (item.isValid === void 0) {
        isValid = void 0;
        break;
      }
      if (item.isValid === false) {
        isValid = false;
        break;
      }
    }
    return isValid;
  }
  validateField(key, afterInputChanged = false) {
    var _a;
    const field = this.fields[key];
    field.isValid = true;
    const promises = [];
    [...field.rules].reverse().forEach((rule) => {
      const res = this.validateFieldRule(
        key,
        field.elem,
        rule,
        afterInputChanged
      );
      if (isPromise(res)) {
        promises.push(res);
      }
    });
    if (field.isValid) {
      this.setFieldValid(key, (_a = field.config) == null ? void 0 : _a.successMessage);
    }
    return Promise.allSettled(promises).finally(() => {
      var _a2;
      if (afterInputChanged) {
        (_a2 = this.onValidateCallback) == null ? void 0 : _a2.call(this, {
          isValid: this.isFormValid(),
          isSubmitted: this.isSubmitted,
          fields: this.getCompatibleFields(),
          groups: { ...this.groupFields }
        });
      }
    });
  }
  revalidateField(fieldSelector) {
    if (typeof fieldSelector !== "string" && !isElement(fieldSelector)) {
      throw Error(
        `Field selector is not valid. Please specify a string selector or a valid DOM element.`
      );
    }
    const key = this.getKeyByFieldSelector(fieldSelector);
    if (!key || !this.fields[key]) {
      console.error(`Field not found. Check the field selector.`);
      return Promise.reject();
    }
    return new Promise((resolve) => {
      this.validateField(key, true).finally(() => {
        this.clearFieldStyle(key);
        this.clearFieldLabel(key);
        this.renderFieldError(key, true);
        resolve(!!this.fields[key].isValid);
      });
    });
  }
  revalidateGroup(groupSelector) {
    if (typeof groupSelector !== "string" && !isElement(groupSelector)) {
      throw Error(
        `Group selector is not valid. Please specify a string selector or a valid DOM element.`
      );
    }
    const key = this.getKeyByFieldSelector(groupSelector);
    if (!key || !this.groupFields[key]) {
      console.error(`Group not found. Check the group selector.`);
      return Promise.reject();
    }
    return new Promise((resolve) => {
      this.validateGroup(key).finally(() => {
        this.clearFieldLabel(key);
        this.renderGroupError(key, true);
        resolve(!!this.groupFields[key].isValid);
      });
    });
  }
  validateGroup(key, afterInputChanged = false) {
    const group = this.groupFields[key];
    const promises = [];
    [...group.rules].reverse().forEach((rule) => {
      const res = this.validateGroupRule(key, group.elems, rule);
      if (isPromise(res)) {
        promises.push(res);
      }
    });
    return Promise.allSettled(promises).finally(() => {
      var _a;
      if (afterInputChanged) {
        (_a = this.onValidateCallback) == null ? void 0 : _a.call(this, {
          isValid: this.isFormValid(),
          isSubmitted: this.isSubmitted,
          fields: this.getCompatibleFields(),
          groups: { ...this.groupFields }
        });
      }
    });
  }
  focusInvalidField() {
    for (const key in this.fields) {
      const field = this.fields[key];
      if (!field.isValid) {
        setTimeout(() => field.elem.focus(), 0);
        break;
      }
    }
  }
  afterSubmitValidation(forceRevalidation = false) {
    this.renderErrors(forceRevalidation);
    if (this.globalConfig.focusInvalidField) {
      this.focusInvalidField();
    }
  }
  validate(forceRevalidation = false) {
    return new Promise((resolve) => {
      const promises = [];
      Object.keys(this.fields).forEach((key) => {
        const promise = this.validateField(key);
        if (isPromise(promise)) {
          promises.push(promise);
        }
      });
      Object.keys(this.groupFields).forEach((key) => {
        const promise = this.validateGroup(key);
        if (isPromise(promise)) {
          promises.push(promise);
        }
      });
      Promise.allSettled(promises).then(() => {
        var _a;
        this.afterSubmitValidation(forceRevalidation);
        (_a = this.onValidateCallback) == null ? void 0 : _a.call(this, {
          isValid: this.isFormValid(),
          isSubmitted: this.isSubmitted,
          fields: this.getCompatibleFields(),
          groups: { ...this.groupFields }
        });
        resolve(!!promises.length);
      });
    });
  }
  revalidate() {
    return new Promise((resolve) => {
      this.validateHandler(void 0, true).finally(() => {
        if (this.globalConfig.focusInvalidField) {
          this.focusInvalidField();
        }
        resolve(this.isValid);
      });
    });
  }
  validateHandler(ev, forceRevalidation = false) {
    if (this.globalConfig.lockForm) {
      this.lockForm();
    }
    return this.validate(forceRevalidation).finally(() => {
      var _a, _b;
      if (this.globalConfig.lockForm) {
        this.unlockForm();
      }
      if (this.isValid) {
        (_a = this.onSuccessCallback) == null ? void 0 : _a.call(this, ev);
      } else {
        (_b = this.onFailCallback) == null ? void 0 : _b.call(this, this.getCompatibleFields(), this.groupFields);
      }
    });
  }
  setForm(form) {
    this.form = form;
    this.form.setAttribute("novalidate", "novalidate");
    this.removeListener("submit", this.form, this.formSubmitHandler);
    this.addListener("submit", this.form, this.formSubmitHandler);
  }
  addListener(type, elem, handler) {
    elem.addEventListener(type, handler);
    this.eventListeners.push({ type, elem, func: handler });
  }
  removeListener(type, elem, handler) {
    elem.removeEventListener(type, handler);
    this.eventListeners = this.eventListeners.filter(
      (item) => item.type !== type || item.elem !== elem
    );
  }
  addField(fieldSelector, rules, config) {
    if (typeof fieldSelector !== "string" && !isElement(fieldSelector)) {
      throw Error(
        `Field selector is not valid. Please specify a string selector or a valid DOM element.`
      );
    }
    let elem;
    if (typeof fieldSelector === "string") {
      elem = this.form.querySelector(fieldSelector);
    } else {
      elem = fieldSelector;
    }
    if (!elem) {
      throw Error(
        `Field doesn't exist in the DOM! Please check the field selector.`
      );
    }
    if (!Array.isArray(rules) || !rules.length) {
      throw Error(
        `Rules argument should be an array and should contain at least 1 element.`
      );
    }
    rules.forEach((item) => {
      if (!("rule" in item || "validator" in item || "plugin" in item)) {
        throw Error(
          `Rules argument must contain at least one rule or validator property.`
        );
      }
      if (!item.validator && !item.plugin && (!item.rule || !Object.values(Rules).includes(item.rule))) {
        throw Error(
          `Rule should be one of these types: ${Object.values(Rules).join(
            ", "
          )}. Provided value: ${item.rule}`
        );
      }
    });
    const key = this.setKeyByFieldSelector(fieldSelector);
    this.fields[key] = {
      elem,
      rules,
      isValid: void 0,
      touched: false,
      config
    };
    this.setListeners(elem);
    if (this.isSubmitted || this.globalConfig.validateBeforeSubmitting) {
      this.validateField(key);
    }
    return this;
  }
  removeField(fieldSelector) {
    if (typeof fieldSelector !== "string" && !isElement(fieldSelector)) {
      throw Error(
        `Field selector is not valid. Please specify a string selector or a valid DOM element.`
      );
    }
    const key = this.getKeyByFieldSelector(fieldSelector);
    if (!key || !this.fields[key]) {
      console.error(`Field not found. Check the field selector.`);
      return this;
    }
    const type = this.getListenerType(this.fields[key].elem.type);
    this.removeListener(type, this.fields[key].elem, this.handlerChange);
    this.clearErrors();
    delete this.fields[key];
    return this;
  }
  removeGroup(group) {
    if (typeof group !== "string") {
      throw Error(
        `Group selector is not valid. Please specify a string selector.`
      );
    }
    const key = this.getKeyByFieldSelector(group);
    if (!key || !this.groupFields[key]) {
      console.error(`Group not found. Check the group selector.`);
      return this;
    }
    this.groupFields[key].elems.forEach((elem) => {
      const type = this.getListenerType(elem.type);
      this.removeListener(type, elem, this.handlerChange);
    });
    this.clearErrors();
    delete this.groupFields[key];
    return this;
  }
  addRequiredGroup(groupField, errorMessage, config, successMessage) {
    if (typeof groupField !== "string" && !isElement(groupField)) {
      throw Error(
        `Group selector is not valid. Please specify a string selector or a valid DOM element.`
      );
    }
    let elem;
    if (typeof groupField === "string") {
      elem = this.form.querySelector(groupField);
    } else {
      elem = groupField;
    }
    if (!elem) {
      throw Error(`Group selector not found! Please check the group selector.`);
    }
    const inputs = elem.querySelectorAll("input");
    const childrenInputs = Array.from(inputs).filter((input) => {
      const parent = getClosestParent(this.groupFields, getNodeParents(input));
      if (!parent) {
        return true;
      }
      return parent[1].elems.find((elem2) => elem2 !== input);
    });
    const key = this.setKeyByFieldSelector(groupField);
    this.groupFields[key] = {
      rules: [
        {
          rule: GroupRules.Required,
          errorMessage,
          successMessage
        }
      ],
      groupElem: elem,
      elems: childrenInputs,
      touched: false,
      isValid: void 0,
      config
    };
    inputs.forEach((input) => {
      this.setListeners(input);
    });
    return this;
  }
  getListenerType(type) {
    switch (type) {
      case "checkbox":
      case "select-one":
      case "file":
      case "radio": {
        return "change";
      }
      default: {
        return "input";
      }
    }
  }
  setListeners(elem) {
    const type = this.getListenerType(elem.type);
    this.removeListener(type, elem, this.handlerChange);
    this.addListener(type, elem, this.handlerChange);
  }
  clearFieldLabel(key) {
    var _a, _b;
    (_a = this.errorLabels[key]) == null ? void 0 : _a.remove();
    (_b = this.successLabels[key]) == null ? void 0 : _b.remove();
  }
  clearFieldStyle(key) {
    var _a, _b, _c, _d;
    const field = this.fields[key];
    const errorStyle = ((_a = field.config) == null ? void 0 : _a.errorFieldStyle) || this.globalConfig.errorFieldStyle;
    Object.keys(errorStyle).forEach((key2) => {
      field.elem.style[key2] = "";
    });
    const successStyle = ((_b = field.config) == null ? void 0 : _b.successFieldStyle) || this.globalConfig.successFieldStyle || {};
    Object.keys(successStyle).forEach((key2) => {
      field.elem.style[key2] = "";
    });
    field.elem.classList.remove(
      ...getClassList(
        ((_c = field.config) == null ? void 0 : _c.errorFieldCssClass) || this.globalConfig.errorFieldCssClass
      ),
      ...getClassList(
        ((_d = field.config) == null ? void 0 : _d.successFieldCssClass) || this.globalConfig.successFieldCssClass
      )
    );
  }
  clearErrors() {
    var _a, _b;
    Object.keys(this.errorLabels).forEach(
      (key) => this.errorLabels[key].remove()
    );
    Object.keys(this.successLabels).forEach(
      (key) => this.successLabels[key].remove()
    );
    for (const key in this.fields) {
      this.clearFieldStyle(key);
    }
    for (const key in this.groupFields) {
      const group = this.groupFields[key];
      const errorStyle = ((_a = group.config) == null ? void 0 : _a.errorFieldStyle) || this.globalConfig.errorFieldStyle;
      Object.keys(errorStyle).forEach((key2) => {
        group.elems.forEach((elem) => {
          var _a2;
          elem.style[key2] = "";
          elem.classList.remove(
            ...getClassList(
              ((_a2 = group.config) == null ? void 0 : _a2.errorFieldCssClass) || this.globalConfig.errorFieldCssClass
            )
          );
        });
      });
      const successStyle = ((_b = group.config) == null ? void 0 : _b.successFieldStyle) || this.globalConfig.successFieldStyle || {};
      Object.keys(successStyle).forEach((key2) => {
        group.elems.forEach((elem) => {
          var _a2;
          elem.style[key2] = "";
          elem.classList.remove(
            ...getClassList(
              ((_a2 = group.config) == null ? void 0 : _a2.successFieldCssClass) || this.globalConfig.successFieldCssClass
            )
          );
        });
      });
    }
    this.tooltips = [];
  }
  isTooltip() {
    return !!this.globalConfig.tooltip;
  }
  lockForm() {
    const elems = this.form.querySelectorAll(
      "input, textarea, button, select"
    );
    for (let i = 0, len = elems.length; i < len; ++i) {
      elems[i].setAttribute(
        "data-just-validate-fallback-disabled",
        elems[i].disabled ? "true" : "false"
      );
      elems[i].setAttribute("disabled", "disabled");
      elems[i].style.pointerEvents = "none";
      elems[i].style.webkitFilter = "grayscale(100%)";
      elems[i].style.filter = "grayscale(100%)";
    }
  }
  unlockForm() {
    const elems = this.form.querySelectorAll(
      "input, textarea, button, select"
    );
    for (let i = 0, len = elems.length; i < len; ++i) {
      if (elems[i].getAttribute("data-just-validate-fallback-disabled") !== "true") {
        elems[i].removeAttribute("disabled");
      }
      elems[i].style.pointerEvents = "";
      elems[i].style.webkitFilter = "";
      elems[i].style.filter = "";
    }
  }
  renderTooltip(elem, errorLabel, position) {
    var _a;
    const { top, left, width, height } = elem.getBoundingClientRect();
    const errorLabelRect = errorLabel.getBoundingClientRect();
    const pos = position || ((_a = this.globalConfig.tooltip) == null ? void 0 : _a.position);
    switch (pos) {
      case "left": {
        errorLabel.style.top = `${top + height / 2 - errorLabelRect.height / 2}px`;
        errorLabel.style.left = `${left - errorLabelRect.width - TOOLTIP_ARROW_HEIGHT}px`;
        break;
      }
      case "top": {
        errorLabel.style.top = `${top - errorLabelRect.height - TOOLTIP_ARROW_HEIGHT}px`;
        errorLabel.style.left = `${left + width / 2 - errorLabelRect.width / 2}px`;
        break;
      }
      case "right": {
        errorLabel.style.top = `${top + height / 2 - errorLabelRect.height / 2}px`;
        errorLabel.style.left = `${left + width + TOOLTIP_ARROW_HEIGHT}px`;
        break;
      }
      case "bottom": {
        errorLabel.style.top = `${top + height + TOOLTIP_ARROW_HEIGHT}px`;
        errorLabel.style.left = `${left + width / 2 - errorLabelRect.width / 2}px`;
        break;
      }
    }
    errorLabel.dataset.direction = pos;
    const refresh = () => {
      this.renderTooltip(elem, errorLabel, position);
    };
    return {
      refresh
    };
  }
  createErrorLabelElem(key, errorMessage, config) {
    const errorLabel = document.createElement("div");
    errorLabel.innerHTML = errorMessage;
    const customErrorLabelStyle = this.isTooltip() ? config == null ? void 0 : config.errorLabelStyle : (config == null ? void 0 : config.errorLabelStyle) || this.globalConfig.errorLabelStyle;
    Object.assign(errorLabel.style, customErrorLabelStyle);
    errorLabel.classList.add(
      ...getClassList(
        (config == null ? void 0 : config.errorLabelCssClass) || this.globalConfig.errorLabelCssClass
      ),
      "just-validate-error-label"
    );
    if (this.isTooltip()) {
      errorLabel.dataset.tooltip = "true";
    }
    if (this.globalConfig.testingMode) {
      errorLabel.dataset.testId = `error-label-${key}`;
    }
    this.errorLabels[key] = errorLabel;
    return errorLabel;
  }
  createSuccessLabelElem(key, successMessage, config) {
    if (successMessage === void 0) {
      return null;
    }
    const successLabel = document.createElement("div");
    successLabel.innerHTML = successMessage;
    const customSuccessLabelStyle = (config == null ? void 0 : config.successLabelStyle) || this.globalConfig.successLabelStyle;
    Object.assign(successLabel.style, customSuccessLabelStyle);
    successLabel.classList.add(
      ...getClassList(
        (config == null ? void 0 : config.successLabelCssClass) || this.globalConfig.successLabelCssClass
      ),
      "just-validate-success-label"
    );
    if (this.globalConfig.testingMode) {
      successLabel.dataset.testId = `success-label-${key}`;
    }
    this.successLabels[key] = successLabel;
    return successLabel;
  }
  renderErrorsContainer(label, errorsContainer) {
    const container = errorsContainer || this.globalConfig.errorsContainer;
    if (typeof container === "string") {
      const elem = this.form.querySelector(container);
      if (elem) {
        elem.appendChild(label);
        return true;
      } else {
        console.error(
          `Error container with ${container} selector not found. Errors will be rendered as usual`
        );
      }
    }
    if (container instanceof Element) {
      container.appendChild(label);
      return true;
    }
    if (container !== void 0) {
      console.error(
        `Error container not found. It should be a string or existing Element. Errors will be rendered as usual`
      );
    }
    return false;
  }
  renderGroupLabel(elem, label, errorsContainer, isSuccess) {
    if (!isSuccess) {
      const renderedInErrorsContainer = this.renderErrorsContainer(
        label,
        errorsContainer
      );
      if (renderedInErrorsContainer) {
        return;
      }
    }
    elem.appendChild(label);
  }
  renderFieldLabel(elem, label, errorsContainer, isSuccess) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (!isSuccess) {
      const renderedInErrorsContainer = this.renderErrorsContainer(
        label,
        errorsContainer
      );
      if (renderedInErrorsContainer) {
        return;
      }
    }
    if (elem.type === "checkbox" || elem.type === "radio") {
      const labelElem = document.querySelector(
        `label[for="${elem.getAttribute("id")}"]`
      );
      if (((_b = (_a = elem.parentElement) == null ? void 0 : _a.tagName) == null ? void 0 : _b.toLowerCase()) === "label") {
        (_d = (_c = elem.parentElement) == null ? void 0 : _c.parentElement) == null ? void 0 : _d.appendChild(label);
      } else if (labelElem) {
        (_e = labelElem.parentElement) == null ? void 0 : _e.appendChild(label);
      } else {
        (_f = elem.parentElement) == null ? void 0 : _f.appendChild(label);
      }
    } else {
      (_g = elem.parentElement) == null ? void 0 : _g.appendChild(label);
    }
  }
  showLabels(fields, isError) {
    Object.keys(fields).forEach((fieldName, i) => {
      const error = fields[fieldName];
      const key = this.getKeyByFieldSelector(fieldName);
      if (!key || !this.fields[key]) {
        console.error(`Field not found. Check the field selector.`);
        return;
      }
      const field = this.fields[key];
      field.isValid = !isError;
      this.clearFieldStyle(key);
      this.clearFieldLabel(key);
      this.renderFieldError(key, false, error);
      if (i === 0 && this.globalConfig.focusInvalidField) {
        setTimeout(() => field.elem.focus(), 0);
      }
    });
  }
  showErrors(fields) {
    if (typeof fields !== "object") {
      throw Error(
        "[showErrors]: Errors should be an object with key: value format"
      );
    }
    this.showLabels(fields, true);
  }
  showSuccessLabels(fields) {
    if (typeof fields !== "object") {
      throw Error(
        "[showSuccessLabels]: Labels should be an object with key: value format"
      );
    }
    this.showLabels(fields, false);
  }
  renderFieldError(key, forced = false, message) {
    var _a, _b, _c, _d, _e, _f;
    const field = this.fields[key];
    if (field.isValid === false) {
      this.isValid = false;
    }
    if (field.isValid === void 0 || !forced && !this.isSubmitted && !field.touched && message === void 0) {
      return;
    }
    if (field.isValid) {
      if (!field.asyncCheckPending) {
        const successLabel = this.createSuccessLabelElem(
          key,
          message !== void 0 ? message : field.successMessage,
          field.config
        );
        if (successLabel) {
          this.renderFieldLabel(
            field.elem,
            successLabel,
            (_a = field.config) == null ? void 0 : _a.errorsContainer,
            true
          );
        }
        field.elem.classList.add(
          ...getClassList(
            ((_b = field.config) == null ? void 0 : _b.successFieldCssClass) || this.globalConfig.successFieldCssClass
          )
        );
      }
      return;
    }
    field.elem.classList.add(
      ...getClassList(
        ((_c = field.config) == null ? void 0 : _c.errorFieldCssClass) || this.globalConfig.errorFieldCssClass
      )
    );
    const errorLabel = this.createErrorLabelElem(
      key,
      message !== void 0 ? message : field.errorMessage,
      field.config
    );
    this.renderFieldLabel(
      field.elem,
      errorLabel,
      (_d = field.config) == null ? void 0 : _d.errorsContainer
    );
    if (this.isTooltip()) {
      this.tooltips.push(
        this.renderTooltip(
          field.elem,
          errorLabel,
          (_f = (_e = field.config) == null ? void 0 : _e.tooltip) == null ? void 0 : _f.position
        )
      );
    }
  }
  renderGroupError(key, force = true) {
    var _a, _b, _c, _d;
    const group = this.groupFields[key];
    if (group.isValid === false) {
      this.isValid = false;
    }
    if (group.isValid === void 0 || !force && !this.isSubmitted && !group.touched) {
      return;
    }
    if (group.isValid) {
      group.elems.forEach((elem) => {
        var _a2, _b2;
        Object.assign(
          elem.style,
          ((_a2 = group.config) == null ? void 0 : _a2.successFieldStyle) || this.globalConfig.successFieldStyle
        );
        elem.classList.add(
          ...getClassList(
            ((_b2 = group.config) == null ? void 0 : _b2.successFieldCssClass) || this.globalConfig.successFieldCssClass
          )
        );
      });
      const successLabel = this.createSuccessLabelElem(
        key,
        group.successMessage,
        group.config
      );
      if (successLabel) {
        this.renderGroupLabel(
          group.groupElem,
          successLabel,
          (_a = group.config) == null ? void 0 : _a.errorsContainer,
          true
        );
      }
      return;
    }
    this.isValid = false;
    group.elems.forEach((elem) => {
      var _a2, _b2;
      Object.assign(
        elem.style,
        ((_a2 = group.config) == null ? void 0 : _a2.errorFieldStyle) || this.globalConfig.errorFieldStyle
      );
      elem.classList.add(
        ...getClassList(
          ((_b2 = group.config) == null ? void 0 : _b2.errorFieldCssClass) || this.globalConfig.errorFieldCssClass
        )
      );
    });
    const errorLabel = this.createErrorLabelElem(
      key,
      group.errorMessage,
      group.config
    );
    this.renderGroupLabel(
      group.groupElem,
      errorLabel,
      (_b = group.config) == null ? void 0 : _b.errorsContainer
    );
    if (this.isTooltip()) {
      this.tooltips.push(
        this.renderTooltip(
          group.groupElem,
          errorLabel,
          (_d = (_c = group.config) == null ? void 0 : _c.tooltip) == null ? void 0 : _d.position
        )
      );
    }
  }
  renderErrors(forceRevalidation = false) {
    if (!this.isSubmitted && !forceRevalidation && !this.globalConfig.validateBeforeSubmitting) {
      return;
    }
    this.clearErrors();
    this.isValid = true;
    for (const key in this.groupFields) {
      this.renderGroupError(key);
    }
    for (const key in this.fields) {
      this.renderFieldError(key);
    }
  }
  destroy() {
    this.eventListeners.forEach((event) => {
      this.removeListener(event.type, event.elem, event.func);
    });
    Object.keys(this.customStyleTags).forEach((key) => {
      this.customStyleTags[key].remove();
    });
    this.clearErrors();
    if (this.globalConfig.lockForm) {
      this.unlockForm();
    }
  }
  refresh() {
    this.destroy();
    if (!this.form) {
      console.error("Cannot initialize the library! Form is not defined");
    } else {
      this.initialize(this.form, this.globalConfig);
      Object.keys(this.fields).forEach((key) => {
        const fieldSelector = this.getFieldSelectorByKey(key);
        if (fieldSelector) {
          this.addField(
            fieldSelector,
            [...this.fields[key].rules],
            this.fields[key].config
          );
        }
      });
    }
  }
  setCurrentLocale(locale) {
    if (typeof locale !== "string" && locale !== void 0) {
      console.error("Current locale should be a string");
      return;
    }
    this.currentLocale = locale;
    if (this.isSubmitted) {
      this.validate();
    }
  }
  onSuccess(callback) {
    this.onSuccessCallback = callback;
    return this;
  }
  onFail(callback) {
    this.onFailCallback = callback;
    return this;
  }
  onValidate(callback) {
    this.onValidateCallback = callback;
    return this;
  }
}



/***/ }),

/***/ "./src/js/_components.js":
/*!*******************************!*\
  !*** ./src/js/_components.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _components_timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/timer.js */ "./src/js/components/timer.js");
/* harmony import */ var _components_modal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/modal.js */ "./src/js/components/modal.js");
/* harmony import */ var _components_validation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/validation.js */ "./src/js/components/validation.js");
 // таймер



// promo-actual
(0,_components_modal_js__WEBPACK_IMPORTED_MODULE_1__["default"])('.promo__header-modal-discount', '.modal-discount', '.modal-discount .modal__close');
(0,_components_modal_js__WEBPACK_IMPORTED_MODULE_1__["default"])('.promo__header-modal-tiresСasco', '.modal-tiresСasco', '.modal-tiresСasco .modal__close');
(0,_components_modal_js__WEBPACK_IMPORTED_MODULE_1__["default"])('.promo__header-modal-bestPrice', '.modal-bestPrice', '.modal-bestPrice .modal__close');

// choice-car-card
// document.querySelectorAll('.choice-car__btn-buy').forEach(btnBuy => {
// 	modal(btnBuy, '.modal-btnUnderCar', '.modal-btnUnderCar .modal__close', true);
// });
// document.querySelectorAll('.choice-car__btn-order').forEach(btnOrder => {
// 	modal(btnOrder, '.modal-btnUnderCar', '.modal-btnUnderCar .modal__close', true);
// });


document.querySelectorAll('.form').forEach(form => {
  (0,_components_validation_js__WEBPACK_IMPORTED_MODULE_2__["default"])(form);
  form.querySelectorAll('.form__input').forEach(input => {
    input.onblur = function (e) {
      if (this.classList.contains('input__tel')) {
        // console.log(e.target.inputmask.unmaskedvalue().length, 'blur tel');
        const targetLength = e.target.inputmask.unmaskedvalue().length;
        if (0 < targetLength && targetLength < 10) {
          this.classList.add('just-validate-error-field');
        } else if (0 < targetLength) {
          this.classList.add('just-validate-success-field');
        }
      }
      if (this.classList.contains('input__name')) {
        // console.log(e.target.value.length, 'blur name');
        const targetLength = e.target.value.length;
        if (0 < targetLength && targetLength < 3) {
          this.classList.add('just-validate-error-field');
        } else if (0 < targetLength) {
          this.classList.add('just-validate-success-field');
        }
      }
    };
    input.onfocus = function () {
      // if (this.classList.contains('input__tel')) {
      //   console.log(this.inputmask.unmaskedvalue(), 'focus tel');
      // }
      this.classList.contains('just-validate-error-field') && this.classList.remove('just-validate-error-field');
      this.classList.contains('just-validate-success-field') && this.classList.remove('just-validate-success-field');
      // if (this.classList.contains('input__name')) {
      //   console.log(this, 'focus name');
      // }
    };
  });
});

/***/ }),

/***/ "./src/js/components/chat.js":
/*!***********************************!*\
  !*** ./src/js/components/chat.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "chat3": () => (/* binding */ chat3)
/* harmony export */ });
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./filter.js */ "./src/js/components/filter.js");
/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers.js */ "./src/js/components/helpers.js");
/* harmony import */ var _slider_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./slider.js */ "./src/js/components/slider.js");



// import { yearsDefaultState } from './years.js';

// =========скроллы========
// скролл до начала сообщения от консультанта +10px вверх
const scrollMsg = msg => {
  window.scrollBy({
    top: msg.offsetHeight + 10,
    // скролл на высоту сообщения консультанта
    behavior: 'smooth'
  });
};

// прокрутка до определённого сообщения
const scrollIntoViewOptions = {
  behavior: 'smooth',
  block: 'end',
  inline: 'nearest'
};

// скролл до начала новой темы чата, после того, как все сообщения появились
const scrollChat = chat => {
  const elementPosition = chat.getBoundingClientRect().top; //расстояние от элемента до верхней части экрана
  const consultantSticky = document.querySelector('.consultant_sticky');
  // если consultantSticky виден, то скроллится с учётом высоты этого стики, если нет, то без учёта
  const offsetPosition = elementPosition - (consultantSticky ? consultantSticky.offsetHeight : 0); // насколько нужно скролить
  window.scrollBy({
    top: offsetPosition,
    behavior: 'smooth'
  });
};

// ===========сам GIGA CHATIC==========
// необходим, т.к. будем сравнивать текущий чат, с другой относительной позицией чата, чтобы вернуться к прошлому чату
let numberChat = 0;
let animShowChat;
const chatMain = document.querySelector('.chat');
const chats = document.querySelectorAll('.chat-messages');
const chatLength = chats.length; // длина блоков чата 8

// скролл к концу чата
const scrollEndChat = () => {
  chatMain.scrollIntoView(scrollIntoViewOptions);
};

// NOTE: последние чаты
// const chatBlock = chatMain.querySelectorAll('.chat__block');
const chatLastBlock = document.querySelector('.chat-last-block');
const promoFooterInner = document.querySelector('.promo__footer-inner');
const footer = document.querySelector('.footer');
const showLastChat = chat => {
  setTimeout(() => {
    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.addClass)(chatLastBlock, 'msg-show'); // 6
    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.addClass)(promoFooterInner, 'active');
    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.addClass)(footer, 'active');
    scrollChat(chat);
    animShowChat = false;
  }, 3800);
};
const hiddenLastChat = () => {
  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.removeClass)(chatLastBlock, 'msg-show'); // 6
  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.removeClass)(promoFooterInner, 'active');
  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.removeClass)(footer, 'active');
};

// NOTE: удаление активных классов с чатов, которые отображены,
// дальше той секции блока, в котором произошёл клик
const resetActiveAllBlock = currentNumber => {
  for (let i = currentNumber + 1; i < chatLength; i++) {
    // ====NOTE: chat__message-block====
    // ====получаем кол-во блоков сообщений: анимация печати + вопрос консультанта
    const msgBlocks = chats[i].querySelectorAll('.chat__message-block');
    // блоки с анимацией печатания и с сообщениями консультанта --- удаляем в них активные классы
    msgBlocks.forEach(msgBlock => {
      // анимация печатания
      const msgPrint = msgBlock.querySelector('.chat__message-print'); // анимация печатания
      // сообщение с вопросом консультанта
      // удаление активных классов
      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.removeClass)(msgPrint, 'msg-print-show');
    });
    // NOTE: блок CHOICE
    const msgBlocksChoice = chats[i].querySelector('.chat__message-block-choice');
    if (msgBlocksChoice) {
      // блок с выборами
      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.removeClass)(msgBlocksChoice, 'msg-show');
      // блоки с вариантами выбора
      const BlocksChoice = msgBlocksChoice.querySelectorAll('.block-choice');
      BlocksChoice && (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.removeClassArray)(BlocksChoice, 'active');
    }

    // сообщение ответа клиента
    const msgClient = chats[i].querySelector('.chat__message-client');
    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.removeClass)(msgClient, 'msg-show');
    // console.log(i, 'i');

    // очистка filter
    if (i === 1) {
      (0,_filter_js__WEBPACK_IMPORTED_MODULE_0__.filterReset)();
    }

    // если тема чата это предпоследний чат, то нужно скрыть:
    //  два последних чата и actual-promo и footer
    if (i === 2) {
      hiddenLastChat();
    }
  }
};

// =====ЛОГИКА ЧАТА2=====
const chat3 = () => {
  // console.log(numberChat, 'numberChat');
  animShowChat = true;

  // получаем блок чата
  // ====NOTE: chat=№
  const chat = chats[numberChat];
  // ====NOTE: chat__message-block====
  // ====получаем кол-во блоков сообщений: анимация печати + вопрос консультанта
  const msgBlocks = chat.querySelectorAll('.chat__message-block');

  // NOTE: показ сообщений консультанта и печатание
  numberChat && msgBlocks.forEach((msgBlock, index) => {
    // анимация печатания
    const msgPrint = msgBlock.querySelector('.chat__message-print');
    setTimeout(() => {
      // анимация 'Ольга печатает...', задержка появления в 500мс
      setTimeout(() => {
        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.addClass)(msgPrint, 'msg-print-show');
        numberChat && msgPrint && scrollMsg(msgPrint);
      }, 600);
      // скрытие о печатании консультанта
      // показ вопроса от консультанта
      // с задержкой в 2,5с + 550мс
      setTimeout(() => {
        // удаление анимации печатания
        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.removeClass)(msgPrint, 'msg-print-show');
        // console.log(msgConsult, msgConsult.offsetHeight);
      }, 2500);
    }, index * 2500 + 650);
    // 2500 + 550:
    //						--- 550(500) - с запасом взятое время появления анимации печати,
    //						--- 2500 - время удаления + появления вопроса консультанта
    // итого время показа одного блока сообщений консультанта "2500+550=3050мс"
  });

  if (numberChat === 1) {
    (0,_slider_js__WEBPACK_IMPORTED_MODULE_2__.sliderReset)();
  }
  // ====NOTE: если номер чата равен 2 (последний пункт),
  // то нужно показать эти блоки и выйти
  if (numberChat === 2) {
    showLastChat(chat);
    return;
  }
  if (numberChat === 0) {
    animShowChat = false;
  }

  // NOTE: СООБЩЕНИЯ КЛИЕНТА
  // сообщение ответ клиента
  const msgAnswer = chat.querySelector('.chat__message-client');
  // блок choice
  const msgBlockChoice = chat.querySelector('.chat__message-block-choice');

  // ====текущий чат, эта переменная необходима, чтобы она замкнулась в прослушке функции следящая за блоком выборов и для блоков с multi
  const currentNumber = Number(chat.dataset.chat);
  // const currentNumber = numberChat;
  numberChat && setTimeout(() => {
    // блок с выборами появляется, если он есть в секции чата
    msgBlockChoice && (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.addClass)(msgBlockChoice, 'msg-show');
    setTimeout(() => {
      // плавный скролл до начала нового блока чата с отступом
      // console.log('вниз до нового блока чата');
      numberChat && scrollChat(chat);
    });
    // появление всех блоков завершено
    setTimeout(() => {
      animShowChat = false;
    });
  }, 2500 * msgBlocks.length + 950);

  // ======NOTE: "блок с выборами"
  if (msgBlockChoice) {
    // console.log('choice', choice);

    // блоки c вариантами выбора, за которыми нужно следить
    // родитель блоков выбора
    const blocksChoice = msgBlockChoice.querySelector('.blocks-choice');
    // сами блоки выбора
    const blockChoiceAll = msgBlockChoice.querySelectorAll('.block-choice');
    const blockChoiceClick = e => {
      // console.log(animShowChat, 'choice');
      // console.log(e.target, 'target');
      if ((0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.containsClass)(e.target, 'choice-car__btn-buy') || (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.containsClass)(e.target, 'choice-car__tel') || (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.containsClass)(e.target, 'choice-car__btn-order')) {
        return;
      }

      // блок на который нажали
      const block = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.closestElement)(e.target, 'block-choice');
      // если текущий чат совпадает с глобальным номером чата,
      // то есть нажали на выбор в последнем доступном чате, то:
      if (currentNumber === numberChat && block) {
        // console.log('currentNumber === numberChat');
        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.removeClassArray)(blockChoiceAll, 'active');
        // доб. класс active на нажатый выбор
        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.addClass)(block, 'active');
        // ответ берём из data блока на который нажали
        msgAnswer.innerText = block.dataset.choice;
        // показываем сообщение ответ клиента
        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.addClass)(msgAnswer, 'msg-show');
        // прокрутка вниз, до сообщения с ответом клиента, т.е. внизу окажется сообщение ответ клиента
        // console.log('вниз до сообщения ответа клиента');
        scrollEndChat();
        // увеличиваем счётчик чата, чтобы запустить следующий чат
        numberChat++;
        chat3();
      } else {
        // NOTE: когда меняем ответ в чате
        // но нас не пустит, пока animShowChat не станет === false
        // он меняется выше, после появление последнего блока
        if (!animShowChat && block) {
          // срабатывает когда нажимаешь на блок с выборами, на другой вариант
          // и тогда удаляются все активные классы в других темах чата
          // console.log('заново choice');
          // ====скрываем сообщение ответ клиента:
          (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.removeClass)(msgAnswer, 'msg-show');
          msgAnswer.innerText = block.dataset.choice;

          // удаляем активные классы с данного choice
          (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.removeClassArray)(blockChoiceAll, 'active');
          // доб. активный класс на тот блок, который нажали
          (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.addClass)(block, 'active');

          // ====NOTE: пройдёмся по всем секциям чата, которые отображены, дальше той секции блока, в котором произошёл клик
          resetActiveAllBlock(currentNumber);
          setTimeout(() => {
            // появляется сообщение клиента
            (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.addClass)(msgAnswer, 'msg-show');
            // скролл до конца сообщения клиента
            // прокрутка вниз, до сообщения с ответом клиента
            // console.log(currentNumber, 'last');
            scrollEndChat();
            // NOTE:
            // запускаем секцию чата, в которой произошёл клик, заново
            numberChat = currentNumber + 1;
            // console.log(numberChat, 'новый счёт choice');
            chat3();
          }, 200);
        } else return;
      }
    };
    blocksChoice.addEventListener('click', blockChoiceClick);
  }
};


/***/ }),

/***/ "./src/js/components/filter.js":
/*!*************************************!*\
  !*** ./src/js/components/filter.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "filter": () => (/* binding */ filter),
/* harmony export */   "filterReset": () => (/* binding */ filterReset)
/* harmony export */ });
/* harmony import */ var _years_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./years.js */ "./src/js/components/years.js");

(0,_years_js__WEBPACK_IMPORTED_MODULE_0__.yearsInit)();

// сброс всех значений в фильтре
const filterReset = () => {
  (0,_years_js__WEBPACK_IMPORTED_MODULE_0__.yearsDefaultState)();
  document.querySelectorAll('.mileage__input').forEach(input => input.value = '');
};

// кнопка "сбросить"
const filter = () => {
  document.querySelector('.filter__btn-reset').addEventListener('click', filterReset);
};

/***/ }),

/***/ "./src/js/components/helpers.js":
/*!**************************************!*\
  !*** ./src/js/components/helpers.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addClass": () => (/* binding */ addClass),
/* harmony export */   "answerChoice": () => (/* binding */ answerChoice),
/* harmony export */   "closestElement": () => (/* binding */ closestElement),
/* harmony export */   "containsAndRemove": () => (/* binding */ containsAndRemove),
/* harmony export */   "containsClass": () => (/* binding */ containsClass),
/* harmony export */   "removeClass": () => (/* binding */ removeClass),
/* harmony export */   "removeClassArray": () => (/* binding */ removeClassArray),
/* harmony export */   "resetAnswer": () => (/* binding */ resetAnswer),
/* harmony export */   "toggleClass": () => (/* binding */ toggleClass)
/* harmony export */ });
const addClass = (element, cls) => {
  element?.classList.add(cls);
};
const toggleClass = (element, cls) => {
  element?.classList.toggle(cls);
};
const removeClass = (element, cls) => {
  element?.classList.remove(cls);
};
const containsClass = (element, cls) => {
  return element?.classList.contains(cls);
};
const containsAndRemove = (element, cls) => {
  element?.classList.contains(cls) && element.classList.remove(cls);
};
const removeClassArray = (elements, cls) => {
  elements?.forEach(element => {
    element?.classList.remove(cls);
  });
};
const closestElement = (element, cls) => {
  return element?.closest(`.${cls}`);
};
const resetAnswer = (cls, defaultAnswer) => {
  const block = document.querySelector(`.${cls}`);
  const answerMessage = block.querySelector('.btn-continue');
  answerMessage.dataset.multi = defaultAnswer;
};
const answerChoice = (blockMain, blockChoice) => {
  const blockParent = document.querySelector(blockMain);
  const blocks = blockParent.querySelectorAll(blockChoice);
  const chatMessageBlock = closestElement(blockParent, 'chat__message-block-choice');
  const answerMessage = chatMessageBlock.nextElementSibling;
  blockParent.addEventListener('click', e => {
    const block = closestElement(e.target, blockChoice);
    removeClassArray(blocks, 'active');
    addClass(block, 'active');
    answerMessage.innerText = block.dataset.choice;
  });
};

/***/ }),

/***/ "./src/js/components/modal.js":
/*!************************************!*\
  !*** ./src/js/components/modal.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.js */ "./src/js/components/helpers.js");

const modalErrorDelete = modal => {
  modal.querySelectorAll('.form__input')?.forEach(input => {
    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.removeClass)(input, 'just-validate-error-field');
  });
  modal.querySelectorAll('.just-validate-error-label')?.forEach(errorElement => errorElement.remove());
};
const modal = function (btnOpen, modal, btnClose) {
  let isLink = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  !isLink && (btnOpen = document.querySelector(btnOpen));
  modal = document.querySelector(modal);
  btnClose = document.querySelector(btnClose);
  const body = document.body;
  const removeActiveClassModal = () => {
    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.removeClass)(body, '_lock');
    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.removeClass)(modal, 'active');
    modalErrorDelete(modal);
  };
  // открытие модального окна
  btnOpen?.addEventListener('click', e => {
    e.preventDefault();
    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.addClass)(body, '_lock');
    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.addClass)(modal, 'active');
  });
  // закрытие модального окна: по кнопке
  btnClose?.addEventListener('click', () => {
    removeActiveClassModal();
  });
  // закрытие модального окна: по области вокруг модального окна
  modal?.addEventListener('click', e => {
    if (e.target === modal) {
      removeActiveClassModal();
    }
  });
};
// btnOpen --- класс кнопки, при клике на которую будет ОТКРЫВАТЬСЯ модальное окно
// modal --- класс открываемого модального окна
// btnClose --- класс кнопки, при клике на которую будет ЗАКРЫВАТЬСЯ модальное окно
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (modal);

/***/ }),

/***/ "./src/js/components/modalChoiceCar.js":
/*!*********************************************!*\
  !*** ./src/js/components/modalChoiceCar.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.js */ "./src/js/components/helpers.js");

// import modal from './modal.js';

const modalErrorDelete = modal => {
  modal.querySelectorAll('.form__input')?.forEach(input => {
    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.removeClass)(input, 'just-validate-error-field');
  });
  modal.querySelectorAll('.just-validate-error-label')?.forEach(errorElement => errorElement.remove());
};
const choiceCarBlocks = document.querySelector('.choice-car__blocks');
choiceCarBlocks.addEventListener('click', e => {
  // console.log(e.target, 'target');
  const btnOpen = e.target;
  if ((0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.containsClass)(btnOpen, 'choice-car__btn-buy') || (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.containsClass)(btnOpen, 'choice-car__btn-order')) {
    const modal = document.querySelector('.modal-btnUnderCar');
    const btnClose = document.querySelector('.modal-btnUnderCar .modal__close');
    const body = document.body;
    const removeActiveClassModal = () => {
      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.removeClass)(body, '_lock');
      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.removeClass)(modal, 'active');
      modalErrorDelete(modal);
      btnClose.removeEventListener('click', removeActiveClassModal);
    };
    // открытие модального окна
    e.preventDefault();
    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.addClass)(body, '_lock');
    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.addClass)(modal, 'active');

    // закрытие модального окна: по кнопке
    btnClose?.addEventListener('click', removeActiveClassModal, {
      once: true
    });
    // закрытие модального окна: по области вокруг модального окна
    // const removeActiveClassModalClick = e => {
    // 	if (e.target === modal) {
    // 		removeActiveClassModal();
    // 	}
    // };
    // modal?.addEventListener('click', removeActiveClassModalClick, { once: true });
    modal?.addEventListener('click', e => {
      if (e.target === modal) {
        removeActiveClassModal();
      }
    }, {
      once: true
    });
  }
});

/***/ }),

/***/ "./src/js/components/slider.js":
/*!*************************************!*\
  !*** ./src/js/components/slider.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sliderReset": () => (/* binding */ sliderReset)
/* harmony export */ });
/* harmony import */ var _fancyapps_ui_dist_carousel_carousel_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fancyapps/ui/dist/carousel/carousel.esm.js */ "./node_modules/@fancyapps/ui/dist/carousel/carousel.esm.js");

const sliderCarousel = document.querySelector('.choice-car__wrapper');
const choiceSlide = sliderCarousel.querySelectorAll('.choice-car__slide');
const choiceSlideImg = choiceSlide[0].querySelector('img');
const options = {
  Dots: false,
  infinite: true,
  transition: 'slide'
};
const sliderStart = () => {
  const sliderCarousel = document.querySelectorAll('.choice-car__wrapper');
  sliderCarousel.forEach(slider => {
    new _fancyapps_ui_dist_carousel_carousel_esm_js__WEBPACK_IMPORTED_MODULE_0__.Carousel(slider, options);
  });
};
// если есть картинка при первой загрузки страницы, то инициализируется слайдер
// для git
if (window.innerWidth === 800) {
  if (choiceSlideImg.dataset.lazySrc) {
    new _fancyapps_ui_dist_carousel_carousel_esm_js__WEBPACK_IMPORTED_MODULE_0__.Carousel(sliderCarousel, options);
  }
}

// для прод
const sliderReset = () => {
  sliderStart();
};

/***/ }),

/***/ "./src/js/components/stickyConsultant.js":
/*!***********************************************!*\
  !*** ./src/js/components/stickyConsultant.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.js */ "./src/js/components/helpers.js");


// фиксация шапки консультанта
const consultSticky = document.querySelector('.consultant_sticky');
const chatConsultant = document.querySelector('.chat__consultant');
const TopChatConsultant = chatConsultant.getBoundingClientRect().top; // высота до верхней точки страница (не экрана, а СТРАНИЦЫ)
// console.log(TopChatConsultant);

function stickyConsultant() {
  // console.log(window.scrollY);
  if (window.scrollY > TopChatConsultant * 1.03) {
    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.addClass)(consultSticky, 'show');
  } else {
    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.containsClass)(consultSticky, 'show') && (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.removeClass)(consultSticky, 'show');
  }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stickyConsultant);

/***/ }),

/***/ "./src/js/components/timer.js":
/*!************************************!*\
  !*** ./src/js/components/timer.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
document.addEventListener('DOMContentLoaded', () => {
  const daysVal = document.querySelector('.timer__day');
  const hoursVal = document.querySelector('.timer__hour');
  const minutesVal = document.querySelector('.timer__min');
  const daysText = document.querySelector('.timer__day-text');
  const hoursText = document.querySelector('.timer__hour-text');
  const minutesText = document.querySelector('.timer__min-text');
  function declOfNum(number, titles) {
    let cases = [2, 0, 1, 1, 1, 2];
    return titles[number % 100 > 4 && number % 100 < 20 ? 2 : cases[number % 10 < 5 ? number % 10 : 5]];
  }
  const timeCount = () => {
    const now = new Date();
    const dayWeek = new Date().getDay(); // день недели
    let dayLeft = 8 - dayWeek; // дней осталось до пн
    dayLeft === 8 && (dayLeft = 1); // если вс, то 1 день остался до пн
    // console.log(dayLeft);

    const monday = new Date(now.getFullYear(), now.getMonth(), now.getDate() + dayLeft); // пн след недели

    // console.log(monday.getDate(), 'дата');
    // console.log(monday.getHours(), 'часы');
    // console.log(monday.getMinutes(), 'минуты');
    // console.log(monday.toLocaleString());

    const leftUntil = monday - now; // осталось до конца недели
    // console.log(leftUntil);

    let days = Math.floor(leftUntil / 1000 / 60 / 60 / 24);
    let hours = Math.floor(leftUntil / 1000 / 60 / 60) % 24;
    let minutes = Math.floor(leftUntil / 1000 / 60) % 60 + 1;
    daysVal.textContent = days;
    hoursVal.textContent = hours;
    minutesVal.textContent = minutes;
    daysText.textContent = declOfNum(days, ['день', 'дня', 'дней']);
    hoursText.textContent = declOfNum(hours, ['час', 'часа', 'часов']);
    minutesText.textContent = declOfNum(minutes, ['минута', 'минуты', 'минут']);
    // console.log(days, hours, minutes);
  };

  timeCount();
  setInterval(timeCount, 60000);
});

/***/ }),

/***/ "./src/js/components/validation.js":
/*!*****************************************!*\
  !*** ./src/js/components/validation.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var just_validate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! just-validate */ "./node_modules/just-validate/dist/just-validate.es.js");
/* harmony import */ var _vendor_inputMask_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./../vendor/inputMask.js */ "./src/js/vendor/inputMask.js");



// formSelector --- класс формы

const validateForms = form => {
  const inputTel = form?.querySelector('input[type="tel"]');
  if (inputTel) {
    const inputMask = new Inputmask('+7 (999) 999 - 99 - 99');
    inputMask.mask(inputTel);
  }
  const validation = new just_validate__WEBPACK_IMPORTED_MODULE_0__["default"](form);
  validation.addField('.input__tel', [{
    rule: 'required',
    value: true,
    errorMessage: 'Введите корректный номер телефона'
  }, {
    rule: 'function',
    validator: function () {
      const phone = inputTel.inputmask.unmaskedvalue();
      return phone.length === 10;
    },
    errorMessage: 'Введите корректный номер телефона'
  }]).addField('.input__name', [{
    rule: 'minLength',
    value: 3,
    errorMessage: 'Впишите не менее 3 букв'
  }, {
    rule: 'maxLength',
    value: 30,
    errorMessage: 'Впишите не более 30 букв'
  }, {
    rule: 'required',
    value: true,
    errorMessage: 'Введите имя'
  }]).onSuccess(event => {
    event.target.reset();
    document.querySelectorAll('.form').forEach(form => {
      form.querySelectorAll('.form__input').forEach(input => {
        input.classList.contains('just-validate-error-field') && input.classList.remove('just-validate-error-field');
        input.classList.contains('just-validate-success-field') && input.classList.remove('just-validate-success-field');
      });
    });

    // при удачной валидации модальное окно закрывается
    document.querySelectorAll('.modal').forEach(modal => {
      modal.classList.contains('active') && modal.classList.remove('active') && body.classList.remove('_lock');
    });
    const body = document.body;
    const modal = document.querySelector('.modal-sendForm');
    const btnClose = document.querySelector('.modal-sendForm .modal__close');
    body.classList.add('_lock');
    modal.classList.add('active');
    btnClose.addEventListener('click', () => {
      body.classList.remove('_lock');
      modal.classList.remove('active');
    });
    modal.addEventListener('click', e => {
      if (e.target === modal) {
        body.classList.remove('_lock');
        modal.classList.remove('active');
      }
    });
    setTimeout(() => {
      body.classList.remove('_lock');
      modal.classList.remove('active');
    }, 5000);
  });
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validateForms);

/***/ }),

/***/ "./src/js/components/years.js":
/*!************************************!*\
  !*** ./src/js/components/years.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "yearsDefaultState": () => (/* binding */ yearsDefaultState),
/* harmony export */   "yearsInit": () => (/* binding */ yearsInit),
/* harmony export */   "yearsShowSelect": () => (/* binding */ yearsShowSelect)
/* harmony export */ });
/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.js */ "./src/js/components/helpers.js");

const yearsShowSelect = () => {
  // let count = 0;

  const selects = document.querySelector('.years__selects');
  const inputTextFrom = document.querySelector('.input-text-from');
  selects.addEventListener('click', e => {
    const selectInput = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.closestElement)(e.target, 'years__input');
    const YearsOption = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.closestElement)(e.target, 'years__option');
    // если нажали на инпут год
    if (selectInput) {
      // console.log('selectInput====');
      // count++;
      const selector = selectInput.nextElementSibling; // блок со списком годов
      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toggleClass)(selectInput, 'active');
      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toggleClass)(selector, 'active');
      // console.log(selectFrom, '-', selectTo, 'count:', count);
    }

    // если выбран год
    if (YearsOption) {
      const selector = YearsOption.closest('.years__select');
      const options = selector.querySelectorAll('.option');
      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.removeClassArray)(options, 'active');
      const selectInput = selector.previousElementSibling;
      const inputYears = selectInput.querySelector('.input-years'); // вписывается год при выборе года
      const optionContainsFrom = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.containsClass)(YearsOption.parentElement, 'select-from');
      const optionContainsTo = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.containsClass)(YearsOption.parentElement, 'select-to');
      const checkboxBlocks = document.querySelectorAll('.years__checkbox-block'); // блоки checkbox с поколениями
      // если нажали на год
      if ((0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.containsClass)(YearsOption, 'option')) {
        // console.log('option====', YearsOption);
        // count++;
        const option = YearsOption.closest('.option');
        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.addClass)(option, 'active');
        inputYears.innerHTML = option.dataset.value;
        if (optionContainsFrom) {
          inputTextFrom.innerHTML = 'до';
        }
      }
      // если нажали на "очистить"
      if ((0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.containsClass)(YearsOption, 'clear')) {
        // console.log('optionClear====');
        // count++;
        inputTextFrom.innerHTML = 'Год до';
        inputYears.innerHTML = '';
      }
    }
    return;
  });

  // ====спрятать список годов====
  document.addEventListener('click', function (e) {
    if (!e.target.closest('.years__input')) {
      // console.log(e.target, selectInput);
      document.querySelectorAll('.years__input').forEach(selectInput => {
        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.removeClass)(selectInput, 'active');
        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.removeClass)(selectInput.nextElementSibling, 'active');
      });
      // console.log('глобал ин');
    }
    // console.log('глобал');
  });
};

const yearsInit = () => {
  yearsShowSelect();
};
const yearsDefaultState = () => {
  document.querySelectorAll('.years__input').forEach(selectInput => {
    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.removeClass)(selectInput, 'active');
    const selector = selectInput.nextElementSibling;
    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.removeClass)(selector, 'active');
    const option = selector.querySelectorAll('.option');
    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.removeClassArray)(option, 'active');
  });
  document.querySelector('.select-from>.clear').click();
  document.querySelector('.select-to>.clear').click();
};


/***/ }),

/***/ "./src/js/scripts.js":
/*!***************************!*\
  !*** ./src/js/scripts.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _components_chat_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/chat.js */ "./src/js/components/chat.js");
/* harmony import */ var _components_filter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/filter.js */ "./src/js/components/filter.js");
/* harmony import */ var _components_stickyConsultant_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/stickyConsultant.js */ "./src/js/components/stickyConsultant.js");
/* harmony import */ var _components_modalChoiceCar_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/modalChoiceCar.js */ "./src/js/components/modalChoiceCar.js");


// import { mileageInit } from './components/mileage.js';
// import { ownerInit } from './components/owner.js';
// import { sliderMethod } from './components/report.js';

// import { blockVisible, btnShowMoreClick } from './components/visibleBlockAndBtnShowMore.js';
// import { yearsInit } from './components/years.js';

// NOTE:===========CHAT start===========
(0,_components_chat_js__WEBPACK_IMPORTED_MODULE_0__.chat3)();
// ========= sticky consultant при скролле страницы=========
window.addEventListener('scroll', _components_stickyConsultant_js__WEBPACK_IMPORTED_MODULE_2__["default"]);

// =============FILTER==================
(0,_components_filter_js__WEBPACK_IMPORTED_MODULE_1__.filter)();

// choice-car


/***/ }),

/***/ "./src/js/vendor/inputMask.js":
/*!************************************!*\
  !*** ./src/js/vendor/inputMask.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
!function webpackUniversalModuleDefinition(root, factory) {
  if ('object' == typeof exports && 'object' == typeof module) module.exports = factory();else if ('function' == typeof define && define.amd) define([], factory);else {
    var a = factory();
    for (var i in a) ('object' == typeof exports ? exports : root)[i] = a[i];
  }
}(window, function () {
  return modules = [function (module) {
    module.exports = JSON.parse('{"BACKSPACE":8,"BACKSPACE_SAFARI":127,"DELETE":46,"DOWN":40,"END":35,"ENTER":13,"ESCAPE":27,"HOME":36,"INSERT":45,"LEFT":37,"PAGE_DOWN":34,"PAGE_UP":33,"RIGHT":39,"SPACE":32,"TAB":9,"UP":38,"X":88,"CONTROL":17}');
  }, function (module, exports, __nested_webpack_require_677__) {
    'use strict';

    function _typeof(obj) {
      return _typeof = 'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator ? function _typeof(obj) {
        return typeof obj;
      } : function _typeof(obj) {
        return obj && 'function' == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
      }, _typeof(obj);
    }
    var $ = __nested_webpack_require_677__(2),
      window = __nested_webpack_require_677__(3),
      document = window.document,
      generateMaskSet = __nested_webpack_require_677__(4).generateMaskSet,
      analyseMask = __nested_webpack_require_677__(4).analyseMask,
      maskScope = __nested_webpack_require_677__(7);
    function Inputmask(alias, options, internal) {
      if (!(this instanceof Inputmask)) return new Inputmask(alias, options, internal);
      this.el = void 0, this.events = {}, this.maskset = void 0, this.refreshValue = !1, !0 !== internal && ($.isPlainObject(alias) ? options = alias : (options = options || {}, alias && (options.alias = alias)), this.opts = $.extend(!0, {}, this.defaults, options), this.noMasksCache = options && void 0 !== options.definitions, this.userOptions = options || {}, resolveAlias(this.opts.alias, options, this.opts), this.isRTL = this.opts.numericInput);
    }
    function resolveAlias(aliasStr, options, opts) {
      var aliasDefinition = Inputmask.prototype.aliases[aliasStr];
      return aliasDefinition ? (aliasDefinition.alias && resolveAlias(aliasDefinition.alias, void 0, opts), $.extend(!0, opts, aliasDefinition), $.extend(!0, opts, options), !0) : (null === opts.mask && (opts.mask = aliasStr), !1);
    }
    function importAttributeOptions(npt, opts, userOptions, dataAttribute) {
      function importOption(option, optionData) {
        optionData = void 0 !== optionData ? optionData : npt.getAttribute(dataAttribute + '-' + option), null !== optionData && ('string' == typeof optionData && (0 === option.indexOf('on') ? optionData = window[optionData] : 'false' === optionData ? optionData = !1 : 'true' === optionData && (optionData = !0)), userOptions[option] = optionData);
      }
      if (!0 === opts.importDataAttributes) {
        var attrOptions = npt.getAttribute(dataAttribute),
          option,
          dataoptions,
          optionData,
          p;
        if (attrOptions && '' !== attrOptions && (attrOptions = attrOptions.replace(/'/g, '"'), dataoptions = JSON.parse('{' + attrOptions + '}')), dataoptions) for (p in optionData = void 0, dataoptions) if ('alias' === p.toLowerCase()) {
          optionData = dataoptions[p];
          break;
        }
        for (option in importOption('alias', optionData), userOptions.alias && resolveAlias(userOptions.alias, userOptions, opts), opts) {
          if (dataoptions) for (p in optionData = void 0, dataoptions) if (p.toLowerCase() === option.toLowerCase()) {
            optionData = dataoptions[p];
            break;
          }
          importOption(option, optionData);
        }
      }
      return $.extend(!0, opts, userOptions), 'rtl' !== npt.dir && !opts.rightAlign || (npt.style.textAlign = 'right'), 'rtl' !== npt.dir && !opts.numericInput || (npt.dir = 'ltr', npt.removeAttribute('dir'), opts.isRTL = !0), Object.keys(userOptions).length;
    }
    Inputmask.prototype = {
      dataAttribute: 'data-inputmask',
      defaults: {
        _maxTestPos: 500,
        placeholder: '_',
        optionalmarker: ['[', ']'],
        quantifiermarker: ['{', '}'],
        groupmarker: ['(', ')'],
        alternatormarker: '|',
        escapeChar: '\\',
        mask: null,
        regex: null,
        oncomplete: $.noop,
        onincomplete: $.noop,
        oncleared: $.noop,
        repeat: 0,
        greedy: !1,
        autoUnmask: !1,
        removeMaskOnSubmit: !1,
        clearMaskOnLostFocus: !0,
        insertMode: !0,
        insertModeVisual: !0,
        clearIncomplete: !1,
        alias: null,
        onKeyDown: $.noop,
        onBeforeMask: null,
        onBeforePaste: function onBeforePaste(pastedValue, opts) {
          return $.isFunction(opts.onBeforeMask) ? opts.onBeforeMask.call(this, pastedValue, opts) : pastedValue;
        },
        onBeforeWrite: null,
        onUnMask: null,
        showMaskOnFocus: !0,
        showMaskOnHover: !0,
        onKeyValidation: $.noop,
        skipOptionalPartCharacter: ' ',
        numericInput: !1,
        rightAlign: !1,
        undoOnEscape: !0,
        radixPoint: '',
        _radixDance: !1,
        groupSeparator: '',
        keepStatic: null,
        positionCaretOnTab: !0,
        tabThrough: !1,
        supportsInputType: ['text', 'tel', 'url', 'password', 'search'],
        ignorables: [8, 9, 19, 27, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 0, 229],
        isComplete: null,
        preValidation: null,
        postValidation: null,
        staticDefinitionSymbol: void 0,
        jitMasking: !1,
        nullable: !0,
        inputEventOnly: !1,
        noValuePatching: !1,
        positionCaretOnClick: 'lvp',
        casing: null,
        inputmode: 'text',
        importDataAttributes: !0,
        shiftPositions: !0
      },
      definitions: {
        9: {
          validator: '[0-9\uff11-\uff19]',
          definitionSymbol: '*'
        },
        a: {
          validator: '[A-Za-z\u0410-\u044f\u0401\u0451\xc0-\xff\xb5]',
          definitionSymbol: '*'
        },
        '*': {
          validator: '[0-9\uff11-\uff19A-Za-z\u0410-\u044f\u0401\u0451\xc0-\xff\xb5]'
        }
      },
      aliases: {},
      masksCache: {},
      mask: function mask(elems) {
        var that = this;
        return 'string' == typeof elems && (elems = document.getElementById(elems) || document.querySelectorAll(elems)), elems = elems.nodeName ? [elems] : elems, $.each(elems, function (ndx, el) {
          var scopedOpts = $.extend(!0, {}, that.opts);
          if (importAttributeOptions(el, scopedOpts, $.extend(!0, {}, that.userOptions), that.dataAttribute)) {
            var maskset = generateMaskSet(scopedOpts, that.noMasksCache);
            void 0 !== maskset && (void 0 !== el.inputmask && (el.inputmask.opts.autoUnmask = !0, el.inputmask.remove()), el.inputmask = new Inputmask(void 0, void 0, !0), el.inputmask.opts = scopedOpts, el.inputmask.noMasksCache = that.noMasksCache, el.inputmask.userOptions = $.extend(!0, {}, that.userOptions), el.inputmask.isRTL = scopedOpts.isRTL || scopedOpts.numericInput, el.inputmask.el = el, el.inputmask.maskset = maskset, $.data(el, '_inputmask_opts', scopedOpts), maskScope.call(el.inputmask, {
              action: 'mask'
            }));
          }
        }), elems && elems[0] && elems[0].inputmask || this;
      },
      option: function option(options, noremask) {
        return 'string' == typeof options ? this.opts[options] : 'object' === _typeof(options) ? ($.extend(this.userOptions, options), this.el && !0 !== noremask && this.mask(this.el), this) : void 0;
      },
      unmaskedvalue: function unmaskedvalue(value) {
        return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), maskScope.call(this, {
          action: 'unmaskedvalue',
          value: value
        });
      },
      remove: function remove() {
        return maskScope.call(this, {
          action: 'remove'
        });
      },
      getemptymask: function getemptymask() {
        return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), maskScope.call(this, {
          action: 'getemptymask'
        });
      },
      hasMaskedValue: function hasMaskedValue() {
        return !this.opts.autoUnmask;
      },
      isComplete: function isComplete() {
        return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), maskScope.call(this, {
          action: 'isComplete'
        });
      },
      getmetadata: function getmetadata() {
        return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), maskScope.call(this, {
          action: 'getmetadata'
        });
      },
      isValid: function isValid(value) {
        return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), maskScope.call(this, {
          action: 'isValid',
          value: value
        });
      },
      format: function format(value, metadata) {
        return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), maskScope.call(this, {
          action: 'format',
          value: value,
          metadata: metadata
        });
      },
      setValue: function setValue(value) {
        this.el && $(this.el).trigger('setvalue', [value]);
      },
      analyseMask: analyseMask
    }, Inputmask.extendDefaults = function (options) {
      $.extend(!0, Inputmask.prototype.defaults, options);
    }, Inputmask.extendDefinitions = function (definition) {
      $.extend(!0, Inputmask.prototype.definitions, definition);
    }, Inputmask.extendAliases = function (alias) {
      $.extend(!0, Inputmask.prototype.aliases, alias);
    }, Inputmask.format = function (value, options, metadata) {
      return Inputmask(options).format(value, metadata);
    }, Inputmask.unmask = function (value, options) {
      return Inputmask(options).unmaskedvalue(value);
    }, Inputmask.isValid = function (value, options) {
      return Inputmask(options).isValid(value);
    }, Inputmask.remove = function (elems) {
      'string' == typeof elems && (elems = document.getElementById(elems) || document.querySelectorAll(elems)), elems = elems.nodeName ? [elems] : elems, $.each(elems, function (ndx, el) {
        el.inputmask && el.inputmask.remove();
      });
    }, Inputmask.setValue = function (elems, value) {
      'string' == typeof elems && (elems = document.getElementById(elems) || document.querySelectorAll(elems)), elems = elems.nodeName ? [elems] : elems, $.each(elems, function (ndx, el) {
        el.inputmask ? el.inputmask.setValue(value) : $(el).trigger('setvalue', [value]);
      });
    };
    var escapeRegexRegex = new RegExp('(\\' + ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\', '$', '^'].join('|\\') + ')', 'gim');
    Inputmask.escapeRegex = function (str) {
      return str.replace(escapeRegexRegex, '\\$1');
    }, Inputmask.dependencyLib = $, window.Inputmask = Inputmask, module.exports = Inputmask;
  }, function (module, exports, __nested_webpack_require_11116__) {
    'use strict';

    function _typeof(obj) {
      return _typeof = 'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator ? function _typeof(obj) {
        return typeof obj;
      } : function _typeof(obj) {
        return obj && 'function' == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
      }, _typeof(obj);
    }
    var window = __nested_webpack_require_11116__(3),
      document = window.document;
    function indexOf(list, elem) {
      for (var i = 0, len = list.length; i < len; i++) if (list[i] === elem) return i;
      return -1;
    }
    function isWindow(obj) {
      return null != obj && obj === obj.window;
    }
    function isArraylike(obj) {
      var length = 'length' in obj && obj.length,
        ltype = _typeof(obj);
      return 'function' !== ltype && !isWindow(obj) && (!(1 !== obj.nodeType || !length) || 'array' === ltype || 0 === length || 'number' == typeof length && 0 < length && length - 1 in obj);
    }
    function isValidElement(elem) {
      return elem instanceof Element;
    }
    function DependencyLib(elem) {
      return elem instanceof DependencyLib ? elem : this instanceof DependencyLib ? void (null != elem && elem !== window && (this[0] = elem.nodeName ? elem : void 0 !== elem[0] && elem[0].nodeName ? elem[0] : document.querySelector(elem), void 0 !== this[0] && null !== this[0] && (this[0].eventRegistry = this[0].eventRegistry || {}))) : new DependencyLib(elem);
    }
    DependencyLib.prototype = {
      on: function on(events, handler) {
        function addEvent(ev, namespace) {
          elem.addEventListener ? elem.addEventListener(ev, handler, !1) : elem.attachEvent && elem.attachEvent('on' + ev, handler), eventRegistry[ev] = eventRegistry[ev] || {}, eventRegistry[ev][namespace] = eventRegistry[ev][namespace] || [], eventRegistry[ev][namespace].push(handler);
        }
        if (isValidElement(this[0])) for (var eventRegistry = this[0].eventRegistry, elem = this[0], _events = events.split(' '), endx = 0; endx < _events.length; endx++) {
          var nsEvent = _events[endx].split('.'),
            ev = nsEvent[0],
            namespace = nsEvent[1] || 'global';
          addEvent(ev, namespace);
        }
        return this;
      },
      off: function off(events, handler) {
        var eventRegistry, elem;
        function removeEvent(ev, namespace, handler) {
          if (ev in eventRegistry == !0) if (elem.removeEventListener ? elem.removeEventListener(ev, handler, !1) : elem.detachEvent && elem.detachEvent('on' + ev, handler), 'global' === namespace) for (var nmsp in eventRegistry[ev]) eventRegistry[ev][nmsp].splice(eventRegistry[ev][nmsp].indexOf(handler), 1);else eventRegistry[ev][namespace].splice(eventRegistry[ev][namespace].indexOf(handler), 1);
        }
        function resolveNamespace(ev, namespace) {
          var evts = [],
            hndx,
            hndL;
          if (0 < ev.length) {
            if (void 0 === handler) for (hndx = 0, hndL = eventRegistry[ev][namespace].length; hndx < hndL; hndx++) evts.push({
              ev: ev,
              namespace: namespace && 0 < namespace.length ? namespace : 'global',
              handler: eventRegistry[ev][namespace][hndx]
            });else evts.push({
              ev: ev,
              namespace: namespace && 0 < namespace.length ? namespace : 'global',
              handler: handler
            });
          } else if (0 < namespace.length) for (var evNdx in eventRegistry) for (var nmsp in eventRegistry[evNdx]) if (nmsp === namespace) if (void 0 === handler) for (hndx = 0, hndL = eventRegistry[evNdx][nmsp].length; hndx < hndL; hndx++) evts.push({
            ev: evNdx,
            namespace: nmsp,
            handler: eventRegistry[evNdx][nmsp][hndx]
          });else evts.push({
            ev: evNdx,
            namespace: nmsp,
            handler: handler
          });
          return evts;
        }
        if (isValidElement(this[0])) {
          eventRegistry = this[0].eventRegistry, elem = this[0];
          for (var _events = events.split(' '), endx = 0; endx < _events.length; endx++) for (var nsEvent = _events[endx].split('.'), offEvents = resolveNamespace(nsEvent[0], nsEvent[1]), i = 0, offEventsL = offEvents.length; i < offEventsL; i++) removeEvent(offEvents[i].ev, offEvents[i].namespace, offEvents[i].handler);
        }
        return this;
      },
      trigger: function trigger(events, argument_1) {
        if (isValidElement(this[0])) for (var eventRegistry = this[0].eventRegistry, elem = this[0], _events = 'string' == typeof events ? events.split(' ') : [events.type], endx = 0; endx < _events.length; endx++) {
          var nsEvent = _events[endx].split('.'),
            ev = nsEvent[0],
            namespace = nsEvent[1] || 'global';
          if (void 0 !== document && 'global' === namespace) {
            var evnt,
              i,
              params = {
                bubbles: !0,
                cancelable: !0,
                detail: argument_1
              };
            if (document.createEvent) {
              try {
                evnt = new CustomEvent(ev, params);
              } catch (e) {
                evnt = document.createEvent('CustomEvent'), evnt.initCustomEvent(ev, params.bubbles, params.cancelable, params.detail);
              }
              events.type && DependencyLib.extend(evnt, events), elem.dispatchEvent(evnt);
            } else evnt = document.createEventObject(), evnt.eventType = ev, evnt.detail = argument_1, events.type && DependencyLib.extend(evnt, events), elem.fireEvent('on' + evnt.eventType, evnt);
          } else if (void 0 !== eventRegistry[ev]) if (events = events.type ? events : DependencyLib.Event(events), events.detail = arguments.slice(1), 'global' === namespace) for (var nmsp in eventRegistry[ev]) for (i = 0; i < eventRegistry[ev][nmsp].length; i++) eventRegistry[ev][nmsp][i].apply(elem, arguments);else for (i = 0; i < eventRegistry[ev][namespace].length; i++) eventRegistry[ev][namespace][i].apply(elem, arguments);
        }
        return this;
      }
    }, DependencyLib.isFunction = function (obj) {
      return 'function' == typeof obj;
    }, DependencyLib.noop = function () {}, DependencyLib.isArray = Array.isArray, DependencyLib.inArray = function (elem, arr, i) {
      return null == arr ? -1 : indexOf(arr, elem, i);
    }, DependencyLib.valHooks = void 0, DependencyLib.isPlainObject = function (obj) {
      return 'object' === _typeof(obj) && !obj.nodeType && !isWindow(obj) && !(obj.constructor && !Object.hasOwnProperty.call(obj.constructor.prototype, 'isPrototypeOf'));
    }, DependencyLib.extend = function () {
      var options,
        name,
        src,
        copy,
        copyIsArray,
        clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = !1;
      for ('boolean' == typeof target && (deep = target, target = arguments[i] || {}, i++), 'object' === _typeof(target) || DependencyLib.isFunction(target) || (target = {}), i === length && (target = this, i--); i < length; i++) if (null != (options = arguments[i])) for (name in options) src = target[name], copy = options[name], target !== copy && (deep && copy && (DependencyLib.isPlainObject(copy) || (copyIsArray = DependencyLib.isArray(copy))) ? (clone = copyIsArray ? (copyIsArray = !1, src && DependencyLib.isArray(src) ? src : []) : src && DependencyLib.isPlainObject(src) ? src : {}, target[name] = DependencyLib.extend(deep, clone, copy)) : void 0 !== copy && (target[name] = copy));
      return target;
    }, DependencyLib.each = function (obj, callback) {
      var value,
        i = 0;
      if (isArraylike(obj)) for (var length = obj.length; i < length && (value = callback.call(obj[i], i, obj[i]), !1 !== value); i++);else for (i in obj) if (value = callback.call(obj[i], i, obj[i]), !1 === value) break;
      return obj;
    }, DependencyLib.data = function (owner, key, value) {
      if (void 0 === value) return owner.__data ? owner.__data[key] : null;
      owner.__data = owner.__data || {}, owner.__data[key] = value;
    }, 'function' == typeof window.CustomEvent ? DependencyLib.Event = window.CustomEvent : (DependencyLib.Event = function (event, params) {
      params = params || {
        bubbles: !1,
        cancelable: !1,
        detail: void 0
      };
      var evt = document.createEvent('CustomEvent');
      return evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail), evt;
    }, DependencyLib.Event.prototype = window.Event.prototype), module.exports = DependencyLib;
  }, function (module, exports, __nested_webpack_require_19804__) {
    'use strict';

    var __WEBPACK_AMD_DEFINE_RESULT__;
    function _typeof(obj) {
      return _typeof = 'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator ? function _typeof(obj) {
        return typeof obj;
      } : function _typeof(obj) {
        return obj && 'function' == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
      }, _typeof(obj);
    }
    __WEBPACK_AMD_DEFINE_RESULT__ = function () {
      return 'undefined' != typeof window ? window : new (eval("require('jsdom').JSDOM"))('').window;
    }.call(exports, __nested_webpack_require_19804__, exports, module), void 0 === __WEBPACK_AMD_DEFINE_RESULT__ || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
  }, function (module, exports, __nested_webpack_require_20588__) {
    'use strict';

    var $ = __nested_webpack_require_20588__(2);
    function generateMaskSet(opts, nocache) {
      var ms;
      function generateMask(mask, metadata, opts) {
        var regexMask = !1,
          masksetDefinition,
          maskdefKey;
        if (null !== mask && '' !== mask || (regexMask = null !== opts.regex, mask = regexMask ? (mask = opts.regex, mask.replace(/^(\^)(.*)(\$)$/, '$2')) : (regexMask = !0, '.*')), 1 === mask.length && !1 === opts.greedy && 0 !== opts.repeat && (opts.placeholder = ''), 0 < opts.repeat || '*' === opts.repeat || '+' === opts.repeat) {
          var repeatStart = '*' === opts.repeat ? 0 : '+' === opts.repeat ? 1 : opts.repeat;
          mask = opts.groupmarker[0] + mask + opts.groupmarker[1] + opts.quantifiermarker[0] + repeatStart + ',' + opts.repeat + opts.quantifiermarker[1];
        }
        return maskdefKey = regexMask ? 'regex_' + opts.regex : opts.numericInput ? mask.split('').reverse().join('') : mask, !1 !== opts.keepStatic && (maskdefKey = 'ks_' + maskdefKey), void 0 === Inputmask.prototype.masksCache[maskdefKey] || !0 === nocache ? (masksetDefinition = {
          mask: mask,
          maskToken: Inputmask.prototype.analyseMask(mask, regexMask, opts),
          validPositions: {},
          _buffer: void 0,
          buffer: void 0,
          tests: {},
          excludes: {},
          metadata: metadata,
          maskLength: void 0,
          jitOffset: {}
        }, !0 !== nocache && (Inputmask.prototype.masksCache[maskdefKey] = masksetDefinition, masksetDefinition = $.extend(!0, {}, Inputmask.prototype.masksCache[maskdefKey]))) : masksetDefinition = $.extend(!0, {}, Inputmask.prototype.masksCache[maskdefKey]), masksetDefinition;
      }
      if ($.isFunction(opts.mask) && (opts.mask = opts.mask(opts)), $.isArray(opts.mask)) {
        if (1 < opts.mask.length) {
          null === opts.keepStatic && (opts.keepStatic = !0);
          var altMask = opts.groupmarker[0];
          return $.each(opts.isRTL ? opts.mask.reverse() : opts.mask, function (ndx, msk) {
            1 < altMask.length && (altMask += opts.groupmarker[1] + opts.alternatormarker + opts.groupmarker[0]), void 0 === msk.mask || $.isFunction(msk.mask) ? altMask += msk : altMask += msk.mask;
          }), altMask += opts.groupmarker[1], generateMask(altMask, opts.mask, opts);
        }
        opts.mask = opts.mask.pop();
      }
      return null === opts.keepStatic && (opts.keepStatic = !1), ms = opts.mask && void 0 !== opts.mask.mask && !$.isFunction(opts.mask.mask) ? generateMask(opts.mask.mask, opts.mask, opts) : generateMask(opts.mask, opts.mask, opts), ms;
    }
    function analyseMask(mask, regexMask, opts) {
      var tokenizer = /(?:[?*+]|\{[0-9+*]+(?:,[0-9+*]*)?(?:\|[0-9+*]*)?\})|[^.?*+^${[]()|\\]+|./g,
        regexTokenizer = /\[\^?]?(?:[^\\\]]+|\\[\S\s]?)*]?|\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\S\s]?)|\((?:\?[:=!]?)?|(?:[?*+]|\{[0-9]+(?:,[0-9]*)?\})\??|[^.?*+^${[()|\\]+|./g,
        escaped = !1,
        currentToken = new MaskToken(),
        match,
        m,
        openenings = [],
        maskTokens = [],
        openingToken,
        currentOpeningToken,
        alternator,
        lastMatch,
        closeRegexGroup = !1;
      function MaskToken(isGroup, isOptional, isQuantifier, isAlternator) {
        this.matches = [], this.openGroup = isGroup || !1, this.alternatorGroup = !1, this.isGroup = isGroup || !1, this.isOptional = isOptional || !1, this.isQuantifier = isQuantifier || !1, this.isAlternator = isAlternator || !1, this.quantifier = {
          min: 1,
          max: 1
        };
      }
      function insertTestDefinition(mtoken, element, position) {
        position = void 0 !== position ? position : mtoken.matches.length;
        var prevMatch = mtoken.matches[position - 1];
        if (regexMask) 0 === element.indexOf('[') || escaped && /\\d|\\s|\\w]/i.test(element) || '.' === element ? mtoken.matches.splice(position++, 0, {
          fn: new RegExp(element, opts.casing ? 'i' : ''),
          static: !1,
          optionality: !1,
          newBlockMarker: void 0 === prevMatch ? 'master' : prevMatch.def !== element,
          casing: null,
          def: element,
          placeholder: void 0,
          nativeDef: element
        }) : (escaped && (element = element[element.length - 1]), $.each(element.split(''), function (ndx, lmnt) {
          prevMatch = mtoken.matches[position - 1], mtoken.matches.splice(position++, 0, {
            fn: /[a-z]/i.test(opts.staticDefinitionSymbol || lmnt) ? new RegExp('[' + (opts.staticDefinitionSymbol || lmnt) + ']', opts.casing ? 'i' : '') : null,
            static: !0,
            optionality: !1,
            newBlockMarker: void 0 === prevMatch ? 'master' : prevMatch.def !== lmnt && !0 !== prevMatch.static,
            casing: null,
            def: opts.staticDefinitionSymbol || lmnt,
            placeholder: void 0 !== opts.staticDefinitionSymbol ? lmnt : void 0,
            nativeDef: (escaped ? "'" : '') + lmnt
          });
        })), escaped = !1;else {
          var maskdef = (opts.definitions ? opts.definitions[element] : void 0) || Inputmask.prototype.definitions[element];
          maskdef && !escaped ? mtoken.matches.splice(position++, 0, {
            fn: maskdef.validator ? 'string' == typeof maskdef.validator ? new RegExp(maskdef.validator, opts.casing ? 'i' : '') : new function () {
              this.test = maskdef.validator;
            }() : new RegExp('.'),
            static: maskdef.static || !1,
            optionality: !1,
            newBlockMarker: void 0 === prevMatch ? 'master' : prevMatch.def !== (maskdef.definitionSymbol || element),
            casing: maskdef.casing,
            def: maskdef.definitionSymbol || element,
            placeholder: maskdef.placeholder,
            nativeDef: element,
            generated: maskdef.generated
          }) : (mtoken.matches.splice(position++, 0, {
            fn: /[a-z]/i.test(opts.staticDefinitionSymbol || element) ? new RegExp('[' + (opts.staticDefinitionSymbol || element) + ']', opts.casing ? 'i' : '') : null,
            static: !0,
            optionality: !1,
            newBlockMarker: void 0 === prevMatch ? 'master' : prevMatch.def !== element && !0 !== prevMatch.static,
            casing: null,
            def: opts.staticDefinitionSymbol || element,
            placeholder: void 0 !== opts.staticDefinitionSymbol ? element : void 0,
            nativeDef: (escaped ? "'" : '') + element
          }), escaped = !1);
        }
      }
      function verifyGroupMarker(maskToken) {
        maskToken && maskToken.matches && $.each(maskToken.matches, function (ndx, token) {
          var nextToken = maskToken.matches[ndx + 1];
          (void 0 === nextToken || void 0 === nextToken.matches || !1 === nextToken.isQuantifier) && token && token.isGroup && (token.isGroup = !1, regexMask || (insertTestDefinition(token, opts.groupmarker[0], 0), !0 !== token.openGroup && insertTestDefinition(token, opts.groupmarker[1]))), verifyGroupMarker(token);
        });
      }
      function defaultCase() {
        if (0 < openenings.length) {
          if (currentOpeningToken = openenings[openenings.length - 1], insertTestDefinition(currentOpeningToken, m), currentOpeningToken.isAlternator) {
            alternator = openenings.pop();
            for (var mndx = 0; mndx < alternator.matches.length; mndx++) alternator.matches[mndx].isGroup && (alternator.matches[mndx].isGroup = !1);
            0 < openenings.length ? (currentOpeningToken = openenings[openenings.length - 1], currentOpeningToken.matches.push(alternator)) : currentToken.matches.push(alternator);
          }
        } else insertTestDefinition(currentToken, m);
      }
      function reverseTokens(maskToken) {
        function reverseStatic(st) {
          return st === opts.optionalmarker[0] ? st = opts.optionalmarker[1] : st === opts.optionalmarker[1] ? st = opts.optionalmarker[0] : st === opts.groupmarker[0] ? st = opts.groupmarker[1] : st === opts.groupmarker[1] && (st = opts.groupmarker[0]), st;
        }
        for (var match in maskToken.matches = maskToken.matches.reverse(), maskToken.matches) if (Object.prototype.hasOwnProperty.call(maskToken.matches, match)) {
          var intMatch = parseInt(match);
          if (maskToken.matches[match].isQuantifier && maskToken.matches[intMatch + 1] && maskToken.matches[intMatch + 1].isGroup) {
            var qt = maskToken.matches[match];
            maskToken.matches.splice(match, 1), maskToken.matches.splice(intMatch + 1, 0, qt);
          }
          void 0 !== maskToken.matches[match].matches ? maskToken.matches[match] = reverseTokens(maskToken.matches[match]) : maskToken.matches[match] = reverseStatic(maskToken.matches[match]);
        }
        return maskToken;
      }
      function groupify(matches) {
        var groupToken = new MaskToken(!0);
        return groupToken.openGroup = !1, groupToken.matches = matches, groupToken;
      }
      function closeGroup() {
        if (openingToken = openenings.pop(), openingToken.openGroup = !1, void 0 !== openingToken) {
          if (0 < openenings.length) {
            if (currentOpeningToken = openenings[openenings.length - 1], currentOpeningToken.matches.push(openingToken), currentOpeningToken.isAlternator) {
              alternator = openenings.pop();
              for (var mndx = 0; mndx < alternator.matches.length; mndx++) alternator.matches[mndx].isGroup = !1, alternator.matches[mndx].alternatorGroup = !1;
              0 < openenings.length ? (currentOpeningToken = openenings[openenings.length - 1], currentOpeningToken.matches.push(alternator)) : currentToken.matches.push(alternator);
            }
          } else currentToken.matches.push(openingToken);
        } else defaultCase();
      }
      function groupQuantifier(matches) {
        var lastMatch = matches.pop();
        return lastMatch.isQuantifier && (lastMatch = groupify([matches.pop(), lastMatch])), lastMatch;
      }
      for (regexMask && (opts.optionalmarker[0] = void 0, opts.optionalmarker[1] = void 0); match = regexMask ? regexTokenizer.exec(mask) : tokenizer.exec(mask);) {
        if (m = match[0], regexMask) switch (m.charAt(0)) {
          case '?':
            m = '{0,1}';
            break;
          case '+':
          case '*':
            m = '{' + m + '}';
            break;
          case '|':
            if (0 === openenings.length) {
              var altRegexGroup = groupify(currentToken.matches);
              altRegexGroup.openGroup = !0, openenings.push(altRegexGroup), currentToken.matches = [], closeRegexGroup = !0;
            }
            break;
        }
        if (escaped) defaultCase();else switch (m.charAt(0)) {
          case '(?=':
            break;
          case '(?!':
            break;
          case '(?<=':
            break;
          case '(?<!':
            break;
          case opts.escapeChar:
            escaped = !0, regexMask && defaultCase();
            break;
          case opts.optionalmarker[1]:
          case opts.groupmarker[1]:
            closeGroup();
            break;
          case opts.optionalmarker[0]:
            openenings.push(new MaskToken(!1, !0));
            break;
          case opts.groupmarker[0]:
            openenings.push(new MaskToken(!0));
            break;
          case opts.quantifiermarker[0]:
            var quantifier = new MaskToken(!1, !1, !0);
            m = m.replace(/[{}]/g, '');
            var mqj = m.split('|'),
              mq = mqj[0].split(','),
              mq0 = isNaN(mq[0]) ? mq[0] : parseInt(mq[0]),
              mq1 = 1 === mq.length ? mq0 : isNaN(mq[1]) ? mq[1] : parseInt(mq[1]);
            '*' !== mq0 && '+' !== mq0 || (mq0 = '*' === mq1 ? 0 : 1), quantifier.quantifier = {
              min: mq0,
              max: mq1,
              jit: mqj[1]
            };
            var matches = 0 < openenings.length ? openenings[openenings.length - 1].matches : currentToken.matches;
            if (match = matches.pop(), match.isAlternator) {
              matches.push(match), matches = match.matches;
              var groupToken = new MaskToken(!0),
                tmpMatch = matches.pop();
              matches.push(groupToken), matches = groupToken.matches, match = tmpMatch;
            }
            match.isGroup || (match = groupify([match])), matches.push(match), matches.push(quantifier);
            break;
          case opts.alternatormarker:
            if (0 < openenings.length) {
              currentOpeningToken = openenings[openenings.length - 1];
              var subToken = currentOpeningToken.matches[currentOpeningToken.matches.length - 1];
              lastMatch = currentOpeningToken.openGroup && (void 0 === subToken.matches || !1 === subToken.isGroup && !1 === subToken.isAlternator) ? openenings.pop() : groupQuantifier(currentOpeningToken.matches);
            } else lastMatch = groupQuantifier(currentToken.matches);
            if (lastMatch.isAlternator) openenings.push(lastMatch);else if (lastMatch.alternatorGroup ? (alternator = openenings.pop(), lastMatch.alternatorGroup = !1) : alternator = new MaskToken(!1, !1, !1, !0), alternator.matches.push(lastMatch), openenings.push(alternator), lastMatch.openGroup) {
              lastMatch.openGroup = !1;
              var alternatorGroup = new MaskToken(!0);
              alternatorGroup.alternatorGroup = !0, openenings.push(alternatorGroup);
            }
            break;
          default:
            defaultCase();
        }
      }
      for (closeRegexGroup && closeGroup(); 0 < openenings.length;) openingToken = openenings.pop(), currentToken.matches.push(openingToken);
      return 0 < currentToken.matches.length && (verifyGroupMarker(currentToken), maskTokens.push(currentToken)), (opts.numericInput || opts.isRTL) && reverseTokens(maskTokens[0]), maskTokens;
    }
    module.exports = {
      generateMaskSet: generateMaskSet,
      analyseMask: analyseMask
    };
  }, function (module, exports, __nested_webpack_require_34695__) {
    'use strict';

    __nested_webpack_require_34695__(6), __nested_webpack_require_34695__(8), __nested_webpack_require_34695__(9), __nested_webpack_require_34695__(10), module.exports = __nested_webpack_require_34695__(1);
  }, function (module, exports, __nested_webpack_require_34911__) {
    'use strict';

    var Inputmask = __nested_webpack_require_34911__(1);
    Inputmask.extendDefinitions({
      A: {
        validator: '[A-Za-z\u0410-\u044f\u0401\u0451\xc0-\xff\xb5]',
        casing: 'upper'
      },
      '&': {
        validator: '[0-9A-Za-z\u0410-\u044f\u0401\u0451\xc0-\xff\xb5]',
        casing: 'upper'
      },
      '#': {
        validator: '[0-9A-Fa-f]',
        casing: 'upper'
      }
    });
    var ipValidatorRegex = new RegExp('25[0-5]|2[0-4][0-9]|[01][0-9][0-9]');
    function ipValidator(chrs, maskset, pos, strict, opts) {
      return chrs = -1 < pos - 1 && '.' !== maskset.buffer[pos - 1] ? (chrs = maskset.buffer[pos - 1] + chrs, -1 < pos - 2 && '.' !== maskset.buffer[pos - 2] ? maskset.buffer[pos - 2] + chrs : '0' + chrs) : '00' + chrs, ipValidatorRegex.test(chrs);
    }
    Inputmask.extendAliases({
      cssunit: {
        regex: '[+-]?[0-9]+\\.?([0-9]+)?(px|em|rem|ex|%|in|cm|mm|pt|pc)'
      },
      url: {
        regex: '(https?|ftp)//.*',
        autoUnmask: !1
      },
      ip: {
        mask: 'i[i[i]].j[j[j]].k[k[k]].l[l[l]]',
        definitions: {
          i: {
            validator: ipValidator
          },
          j: {
            validator: ipValidator
          },
          k: {
            validator: ipValidator
          },
          l: {
            validator: ipValidator
          }
        },
        onUnMask: function onUnMask(maskedValue, unmaskedValue, opts) {
          return maskedValue;
        },
        inputmode: 'numeric'
      },
      email: {
        mask: '*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]',
        greedy: !1,
        casing: 'lower',
        onBeforePaste: function onBeforePaste(pastedValue, opts) {
          return pastedValue = pastedValue.toLowerCase(), pastedValue.replace('mailto:', '');
        },
        definitions: {
          '*': {
            validator: "[0-9\uff11-\uff19A-Za-z\u0410-\u044f\u0401\u0451\xc0-\xff\xb5!#$%&'*+/=?^_`{|}~-]"
          },
          '-': {
            validator: '[0-9A-Za-z-]'
          }
        },
        onUnMask: function onUnMask(maskedValue, unmaskedValue, opts) {
          return maskedValue;
        },
        inputmode: 'email'
      },
      mac: {
        mask: '##:##:##:##:##:##'
      },
      vin: {
        mask: 'V{13}9{4}',
        definitions: {
          V: {
            validator: '[A-HJ-NPR-Za-hj-npr-z\\d]',
            casing: 'upper'
          }
        },
        clearIncomplete: !0,
        autoUnmask: !0
      },
      ssn: {
        mask: '999-99-9999',
        postValidation: function postValidation(buffer, pos, c, currentResult, opts, maskset, strict) {
          return /^(?!219-09-9999|078-05-1120)(?!666|000|9.{2}).{3}-(?!00).{2}-(?!0{4}).{4}$/.test(buffer.join(''));
        }
      }
    }), module.exports = Inputmask;
  }, function (module, exports, __nested_webpack_require_37805__) {
    'use strict';

    function _typeof(obj) {
      return _typeof = 'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator ? function _typeof(obj) {
        return typeof obj;
      } : function _typeof(obj) {
        return obj && 'function' == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
      }, _typeof(obj);
    }
    var $ = __nested_webpack_require_37805__(2),
      window = __nested_webpack_require_37805__(3),
      document = window.document,
      ua = window.navigator && window.navigator.userAgent || '',
      ie = 0 < ua.indexOf('MSIE ') || 0 < ua.indexOf('Trident/'),
      mobile = ('ontouchstart' in window),
      iemobile = /iemobile/i.test(ua),
      iphone = /iphone/i.test(ua) && !iemobile,
      keyCode = __nested_webpack_require_37805__(0);
    module.exports = function maskScope(actionObj, maskset, opts) {
      maskset = maskset || this.maskset, opts = opts || this.opts;
      var inputmask = this,
        el = this.el,
        isRTL = this.isRTL || (this.isRTL = opts.numericInput),
        undoValue,
        $el,
        skipKeyPressEvent = !1,
        skipInputEvent = !1,
        validationEvent = !1,
        ignorable = !1,
        maxLength,
        mouseEnter = !1,
        originalPlaceholder = void 0;
      function getMaskTemplate(baseOnInput, minimalPos, includeMode, noJit, clearOptionalTail) {
        var greedy = opts.greedy;
        clearOptionalTail && (opts.greedy = !1), minimalPos = minimalPos || 0;
        var maskTemplate = [],
          ndxIntlzr,
          pos = 0,
          test,
          testPos,
          jitRenderStatic;
        do {
          if (!0 === baseOnInput && maskset.validPositions[pos]) testPos = clearOptionalTail && !0 === maskset.validPositions[pos].match.optionality && void 0 === maskset.validPositions[pos + 1] && (!0 === maskset.validPositions[pos].generatedInput || maskset.validPositions[pos].input == opts.skipOptionalPartCharacter && 0 < pos) ? determineTestTemplate(pos, getTests(pos, ndxIntlzr, pos - 1)) : maskset.validPositions[pos], test = testPos.match, ndxIntlzr = testPos.locator.slice(), maskTemplate.push(!0 === includeMode ? testPos.input : !1 === includeMode ? test.nativeDef : getPlaceholder(pos, test));else {
            testPos = getTestTemplate(pos, ndxIntlzr, pos - 1), test = testPos.match, ndxIntlzr = testPos.locator.slice();
            var jitMasking = !0 !== noJit && (!1 !== opts.jitMasking ? opts.jitMasking : test.jit);
            jitRenderStatic = jitRenderStatic && test.static && test.def !== opts.groupSeparator && null === test.fn || maskset.validPositions[pos - 1] && test.static && test.def !== opts.groupSeparator && null === test.fn, jitRenderStatic || !1 === jitMasking || void 0 === jitMasking || 'number' == typeof jitMasking && isFinite(jitMasking) && pos < jitMasking ? maskTemplate.push(!1 === includeMode ? test.nativeDef : getPlaceholder(pos, test)) : jitRenderStatic = !1;
          }
          pos++;
        } while ((void 0 === maxLength || pos < maxLength) && (!0 !== test.static || '' !== test.def) || pos < minimalPos);
        return '' === maskTemplate[maskTemplate.length - 1] && maskTemplate.pop(), !1 === includeMode && void 0 !== maskset.maskLength || (maskset.maskLength = pos - 1), opts.greedy = greedy, maskTemplate;
      }
      function resetMaskSet(soft) {
        maskset.buffer = void 0, !0 !== soft && (maskset.validPositions = {}, maskset.p = 0);
      }
      function getLastValidPosition(closestTo, strict, validPositions) {
        var before = -1,
          after = -1,
          valids = validPositions || maskset.validPositions;
        for (var posNdx in void 0 === closestTo && (closestTo = -1), valids) {
          var psNdx = parseInt(posNdx);
          valids[psNdx] && (strict || !0 !== valids[psNdx].generatedInput) && (psNdx <= closestTo && (before = psNdx), closestTo <= psNdx && (after = psNdx));
        }
        return -1 === before || before == closestTo ? after : -1 == after ? before : closestTo - before < after - closestTo ? before : after;
      }
      function getDecisionTaker(tst) {
        var decisionTaker = tst.locator[tst.alternation];
        return 'string' == typeof decisionTaker && 0 < decisionTaker.length && (decisionTaker = decisionTaker.split(',')[0]), void 0 !== decisionTaker ? decisionTaker.toString() : '';
      }
      function getLocator(tst, align) {
        var locator = (null != tst.alternation ? tst.mloc[getDecisionTaker(tst)] : tst.locator).join('');
        if ('' !== locator) for (; locator.length < align;) locator += '0';
        return locator;
      }
      function determineTestTemplate(pos, tests) {
        pos = 0 < pos ? pos - 1 : 0;
        for (var altTest = getTest(pos), targetLocator = getLocator(altTest), tstLocator, closest, bestMatch, ndx = 0; ndx < tests.length; ndx++) {
          var tst = tests[ndx];
          tstLocator = getLocator(tst, targetLocator.length);
          var distance = Math.abs(tstLocator - targetLocator);
          (void 0 === closest || '' !== tstLocator && distance < closest || bestMatch && !opts.greedy && bestMatch.match.optionality && 'master' === bestMatch.match.newBlockMarker && (!tst.match.optionality || !tst.match.newBlockMarker) || bestMatch && bestMatch.match.optionalQuantifier && !tst.match.optionalQuantifier) && (closest = distance, bestMatch = tst);
        }
        return bestMatch;
      }
      function getTestTemplate(pos, ndxIntlzr, tstPs) {
        return maskset.validPositions[pos] || determineTestTemplate(pos, getTests(pos, ndxIntlzr ? ndxIntlzr.slice() : ndxIntlzr, tstPs));
      }
      function getTest(pos, tests) {
        return maskset.validPositions[pos] ? maskset.validPositions[pos] : (tests || getTests(pos))[0];
      }
      function positionCanMatchDefinition(pos, testDefinition, opts) {
        for (var valid = !1, tests = getTests(pos), tndx = 0; tndx < tests.length; tndx++) {
          if (tests[tndx].match && (!(tests[tndx].match.nativeDef !== testDefinition.match[opts.shiftPositions ? 'def' : 'nativeDef'] || opts.shiftPositions && testDefinition.match.static) || tests[tndx].match.nativeDef === testDefinition.match.nativeDef)) {
            valid = !0;
            break;
          }
          if (tests[tndx].match && tests[tndx].match.def === testDefinition.match.nativeDef) {
            valid = void 0;
            break;
          }
        }
        return !1 === valid && void 0 !== maskset.jitOffset[pos] && (valid = positionCanMatchDefinition(pos + maskset.jitOffset[pos], testDefinition, opts)), valid;
      }
      function getTests(pos, ndxIntlzr, tstPs) {
        var maskTokens = maskset.maskToken,
          testPos = ndxIntlzr ? tstPs : 0,
          ndxInitializer = ndxIntlzr ? ndxIntlzr.slice() : [0],
          matches = [],
          insertStop = !1,
          latestMatch,
          cacheDependency = ndxIntlzr ? ndxIntlzr.join('') : '';
        function resolveTestFromToken(maskToken, ndxInitializer, loopNdx, quantifierRecurse) {
          function handleMatch(match, loopNdx, quantifierRecurse) {
            function isFirstMatch(latestMatch, tokenGroup) {
              var firstMatch = 0 === $.inArray(latestMatch, tokenGroup.matches);
              return firstMatch || $.each(tokenGroup.matches, function (ndx, match) {
                if (!0 === match.isQuantifier ? firstMatch = isFirstMatch(latestMatch, tokenGroup.matches[ndx - 1]) : Object.prototype.hasOwnProperty.call(match, 'matches') && (firstMatch = isFirstMatch(latestMatch, match)), firstMatch) return !1;
              }), firstMatch;
            }
            function resolveNdxInitializer(pos, alternateNdx, targetAlternation) {
              var bestMatch, indexPos;
              if ((maskset.tests[pos] || maskset.validPositions[pos]) && $.each(maskset.tests[pos] || [maskset.validPositions[pos]], function (ndx, lmnt) {
                if (lmnt.mloc[alternateNdx]) return bestMatch = lmnt, !1;
                var alternation = void 0 !== targetAlternation ? targetAlternation : lmnt.alternation,
                  ndxPos = void 0 !== lmnt.locator[alternation] ? lmnt.locator[alternation].toString().indexOf(alternateNdx) : -1;
                (void 0 === indexPos || ndxPos < indexPos) && -1 !== ndxPos && (bestMatch = lmnt, indexPos = ndxPos);
              }), bestMatch) {
                var bestMatchAltIndex = bestMatch.locator[bestMatch.alternation],
                  locator = bestMatch.mloc[alternateNdx] || bestMatch.mloc[bestMatchAltIndex] || bestMatch.locator;
                return locator.slice((void 0 !== targetAlternation ? targetAlternation : bestMatch.alternation) + 1);
              }
              return void 0 !== targetAlternation ? resolveNdxInitializer(pos, alternateNdx) : void 0;
            }
            function isSubsetOf(source, target) {
              function expand(pattern) {
                for (var expanded = [], start = -1, end, i = 0, l = pattern.length; i < l; i++) if ('-' === pattern.charAt(i)) for (end = pattern.charCodeAt(i + 1); ++start < end;) expanded.push(String.fromCharCode(start));else start = pattern.charCodeAt(i), expanded.push(pattern.charAt(i));
                return expanded.join('');
              }
              return source.match.def === target.match.nativeDef || !(!(opts.regex || source.match.fn instanceof RegExp && target.match.fn instanceof RegExp) || !0 === source.match.static || !0 === target.match.static) && -1 !== expand(target.match.fn.toString().replace(/[[\]/]/g, '')).indexOf(expand(source.match.fn.toString().replace(/[[\]/]/g, '')));
            }
            function staticCanMatchDefinition(source, target) {
              return !0 === source.match.static && !0 !== target.match.static && target.match.fn.test(source.match.def, maskset, pos, !1, opts, !1);
            }
            function setMergeLocators(targetMatch, altMatch) {
              var alternationNdx = targetMatch.alternation,
                shouldMerge = void 0 === altMatch || alternationNdx === altMatch.alternation && -1 === targetMatch.locator[alternationNdx].toString().indexOf(altMatch.locator[alternationNdx]);
              if (!shouldMerge && alternationNdx > altMatch.alternation) for (var i = altMatch.alternation; i < alternationNdx; i++) if (targetMatch.locator[i] !== altMatch.locator[i]) {
                alternationNdx = i, shouldMerge = !0;
                break;
              }
              if (shouldMerge) {
                targetMatch.mloc = targetMatch.mloc || {};
                var locNdx = targetMatch.locator[alternationNdx];
                if (void 0 !== locNdx) {
                  if ('string' == typeof locNdx && (locNdx = locNdx.split(',')[0]), void 0 === targetMatch.mloc[locNdx] && (targetMatch.mloc[locNdx] = targetMatch.locator.slice()), void 0 !== altMatch) {
                    for (var ndx in altMatch.mloc) 'string' == typeof ndx && (ndx = ndx.split(',')[0]), void 0 === targetMatch.mloc[ndx] && (targetMatch.mloc[ndx] = altMatch.mloc[ndx]);
                    targetMatch.locator[alternationNdx] = Object.keys(targetMatch.mloc).join(',');
                  }
                  return !0;
                }
                targetMatch.alternation = void 0;
              }
              return !1;
            }
            if (testPos > opts._maxTestPos && void 0 !== quantifierRecurse) throw 'Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. ' + maskset.mask;
            if (testPos === pos && void 0 === match.matches) return matches.push({
              match: match,
              locator: loopNdx.reverse(),
              cd: cacheDependency,
              mloc: {}
            }), !0;
            if (void 0 !== match.matches) {
              if (match.isGroup && quantifierRecurse !== match) {
                if (match = handleMatch(maskToken.matches[$.inArray(match, maskToken.matches) + 1], loopNdx, quantifierRecurse), match) return !0;
              } else if (match.isOptional) {
                var optionalToken = match,
                  mtchsNdx = matches.length;
                if (match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse), match) {
                  if ($.each(matches, function (ndx, mtch) {
                    mtchsNdx <= ndx && (mtch.match.optionality = !0);
                  }), latestMatch = matches[matches.length - 1].match, void 0 !== quantifierRecurse || !isFirstMatch(latestMatch, optionalToken)) return !0;
                  insertStop = !0, testPos = pos;
                }
              } else if (match.isAlternator) {
                var alternateToken = match,
                  malternateMatches = [],
                  maltMatches,
                  currentMatches = matches.slice(),
                  loopNdxCnt = loopNdx.length,
                  altIndex = 0 < ndxInitializer.length ? ndxInitializer.shift() : -1;
                if (-1 === altIndex || 'string' == typeof altIndex) {
                  var currentPos = testPos,
                    ndxInitializerClone = ndxInitializer.slice(),
                    altIndexArr = [],
                    amndx;
                  if ('string' == typeof altIndex) altIndexArr = altIndex.split(',');else for (amndx = 0; amndx < alternateToken.matches.length; amndx++) altIndexArr.push(amndx.toString());
                  if (void 0 !== maskset.excludes[pos]) {
                    for (var altIndexArrClone = altIndexArr.slice(), i = 0, el = maskset.excludes[pos].length; i < el; i++) {
                      var excludeSet = maskset.excludes[pos][i].toString().split(':');
                      loopNdx.length == excludeSet[1] && altIndexArr.splice(altIndexArr.indexOf(excludeSet[0]), 1);
                    }
                    0 === altIndexArr.length && (delete maskset.excludes[pos], altIndexArr = altIndexArrClone);
                  }
                  (!0 === opts.keepStatic || isFinite(parseInt(opts.keepStatic)) && currentPos >= opts.keepStatic) && (altIndexArr = altIndexArr.slice(0, 1));
                  for (var unMatchedAlternation = !1, ndx = 0; ndx < altIndexArr.length; ndx++) {
                    amndx = parseInt(altIndexArr[ndx]), matches = [], ndxInitializer = 'string' == typeof altIndex && resolveNdxInitializer(testPos, amndx, loopNdxCnt) || ndxInitializerClone.slice(), alternateToken.matches[amndx] && handleMatch(alternateToken.matches[amndx], [amndx].concat(loopNdx), quantifierRecurse) ? match = !0 : 0 === ndx && (unMatchedAlternation = !0), maltMatches = matches.slice(), testPos = currentPos, matches = [];
                    for (var ndx1 = 0; ndx1 < maltMatches.length; ndx1++) {
                      var altMatch = maltMatches[ndx1],
                        dropMatch = !1;
                      altMatch.match.jit = altMatch.match.jit || unMatchedAlternation, altMatch.alternation = altMatch.alternation || loopNdxCnt, setMergeLocators(altMatch);
                      for (var ndx2 = 0; ndx2 < malternateMatches.length; ndx2++) {
                        var altMatch2 = malternateMatches[ndx2];
                        if ('string' != typeof altIndex || void 0 !== altMatch.alternation && -1 !== $.inArray(altMatch.locator[altMatch.alternation].toString(), altIndexArr)) {
                          if (altMatch.match.nativeDef === altMatch2.match.nativeDef) {
                            dropMatch = !0, setMergeLocators(altMatch2, altMatch);
                            break;
                          }
                          if (isSubsetOf(altMatch, altMatch2)) {
                            setMergeLocators(altMatch, altMatch2) && (dropMatch = !0, malternateMatches.splice(malternateMatches.indexOf(altMatch2), 0, altMatch));
                            break;
                          }
                          if (isSubsetOf(altMatch2, altMatch)) {
                            setMergeLocators(altMatch2, altMatch);
                            break;
                          }
                          if (staticCanMatchDefinition(altMatch, altMatch2)) {
                            setMergeLocators(altMatch, altMatch2) && (dropMatch = !0, malternateMatches.splice(malternateMatches.indexOf(altMatch2), 0, altMatch));
                            break;
                          }
                        }
                      }
                      dropMatch || malternateMatches.push(altMatch);
                    }
                  }
                  matches = currentMatches.concat(malternateMatches), testPos = pos, insertStop = 0 < matches.length, match = 0 < malternateMatches.length, ndxInitializer = ndxInitializerClone.slice();
                } else match = handleMatch(alternateToken.matches[altIndex] || maskToken.matches[altIndex], [altIndex].concat(loopNdx), quantifierRecurse);
                if (match) return !0;
              } else if (match.isQuantifier && quantifierRecurse !== maskToken.matches[$.inArray(match, maskToken.matches) - 1]) for (var qt = match, qndx = 0 < ndxInitializer.length ? ndxInitializer.shift() : 0; qndx < (isNaN(qt.quantifier.max) ? qndx + 1 : qt.quantifier.max) && testPos <= pos; qndx++) {
                var tokenGroup = maskToken.matches[$.inArray(qt, maskToken.matches) - 1];
                if (match = handleMatch(tokenGroup, [qndx].concat(loopNdx), tokenGroup), match) {
                  if (latestMatch = matches[matches.length - 1].match, latestMatch.optionalQuantifier = qndx >= qt.quantifier.min, latestMatch.jit = (qndx || 1) * tokenGroup.matches.indexOf(latestMatch) >= qt.quantifier.jit, latestMatch.optionalQuantifier && isFirstMatch(latestMatch, tokenGroup)) {
                    insertStop = !0, testPos = pos;
                    break;
                  }
                  return latestMatch.jit && (maskset.jitOffset[pos] = tokenGroup.matches.length - tokenGroup.matches.indexOf(latestMatch)), !0;
                }
              } else if (match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse), match) return !0;
            } else testPos++;
          }
          for (var tndx = 0 < ndxInitializer.length ? ndxInitializer.shift() : 0; tndx < maskToken.matches.length; tndx++) if (!0 !== maskToken.matches[tndx].isQuantifier) {
            var match = handleMatch(maskToken.matches[tndx], [tndx].concat(loopNdx), quantifierRecurse);
            if (match && testPos === pos) return match;
            if (pos < testPos) break;
          }
        }
        function mergeLocators(pos, tests) {
          var locator = [];
          return $.isArray(tests) || (tests = [tests]), 0 < tests.length && (void 0 === tests[0].alternation || !0 === opts.keepStatic ? (locator = determineTestTemplate(pos, tests.slice()).locator.slice(), 0 === locator.length && (locator = tests[0].locator.slice())) : $.each(tests, function (ndx, tst) {
            if ('' !== tst.def) if (0 === locator.length) locator = tst.locator.slice();else for (var i = 0; i < locator.length; i++) tst.locator[i] && -1 === locator[i].toString().indexOf(tst.locator[i]) && (locator[i] += ',' + tst.locator[i]);
          })), locator;
        }
        if (-1 < pos && (void 0 === maxLength || pos < maxLength)) {
          if (void 0 === ndxIntlzr) {
            for (var previousPos = pos - 1, test; void 0 === (test = maskset.validPositions[previousPos] || maskset.tests[previousPos]) && -1 < previousPos;) previousPos--;
            void 0 !== test && -1 < previousPos && (ndxInitializer = mergeLocators(previousPos, test), cacheDependency = ndxInitializer.join(''), testPos = previousPos);
          }
          if (maskset.tests[pos] && maskset.tests[pos][0].cd === cacheDependency) return maskset.tests[pos];
          for (var mtndx = ndxInitializer.shift(); mtndx < maskTokens.length; mtndx++) {
            var match = resolveTestFromToken(maskTokens[mtndx], ndxInitializer, [mtndx]);
            if (match && testPos === pos || pos < testPos) break;
          }
        }
        return 0 !== matches.length && !insertStop || matches.push({
          match: {
            fn: null,
            static: !0,
            optionality: !1,
            casing: null,
            def: '',
            placeholder: ''
          },
          locator: [],
          mloc: {},
          cd: cacheDependency
        }), void 0 !== ndxIntlzr && maskset.tests[pos] ? $.extend(!0, [], matches) : (maskset.tests[pos] = $.extend(!0, [], matches), maskset.tests[pos]);
      }
      function getBufferTemplate() {
        return void 0 === maskset._buffer && (maskset._buffer = getMaskTemplate(!1, 1), void 0 === maskset.buffer && (maskset.buffer = maskset._buffer.slice())), maskset._buffer;
      }
      function getBuffer(noCache) {
        return void 0 !== maskset.buffer && !0 !== noCache || (maskset.buffer = getMaskTemplate(!0, getLastValidPosition(), !0), void 0 === maskset._buffer && (maskset._buffer = maskset.buffer.slice())), maskset.buffer;
      }
      function refreshFromBuffer(start, end, buffer) {
        var i,
          p,
          skipOptionalPartCharacter = opts.skipOptionalPartCharacter,
          bffr = isRTL ? buffer.slice().reverse() : buffer;
        if (opts.skipOptionalPartCharacter = '', !0 === start) resetMaskSet(), maskset.tests = {}, start = 0, end = buffer.length, p = determineNewCaretPosition({
          begin: 0,
          end: 0
        }, !1).begin;else {
          for (i = start; i < end; i++) delete maskset.validPositions[i];
          p = start;
        }
        var keypress = new $.Event('keypress');
        for (i = start; i < end; i++) {
          keypress.which = bffr[i].toString().charCodeAt(0), ignorable = !1;
          var valResult = EventHandlers.keypressEvent.call(el, keypress, !0, !1, !1, p);
          !1 !== valResult && (p = valResult.forwardPosition);
        }
        opts.skipOptionalPartCharacter = skipOptionalPartCharacter;
      }
      function casing(elem, test, pos) {
        switch (opts.casing || test.casing) {
          case 'upper':
            elem = elem.toUpperCase();
            break;
          case 'lower':
            elem = elem.toLowerCase();
            break;
          case 'title':
            var posBefore = maskset.validPositions[pos - 1];
            elem = 0 === pos || posBefore && posBefore.input === String.fromCharCode(keyCode.SPACE) ? elem.toUpperCase() : elem.toLowerCase();
            break;
          default:
            if ($.isFunction(opts.casing)) {
              var args = Array.prototype.slice.call(arguments);
              args.push(maskset.validPositions), elem = opts.casing.apply(this, args);
            }
        }
        return elem;
      }
      function checkAlternationMatch(altArr1, altArr2, na) {
        for (var altArrC = opts.greedy ? altArr2 : altArr2.slice(0, 1), isMatch = !1, naArr = void 0 !== na ? na.split(',') : [], naNdx, i = 0; i < naArr.length; i++) -1 !== (naNdx = altArr1.indexOf(naArr[i])) && altArr1.splice(naNdx, 1);
        for (var alndx = 0; alndx < altArr1.length; alndx++) if (-1 !== $.inArray(altArr1[alndx], altArrC)) {
          isMatch = !0;
          break;
        }
        return isMatch;
      }
      function alternate(maskPos, c, strict, fromIsValid, rAltPos, selection) {
        var validPsClone = $.extend(!0, {}, maskset.validPositions),
          tstClone = $.extend(!0, {}, maskset.tests),
          lastAlt,
          alternation,
          isValidRslt = !1,
          returnRslt = !1,
          altPos,
          prevAltPos,
          i,
          validPos,
          decisionPos,
          lAltPos = void 0 !== rAltPos ? rAltPos : getLastValidPosition(),
          nextPos,
          input,
          begin,
          end;
        if (selection && (begin = selection.begin, end = selection.end, selection.begin > selection.end && (begin = selection.end, end = selection.begin)), -1 === lAltPos && void 0 === rAltPos) lastAlt = 0, prevAltPos = getTest(lastAlt), alternation = prevAltPos.alternation;else for (; 0 <= lAltPos; lAltPos--) if (altPos = maskset.validPositions[lAltPos], altPos && void 0 !== altPos.alternation) {
          if (prevAltPos && prevAltPos.locator[altPos.alternation] !== altPos.locator[altPos.alternation]) break;
          lastAlt = lAltPos, alternation = maskset.validPositions[lastAlt].alternation, prevAltPos = altPos;
        }
        if (void 0 !== alternation) {
          decisionPos = parseInt(lastAlt), maskset.excludes[decisionPos] = maskset.excludes[decisionPos] || [], !0 !== maskPos && maskset.excludes[decisionPos].push(getDecisionTaker(prevAltPos) + ':' + prevAltPos.alternation);
          var validInputs = [],
            resultPos = -1;
          for (i = decisionPos; i < getLastValidPosition(void 0, !0) + 1; i++) -1 === resultPos && maskPos <= i && void 0 !== c && (validInputs.push(c), resultPos = validInputs.length - 1), validPos = maskset.validPositions[i], validPos && !0 !== validPos.generatedInput && (void 0 === selection || i < begin || end <= i) && validInputs.push(validPos.input), delete maskset.validPositions[i];
          for (-1 === resultPos && void 0 !== c && (validInputs.push(c), resultPos = validInputs.length - 1); void 0 !== maskset.excludes[decisionPos] && maskset.excludes[decisionPos].length < 10;) {
            for (maskset.tests = {}, resetMaskSet(!0), isValidRslt = !0, i = 0; i < validInputs.length && (nextPos = isValidRslt.caret || getLastValidPosition(void 0, !0) + 1, input = validInputs[i], isValidRslt = isValid(nextPos, input, !1, fromIsValid, !0)); i++) i === resultPos && (returnRslt = isValidRslt), 1 == maskPos && isValidRslt && (returnRslt = {
              caretPos: i
            });
            if (isValidRslt) break;
            if (resetMaskSet(), prevAltPos = getTest(decisionPos), maskset.validPositions = $.extend(!0, {}, validPsClone), maskset.tests = $.extend(!0, {}, tstClone), !maskset.excludes[decisionPos]) {
              returnRslt = alternate(maskPos, c, strict, fromIsValid, decisionPos - 1, selection);
              break;
            }
            var decisionTaker = getDecisionTaker(prevAltPos);
            if (-1 !== maskset.excludes[decisionPos].indexOf(decisionTaker + ':' + prevAltPos.alternation)) {
              returnRslt = alternate(maskPos, c, strict, fromIsValid, decisionPos - 1, selection);
              break;
            }
            for (maskset.excludes[decisionPos].push(decisionTaker + ':' + prevAltPos.alternation), i = decisionPos; i < getLastValidPosition(void 0, !0) + 1; i++) delete maskset.validPositions[i];
          }
        }
        return returnRslt && !1 === opts.keepStatic || delete maskset.excludes[decisionPos], returnRslt;
      }
      function isValid(pos, c, strict, fromIsValid, fromAlternate, validateOnly) {
        function isSelection(posObj) {
          return isRTL ? 1 < posObj.begin - posObj.end || posObj.begin - posObj.end == 1 : 1 < posObj.end - posObj.begin || posObj.end - posObj.begin == 1;
        }
        strict = !0 === strict;
        var maskPos = pos;
        function processCommandObject(commandObj) {
          if (void 0 !== commandObj) {
            if (void 0 !== commandObj.remove && ($.isArray(commandObj.remove) || (commandObj.remove = [commandObj.remove]), $.each(commandObj.remove.sort(function (a, b) {
              return b.pos - a.pos;
            }), function (ndx, lmnt) {
              revalidateMask({
                begin: lmnt,
                end: lmnt + 1
              });
            }), commandObj.remove = void 0), void 0 !== commandObj.insert && ($.isArray(commandObj.insert) || (commandObj.insert = [commandObj.insert]), $.each(commandObj.insert.sort(function (a, b) {
              return a.pos - b.pos;
            }), function (ndx, lmnt) {
              '' !== lmnt.c && isValid(lmnt.pos, lmnt.c, void 0 === lmnt.strict || lmnt.strict, void 0 !== lmnt.fromIsValid ? lmnt.fromIsValid : fromIsValid);
            }), commandObj.insert = void 0), commandObj.refreshFromBuffer && commandObj.buffer) {
              var refresh = commandObj.refreshFromBuffer;
              refreshFromBuffer(!0 === refresh ? refresh : refresh.start, refresh.end, commandObj.buffer), commandObj.refreshFromBuffer = void 0;
            }
            void 0 !== commandObj.rewritePosition && (maskPos = commandObj.rewritePosition, commandObj = !0);
          }
          return commandObj;
        }
        function _isValid(position, c, strict) {
          var rslt = !1;
          return $.each(getTests(position), function (ndx, tst) {
            var test = tst.match;
            if (getBuffer(!0), rslt = null != test.fn ? test.fn.test(c, maskset, position, strict, opts, isSelection(pos)) : (c === test.def || c === opts.skipOptionalPartCharacter) && '' !== test.def && {
              c: getPlaceholder(position, test, !0) || test.def,
              pos: position
            }, !1 !== rslt) {
              var elem = void 0 !== rslt.c ? rslt.c : c,
                validatedPos = position;
              return elem = elem === opts.skipOptionalPartCharacter && !0 === test.static ? getPlaceholder(position, test, !0) || test.def : elem, rslt = processCommandObject(rslt), !0 !== rslt && void 0 !== rslt.pos && rslt.pos !== position && (validatedPos = rslt.pos), !0 !== rslt && void 0 === rslt.pos && void 0 === rslt.c ? !1 : (!1 === revalidateMask(pos, $.extend({}, tst, {
                input: casing(elem, test, validatedPos)
              }), fromIsValid, validatedPos) && (rslt = !1), !1);
            }
          }), rslt;
        }
        void 0 !== pos.begin && (maskPos = isRTL ? pos.end : pos.begin);
        var result = !0,
          positionsClone = $.extend(!0, {}, maskset.validPositions);
        if (!1 === opts.keepStatic && void 0 !== maskset.excludes[maskPos] && !0 !== fromAlternate && !0 !== fromIsValid) for (var i = maskPos; i < (isRTL ? pos.begin : pos.end); i++) void 0 !== maskset.excludes[i] && (maskset.excludes[i] = void 0, delete maskset.tests[i]);
        if ($.isFunction(opts.preValidation) && !0 !== fromIsValid && !0 !== validateOnly && (result = opts.preValidation.call(el, getBuffer(), maskPos, c, isSelection(pos), opts, maskset, pos, strict || fromAlternate), result = processCommandObject(result)), !0 === result) {
          if (void 0 === maxLength || maskPos < maxLength) {
            if (result = _isValid(maskPos, c, strict), (!strict || !0 === fromIsValid) && !1 === result && !0 !== validateOnly) {
              var currentPosValid = maskset.validPositions[maskPos];
              if (!currentPosValid || !0 !== currentPosValid.match.static || currentPosValid.match.def !== c && c !== opts.skipOptionalPartCharacter) {
                if (opts.insertMode || void 0 === maskset.validPositions[seekNext(maskPos)] || pos.end > maskPos) {
                  var skip = !1;
                  if (maskset.jitOffset[maskPos] && void 0 === maskset.validPositions[seekNext(maskPos)] && (result = isValid(maskPos + maskset.jitOffset[maskPos], c, !0), !1 !== result && (!0 !== fromAlternate && (result.caret = maskPos), skip = !0)), pos.end > maskPos && (maskset.validPositions[maskPos] = void 0), !skip && !isMask(maskPos, opts.keepStatic)) for (var nPos = maskPos + 1, snPos = seekNext(maskPos); nPos <= snPos; nPos++) if (result = _isValid(nPos, c, strict), !1 !== result) {
                    result = trackbackPositions(maskPos, void 0 !== result.pos ? result.pos : nPos) || result, maskPos = nPos;
                    break;
                  }
                }
              } else result = {
                caret: seekNext(maskPos)
              };
            }
          } else result = !1;
          !1 !== result || !opts.keepStatic || !isComplete(getBuffer()) && 0 !== maskPos || strict || !0 === fromAlternate ? isSelection(pos) && maskset.tests[maskPos] && 1 < maskset.tests[maskPos].length && opts.keepStatic && !strict && !0 !== fromAlternate && (result = alternate(!0)) : result = alternate(maskPos, c, strict, fromIsValid, void 0, pos), !0 === result && (result = {
            pos: maskPos
          });
        }
        if ($.isFunction(opts.postValidation) && !0 !== fromIsValid && !0 !== validateOnly) {
          var postResult = opts.postValidation.call(el, getBuffer(!0), void 0 !== pos.begin ? isRTL ? pos.end : pos.begin : pos, c, result, opts, maskset, strict);
          void 0 !== postResult && (result = !0 === postResult ? result : postResult);
        }
        result && void 0 === result.pos && (result.pos = maskPos), !1 === result || !0 === validateOnly ? (resetMaskSet(!0), maskset.validPositions = $.extend(!0, {}, positionsClone)) : trackbackPositions(void 0, maskPos, !0);
        var endResult = processCommandObject(result);
        return endResult;
      }
      function trackbackPositions(originalPos, newPos, fillOnly) {
        if (void 0 === originalPos) for (originalPos = newPos - 1; 0 < originalPos && !maskset.validPositions[originalPos]; originalPos--);
        for (var ps = originalPos; ps < newPos; ps++) if (void 0 === maskset.validPositions[ps] && !isMask(ps, !0)) {
          var vp = 0 == ps ? getTest(ps) : maskset.validPositions[ps - 1];
          if (vp) {
            var tests = getTests(ps).slice();
            '' === tests[tests.length - 1].match.def && tests.pop();
            var bestMatch = determineTestTemplate(ps, tests),
              np;
            if (bestMatch && (!0 !== bestMatch.match.jit || 'master' === bestMatch.match.newBlockMarker && (np = maskset.validPositions[ps + 1]) && !0 === np.match.optionalQuantifier) && (bestMatch = $.extend({}, bestMatch, {
              input: getPlaceholder(ps, bestMatch.match, !0) || bestMatch.match.def
            }), bestMatch.generatedInput = !0, revalidateMask(ps, bestMatch, !0), !0 !== fillOnly)) {
              var cvpInput = maskset.validPositions[newPos].input;
              return maskset.validPositions[newPos] = void 0, isValid(newPos, cvpInput, !0, !0);
            }
          }
        }
      }
      function revalidateMask(pos, validTest, fromIsValid, validatedPos) {
        function IsEnclosedStatic(pos, valids, selection) {
          var posMatch = valids[pos];
          if (void 0 === posMatch || !0 !== posMatch.match.static || !0 === posMatch.match.optionality || void 0 !== valids[0] && void 0 !== valids[0].alternation) return !1;
          var prevMatch = selection.begin <= pos - 1 ? valids[pos - 1] && !0 === valids[pos - 1].match.static && valids[pos - 1] : valids[pos - 1],
            nextMatch = selection.end > pos + 1 ? valids[pos + 1] && !0 === valids[pos + 1].match.static && valids[pos + 1] : valids[pos + 1];
          return prevMatch && nextMatch;
        }
        var offset = 0,
          begin = void 0 !== pos.begin ? pos.begin : pos,
          end = void 0 !== pos.end ? pos.end : pos;
        if (pos.begin > pos.end && (begin = pos.end, end = pos.begin), validatedPos = void 0 !== validatedPos ? validatedPos : begin, begin !== end || opts.insertMode && void 0 !== maskset.validPositions[validatedPos] && void 0 === fromIsValid || void 0 === validTest) {
          var positionsClone = $.extend(!0, {}, maskset.validPositions),
            lvp = getLastValidPosition(void 0, !0),
            i;
          for (maskset.p = begin, i = lvp; begin <= i; i--) delete maskset.validPositions[i], void 0 === validTest && delete maskset.tests[i + 1];
          var valid = !0,
            j = validatedPos,
            posMatch = j,
            t,
            canMatch;
          for (i = j, validTest && (maskset.validPositions[validatedPos] = $.extend(!0, {}, validTest), posMatch++, j++, begin < end && i++); i <= lvp; i++) {
            if (void 0 !== (t = positionsClone[i]) && !0 !== t.generatedInput && (end <= i || begin <= i && IsEnclosedStatic(i, positionsClone, {
              begin: begin,
              end: end
            }))) {
              for (; '' !== getTest(posMatch).match.def;) {
                if (!1 !== (canMatch = positionCanMatchDefinition(posMatch, t, opts)) || '+' === t.match.def) {
                  '+' === t.match.def && getBuffer(!0);
                  var result = isValid(posMatch, t.input, '+' !== t.match.def, '+' !== t.match.def);
                  if (valid = !1 !== result, j = (result.pos || posMatch) + 1, !valid && canMatch) break;
                } else valid = !1;
                if (valid) {
                  void 0 === validTest && t.match.static && i === pos.begin && offset++;
                  break;
                }
                if (!valid && posMatch > maskset.maskLength) break;
                posMatch++;
              }
              '' == getTest(posMatch).match.def && (valid = !1), posMatch = j;
            }
            if (!valid) break;
          }
          if (!valid) return maskset.validPositions = $.extend(!0, {}, positionsClone), resetMaskSet(!0), !1;
        } else validTest && getTest(validatedPos).match.cd === validTest.match.cd && (maskset.validPositions[validatedPos] = $.extend(!0, {}, validTest));
        return resetMaskSet(!0), offset;
      }
      function isMask(pos, strict, fuzzy) {
        var test = getTestTemplate(pos).match;
        if ('' === test.def && (test = getTest(pos).match), !0 !== test.static) return test.fn;
        if (!0 === fuzzy && void 0 !== maskset.validPositions[pos] && !0 !== maskset.validPositions[pos].generatedInput) return !0;
        if (!0 !== strict && -1 < pos) {
          if (fuzzy) {
            var tests = getTests(pos);
            return tests.length > 1 + ('' === tests[tests.length - 1].match.def ? 1 : 0);
          }
          var testTemplate = determineTestTemplate(pos, getTests(pos)),
            testPlaceHolder = getPlaceholder(pos, testTemplate.match);
          return testTemplate.match.def !== testPlaceHolder;
        }
        return !1;
      }
      function seekNext(pos, newBlock, fuzzy) {
        void 0 === fuzzy && (fuzzy = !0);
        for (var position = pos + 1; '' !== getTest(position).match.def && (!0 === newBlock && (!0 !== getTest(position).match.newBlockMarker || !isMask(position, void 0, !0)) || !0 !== newBlock && !isMask(position, void 0, fuzzy));) position++;
        return position;
      }
      function seekPrevious(pos, newBlock) {
        var position = pos,
          tests;
        if (position <= 0) return 0;
        for (; 0 < --position && (!0 === newBlock && !0 !== getTest(position).match.newBlockMarker || !0 !== newBlock && !isMask(position, void 0, !0) && (tests = getTests(position), tests.length < 2 || 2 === tests.length && '' === tests[1].match.def)););
        return position;
      }
      function writeBuffer(input, buffer, caretPos, event, triggerEvents) {
        if (event && $.isFunction(opts.onBeforeWrite)) {
          var result = opts.onBeforeWrite.call(inputmask, event, buffer, caretPos, opts);
          if (result) {
            if (result.refreshFromBuffer) {
              var refresh = result.refreshFromBuffer;
              refreshFromBuffer(!0 === refresh ? refresh : refresh.start, refresh.end, result.buffer || buffer), buffer = getBuffer(!0);
            }
            void 0 !== caretPos && (caretPos = void 0 !== result.caret ? result.caret : caretPos);
          }
        }
        if (void 0 !== input && (input.inputmask._valueSet(buffer.join('')), void 0 === caretPos || void 0 !== event && 'blur' === event.type || caret(input, caretPos, void 0, void 0, void 0 !== event && 'keydown' === event.type && (event.keyCode === keyCode.DELETE || event.keyCode === keyCode.BACKSPACE)), !0 === triggerEvents)) {
          var $input = $(input),
            nptVal = input.inputmask._valueGet();
          skipInputEvent = !0, $input.trigger('input'), setTimeout(function () {
            nptVal === getBufferTemplate().join('') ? $input.trigger('cleared') : !0 === isComplete(buffer) && $input.trigger('complete');
          }, 0);
        }
      }
      function getPlaceholder(pos, test, returnPL) {
        if (test = test || getTest(pos).match, void 0 !== test.placeholder || !0 === returnPL) return $.isFunction(test.placeholder) ? test.placeholder(opts) : test.placeholder;
        if (!0 !== test.static) return opts.placeholder.charAt(pos % opts.placeholder.length);
        if (-1 < pos && void 0 === maskset.validPositions[pos]) {
          var tests = getTests(pos),
            staticAlternations = [],
            prevTest;
          if (tests.length > 1 + ('' === tests[tests.length - 1].match.def ? 1 : 0)) for (var i = 0; i < tests.length; i++) if ('' !== tests[i].match.def && !0 !== tests[i].match.optionality && !0 !== tests[i].match.optionalQuantifier && (!0 === tests[i].match.static || void 0 === prevTest || !1 !== tests[i].match.fn.test(prevTest.match.def, maskset, pos, !0, opts)) && (staticAlternations.push(tests[i]), !0 === tests[i].match.static && (prevTest = tests[i]), 1 < staticAlternations.length && /[0-9a-bA-Z]/.test(staticAlternations[0].match.def))) return opts.placeholder.charAt(pos % opts.placeholder.length);
        }
        return test.def;
      }
      function HandleNativePlaceholder(npt, value) {
        if (ie) {
          if (npt.inputmask._valueGet() !== value && (npt.placeholder !== value || '' === npt.placeholder)) {
            var buffer = getBuffer().slice(),
              nptValue = npt.inputmask._valueGet();
            if (nptValue !== value) {
              var lvp = getLastValidPosition();
              -1 === lvp && nptValue === getBufferTemplate().join('') ? buffer = [] : -1 !== lvp && clearOptionalTail(buffer), writeBuffer(npt, buffer);
            }
          }
        } else npt.placeholder !== value && (npt.placeholder = value, '' === npt.placeholder && npt.removeAttribute('placeholder'));
      }
      function determineNewCaretPosition(selectedCaret, tabbed) {
        function doRadixFocus(clickPos) {
          if ('' !== opts.radixPoint && 0 !== opts.digits) {
            var vps = maskset.validPositions;
            if (void 0 === vps[clickPos] || vps[clickPos].input === getPlaceholder(clickPos)) {
              if (clickPos < seekNext(-1)) return !0;
              var radixPos = $.inArray(opts.radixPoint, getBuffer());
              if (-1 !== radixPos) {
                for (var vp in vps) if (vps[vp] && radixPos < vp && vps[vp].input !== getPlaceholder(vp)) return !1;
                return !0;
              }
            }
          }
          return !1;
        }
        if (tabbed && (isRTL ? selectedCaret.end = selectedCaret.begin : selectedCaret.begin = selectedCaret.end), selectedCaret.begin === selectedCaret.end) {
          switch (opts.positionCaretOnClick) {
            case 'none':
              break;
            case 'select':
              selectedCaret = {
                begin: 0,
                end: getBuffer().length
              };
              break;
            case 'ignore':
              selectedCaret.end = selectedCaret.begin = seekNext(getLastValidPosition());
              break;
            case 'radixFocus':
              if (doRadixFocus(selectedCaret.begin)) {
                var radixPos = getBuffer().join('').indexOf(opts.radixPoint);
                selectedCaret.end = selectedCaret.begin = opts.numericInput ? seekNext(radixPos) : radixPos;
                break;
              }
            default:
              var clickPosition = selectedCaret.begin,
                lvclickPosition = getLastValidPosition(clickPosition, !0),
                lastPosition = seekNext(-1 !== lvclickPosition || isMask(0) ? lvclickPosition : 0);
              if (clickPosition < lastPosition) selectedCaret.end = selectedCaret.begin = isMask(clickPosition, !0) || isMask(clickPosition - 1, !0) ? clickPosition : seekNext(clickPosition);else {
                var lvp = maskset.validPositions[lvclickPosition],
                  tt = getTestTemplate(lastPosition, lvp ? lvp.match.locator : void 0, lvp),
                  placeholder = getPlaceholder(lastPosition, tt.match);
                if ('' !== placeholder && getBuffer()[lastPosition] !== placeholder && !0 !== tt.match.optionalQuantifier && !0 !== tt.match.newBlockMarker || !isMask(lastPosition, opts.keepStatic) && tt.match.def === placeholder) {
                  var newPos = seekNext(lastPosition);
                  (newPos <= clickPosition || clickPosition === lastPosition) && (lastPosition = newPos);
                }
                selectedCaret.end = selectedCaret.begin = lastPosition;
              }
          }
          return selectedCaret;
        }
      }
      var EventRuler = {
          on: function on(input, eventName, eventHandler) {
            var ev = function ev(e) {
              e.originalEvent && (e = e.originalEvent || e, arguments[0] = e);
              var that = this,
                args;
              if (void 0 === that.inputmask && 'FORM' !== this.nodeName) {
                var imOpts = $.data(that, '_inputmask_opts');
                imOpts ? new Inputmask(imOpts).mask(that) : EventRuler.off(that);
              } else {
                if ('setvalue' === e.type || 'FORM' === this.nodeName || !(that.disabled || that.readOnly && !('keydown' === e.type && e.ctrlKey && 67 === e.keyCode || !1 === opts.tabThrough && e.keyCode === keyCode.TAB))) {
                  switch (e.type) {
                    case 'input':
                      if (!0 === skipInputEvent || e.inputType && 'insertCompositionText' === e.inputType) return skipInputEvent = !1, e.preventDefault();
                      break;
                    case 'keydown':
                      skipKeyPressEvent = !1, skipInputEvent = !1;
                      break;
                    case 'keypress':
                      if (!0 === skipKeyPressEvent) return e.preventDefault();
                      skipKeyPressEvent = !0;
                      break;
                    case 'click':
                    case 'focus':
                      return validationEvent ? (validationEvent = !1, input.blur(), HandleNativePlaceholder(input, (isRTL ? getBufferTemplate().slice().reverse() : getBufferTemplate()).join('')), setTimeout(function () {
                        input.focus();
                      }, 3e3)) : (args = arguments, setTimeout(function () {
                        eventHandler.apply(that, args);
                      }, 0)), !1;
                  }
                  var returnVal = eventHandler.apply(that, arguments);
                  return !1 === returnVal && (e.preventDefault(), e.stopPropagation()), returnVal;
                }
                e.preventDefault();
              }
            };
            input.inputmask.events[eventName] = input.inputmask.events[eventName] || [], input.inputmask.events[eventName].push(ev), -1 !== $.inArray(eventName, ['submit', 'reset']) ? null !== input.form && $(input.form).on(eventName, ev) : $(input).on(eventName, ev);
          },
          off: function off(input, event) {
            var events;
            input.inputmask && input.inputmask.events && (event ? (events = [], events[event] = input.inputmask.events[event]) : events = input.inputmask.events, $.each(events, function (eventName, evArr) {
              for (; 0 < evArr.length;) {
                var ev = evArr.pop();
                -1 !== $.inArray(eventName, ['submit', 'reset']) ? null !== input.form && $(input.form).off(eventName, ev) : $(input).off(eventName, ev);
              }
              delete input.inputmask.events[eventName];
            }));
          }
        },
        EventHandlers = {
          keydownEvent: function keydownEvent(e) {
            var input = this,
              $input = $(input),
              k = e.keyCode,
              pos = caret(input),
              kdResult = opts.onKeyDown.call(this, e, getBuffer(), pos, opts);
            if (void 0 !== kdResult) return kdResult;
            if (k === keyCode.BACKSPACE || k === keyCode.DELETE || iphone && k === keyCode.BACKSPACE_SAFARI || e.ctrlKey && k === keyCode.X && !('oncut' in input)) e.preventDefault(), handleRemove(input, k, pos), writeBuffer(input, getBuffer(!0), maskset.p, e, input.inputmask._valueGet() !== getBuffer().join(''));else if (k === keyCode.END || k === keyCode.PAGE_DOWN) {
              e.preventDefault();
              var caretPos = seekNext(getLastValidPosition());
              caret(input, e.shiftKey ? pos.begin : caretPos, caretPos, !0);
            } else k === keyCode.HOME && !e.shiftKey || k === keyCode.PAGE_UP ? (e.preventDefault(), caret(input, 0, e.shiftKey ? pos.begin : 0, !0)) : (opts.undoOnEscape && k === keyCode.ESCAPE || 90 === k && e.ctrlKey) && !0 !== e.altKey ? (checkVal(input, !0, !1, undoValue.split('')), $input.trigger('click')) : !0 === opts.tabThrough && k === keyCode.TAB ? (!0 === e.shiftKey ? (!0 === getTest(pos.begin).match.static && (pos.begin = seekNext(pos.begin)), pos.end = seekPrevious(pos.begin, !0), pos.begin = seekPrevious(pos.end, !0)) : (pos.begin = seekNext(pos.begin, !0), pos.end = seekNext(pos.begin, !0), pos.end < maskset.maskLength && pos.end--), pos.begin < maskset.maskLength && (e.preventDefault(), caret(input, pos.begin, pos.end))) : e.shiftKey || opts.insertModeVisual && !1 === opts.insertMode && (k === keyCode.RIGHT ? setTimeout(function () {
              var caretPos = caret(input);
              caret(input, caretPos.begin);
            }, 0) : k === keyCode.LEFT && setTimeout(function () {
              var caretPos_begin = translatePosition(input.inputmask.caretPos.begin),
                caretPos_end = translatePosition(input.inputmask.caretPos.end);
              caret(input, isRTL ? caretPos_begin + (caretPos_begin === maskset.maskLength ? 0 : 1) : caretPos_begin - (0 === caretPos_begin ? 0 : 1));
            }, 0));
            ignorable = -1 !== $.inArray(k, opts.ignorables);
          },
          keypressEvent: function keypressEvent(e, checkval, writeOut, strict, ndx) {
            var input = this,
              $input = $(input),
              k = e.which || e.charCode || e.keyCode;
            if (!(!0 === checkval || e.ctrlKey && e.altKey) && (e.ctrlKey || e.metaKey || ignorable)) return k === keyCode.ENTER && undoValue !== getBuffer().join('') && (undoValue = getBuffer().join(''), setTimeout(function () {
              $input.trigger('change');
            }, 0)), skipInputEvent = !0, !0;
            if (k) {
              44 !== k && 46 !== k || 3 !== e.location || '' === opts.radixPoint || (k = opts.radixPoint.charCodeAt(0));
              var pos = checkval ? {
                  begin: ndx,
                  end: ndx
                } : caret(input),
                forwardPosition,
                c = String.fromCharCode(k);
              maskset.writeOutBuffer = !0;
              var valResult = isValid(pos, c, strict);
              if (!1 !== valResult && (resetMaskSet(!0), forwardPosition = void 0 !== valResult.caret ? valResult.caret : seekNext(valResult.pos.begin ? valResult.pos.begin : valResult.pos), maskset.p = forwardPosition), forwardPosition = opts.numericInput && void 0 === valResult.caret ? seekPrevious(forwardPosition) : forwardPosition, !1 !== writeOut && (setTimeout(function () {
                opts.onKeyValidation.call(input, k, valResult);
              }, 0), maskset.writeOutBuffer && !1 !== valResult)) {
                var buffer = getBuffer();
                writeBuffer(input, buffer, forwardPosition, e, !0 !== checkval);
              }
              if (e.preventDefault(), checkval) return !1 !== valResult && (valResult.forwardPosition = forwardPosition), valResult;
            }
          },
          pasteEvent: function pasteEvent(e) {
            var input = this,
              inputValue = this.inputmask._valueGet(!0),
              caretPos = caret(this),
              tempValue;
            isRTL && (tempValue = caretPos.end, caretPos.end = caretPos.begin, caretPos.begin = tempValue);
            var valueBeforeCaret = inputValue.substr(0, caretPos.begin),
              valueAfterCaret = inputValue.substr(caretPos.end, inputValue.length);
            if (valueBeforeCaret == (isRTL ? getBufferTemplate().slice().reverse() : getBufferTemplate()).slice(0, caretPos.begin).join('') && (valueBeforeCaret = ''), valueAfterCaret == (isRTL ? getBufferTemplate().slice().reverse() : getBufferTemplate()).slice(caretPos.end).join('') && (valueAfterCaret = ''), window.clipboardData && window.clipboardData.getData) inputValue = valueBeforeCaret + window.clipboardData.getData('Text') + valueAfterCaret;else {
              if (!e.clipboardData || !e.clipboardData.getData) return !0;
              inputValue = valueBeforeCaret + e.clipboardData.getData('text/plain') + valueAfterCaret;
            }
            var pasteValue = inputValue;
            if ($.isFunction(opts.onBeforePaste)) {
              if (pasteValue = opts.onBeforePaste.call(inputmask, inputValue, opts), !1 === pasteValue) return e.preventDefault();
              pasteValue = pasteValue || inputValue;
            }
            return checkVal(this, !1, !1, pasteValue.toString().split('')), writeBuffer(this, getBuffer(), seekNext(getLastValidPosition()), e, undoValue !== getBuffer().join('')), e.preventDefault();
          },
          inputFallBackEvent: function inputFallBackEvent(e) {
            function ieMobileHandler(input, inputValue, caretPos) {
              if (iemobile) {
                var inputChar = inputValue.replace(getBuffer().join(''), '');
                if (1 === inputChar.length) {
                  var iv = inputValue.split('');
                  iv.splice(caretPos.begin, 0, inputChar), inputValue = iv.join('');
                }
              }
              return inputValue;
            }
            function analyseChanges(inputValue, buffer, caretPos) {
              for (var frontPart = inputValue.substr(0, caretPos.begin).split(''), backPart = inputValue.substr(caretPos.begin).split(''), frontBufferPart = buffer.substr(0, caretPos.begin).split(''), backBufferPart = buffer.substr(caretPos.begin).split(''), fpl = frontPart.length >= frontBufferPart.length ? frontPart.length : frontBufferPart.length, bpl = backPart.length >= backBufferPart.length ? backPart.length : backBufferPart.length, bl, i, action = '', data = [], marker = '~', placeholder; frontPart.length < fpl;) frontPart.push('~');
              for (; frontBufferPart.length < fpl;) frontBufferPart.push('~');
              for (; backPart.length < bpl;) backPart.unshift('~');
              for (; backBufferPart.length < bpl;) backBufferPart.unshift('~');
              var newBuffer = frontPart.concat(backPart),
                oldBuffer = frontBufferPart.concat(backBufferPart);
              for (i = 0, bl = newBuffer.length; i < bl; i++) switch (placeholder = getPlaceholder(translatePosition(i)), action) {
                case 'insertText':
                  oldBuffer[i - 1] === newBuffer[i] && caretPos.begin == newBuffer.length - 1 && data.push(newBuffer[i]), i = bl;
                  break;
                case 'insertReplacementText':
                  '~' === newBuffer[i] ? caretPos.end++ : i = bl;
                  break;
                case 'deleteContentBackward':
                  '~' === newBuffer[i] ? caretPos.end++ : i = bl;
                  break;
                default:
                  newBuffer[i] !== oldBuffer[i] && ('~' !== newBuffer[i + 1] && newBuffer[i + 1] !== placeholder && void 0 !== newBuffer[i + 1] || (oldBuffer[i] !== placeholder || '~' !== oldBuffer[i + 1]) && '~' !== oldBuffer[i] ? '~' === oldBuffer[i + 1] && oldBuffer[i] === newBuffer[i + 1] ? (action = 'insertText', data.push(newBuffer[i]), caretPos.begin--, caretPos.end--) : newBuffer[i] !== placeholder && '~' !== newBuffer[i] && ('~' === newBuffer[i + 1] || oldBuffer[i] !== newBuffer[i] && oldBuffer[i + 1] === newBuffer[i + 1]) ? (action = 'insertReplacementText', data.push(newBuffer[i]), caretPos.begin--) : '~' === newBuffer[i] ? (action = 'deleteContentBackward', !isMask(translatePosition(i), !0) && oldBuffer[i] !== opts.radixPoint || caretPos.end++) : i = bl : (action = 'insertText', data.push(newBuffer[i]), caretPos.begin--, caretPos.end--));
                  break;
              }
              return {
                action: action,
                data: data,
                caret: caretPos
              };
            }
            var input = this,
              inputValue = input.inputmask._valueGet(!0),
              buffer = (isRTL ? getBuffer().slice().reverse() : getBuffer()).join(''),
              caretPos = caret(input, void 0, void 0, !0);
            if (buffer !== inputValue) {
              inputValue = ieMobileHandler(input, inputValue, caretPos);
              var changes = analyseChanges(inputValue, buffer, caretPos);
              switch ((input.inputmask.shadowRoot || document).activeElement !== input && input.focus(), writeBuffer(input, getBuffer()), caret(input, caretPos.begin, caretPos.end, !0), changes.action) {
                case 'insertText':
                case 'insertReplacementText':
                  $.each(changes.data, function (ndx, entry) {
                    var keypress = new $.Event('keypress');
                    keypress.which = entry.charCodeAt(0), ignorable = !1, EventHandlers.keypressEvent.call(input, keypress);
                  }), setTimeout(function () {
                    $el.trigger('keyup');
                  }, 0);
                  break;
                case 'deleteContentBackward':
                  var keydown = new $.Event('keydown');
                  keydown.keyCode = keyCode.BACKSPACE, EventHandlers.keydownEvent.call(input, keydown);
                  break;
                default:
                  applyInputValue(input, inputValue);
                  break;
              }
              e.preventDefault();
            }
          },
          compositionendEvent: function compositionendEvent(e) {
            $el.trigger('input');
          },
          setValueEvent: function setValueEvent(e, argument_1, argument_2) {
            var input = this,
              value = e && e.detail ? e.detail[0] : argument_1;
            void 0 === value && (value = this.inputmask._valueGet(!0)), applyInputValue(this, value), (e.detail && void 0 !== e.detail[1] || void 0 !== argument_2) && caret(this, e.detail ? e.detail[1] : argument_2);
          },
          focusEvent: function focusEvent(e) {
            var input = this,
              nptValue = this.inputmask._valueGet();
            opts.showMaskOnFocus && nptValue !== getBuffer().join('') && writeBuffer(this, getBuffer(), seekNext(getLastValidPosition())), !0 !== opts.positionCaretOnTab || !1 !== mouseEnter || isComplete(getBuffer()) && -1 !== getLastValidPosition() || EventHandlers.clickEvent.apply(this, [e, !0]), undoValue = getBuffer().join('');
          },
          invalidEvent: function invalidEvent(e) {
            validationEvent = !0;
          },
          mouseleaveEvent: function mouseleaveEvent() {
            var input = this;
            mouseEnter = !1, opts.clearMaskOnLostFocus && (this.inputmask.shadowRoot || document).activeElement !== this && HandleNativePlaceholder(this, originalPlaceholder);
          },
          clickEvent: function clickEvent(e, tabbed) {
            var input = this;
            if ((this.inputmask.shadowRoot || document).activeElement === this) {
              var newCaretPosition = determineNewCaretPosition(caret(this), tabbed);
              void 0 !== newCaretPosition && caret(this, newCaretPosition);
            }
          },
          cutEvent: function cutEvent(e) {
            var input = this,
              pos = caret(this),
              clipboardData = window.clipboardData || e.clipboardData,
              clipData = isRTL ? getBuffer().slice(pos.end, pos.begin) : getBuffer().slice(pos.begin, pos.end);
            clipboardData.setData('text', isRTL ? clipData.reverse().join('') : clipData.join('')), document.execCommand && document.execCommand('copy'), handleRemove(this, keyCode.DELETE, pos), writeBuffer(this, getBuffer(), maskset.p, e, undoValue !== getBuffer().join(''));
          },
          blurEvent: function blurEvent(e) {
            var $input = $(this),
              input = this;
            if (this.inputmask) {
              HandleNativePlaceholder(this, originalPlaceholder);
              var nptValue = this.inputmask._valueGet(),
                buffer = getBuffer().slice();
              '' !== nptValue && (opts.clearMaskOnLostFocus && (-1 === getLastValidPosition() && nptValue === getBufferTemplate().join('') ? buffer = [] : clearOptionalTail(buffer)), !1 === isComplete(buffer) && (setTimeout(function () {
                $input.trigger('incomplete');
              }, 0), opts.clearIncomplete && (resetMaskSet(), buffer = opts.clearMaskOnLostFocus ? [] : getBufferTemplate().slice())), writeBuffer(this, buffer, void 0, e)), undoValue !== getBuffer().join('') && (undoValue = getBuffer().join(''), $input.trigger('change'));
            }
          },
          mouseenterEvent: function mouseenterEvent() {
            var input = this;
            mouseEnter = !0, (this.inputmask.shadowRoot || document).activeElement !== this && (null == originalPlaceholder && this.placeholder !== originalPlaceholder && (originalPlaceholder = this.placeholder), opts.showMaskOnHover && HandleNativePlaceholder(this, (isRTL ? getBufferTemplate().slice().reverse() : getBufferTemplate()).join('')));
          },
          submitEvent: function submitEvent() {
            undoValue !== getBuffer().join('') && $el.trigger('change'), opts.clearMaskOnLostFocus && -1 === getLastValidPosition() && el.inputmask._valueGet && el.inputmask._valueGet() === getBufferTemplate().join('') && el.inputmask._valueSet(''), opts.clearIncomplete && !1 === isComplete(getBuffer()) && el.inputmask._valueSet(''), opts.removeMaskOnSubmit && (el.inputmask._valueSet(el.inputmask.unmaskedvalue(), !0), setTimeout(function () {
              writeBuffer(el, getBuffer());
            }, 0));
          },
          resetEvent: function resetEvent() {
            el.inputmask.refreshValue = !0, setTimeout(function () {
              applyInputValue(el, el.inputmask._valueGet(!0));
            }, 0);
          }
        },
        valueBuffer;
      function checkVal(input, writeOut, strict, nptvl, initiatingEvent) {
        var inputmask = this || input.inputmask,
          inputValue = nptvl.slice(),
          charCodes = '',
          initialNdx = -1,
          result = void 0;
        function isTemplateMatch(ndx, charCodes) {
          for (var targetTemplate = getMaskTemplate(!0, 0).slice(ndx, seekNext(ndx)).join('').replace(/'/g, ''), charCodeNdx = targetTemplate.indexOf(charCodes); 0 < charCodeNdx && ' ' === targetTemplate[charCodeNdx - 1];) charCodeNdx--;
          var match = 0 === charCodeNdx && !isMask(ndx) && (getTest(ndx).match.nativeDef === charCodes.charAt(0) || !0 === getTest(ndx).match.static && getTest(ndx).match.nativeDef === "'" + charCodes.charAt(0) || ' ' === getTest(ndx).match.nativeDef && (getTest(ndx + 1).match.nativeDef === charCodes.charAt(0) || !0 === getTest(ndx + 1).match.static && getTest(ndx + 1).match.nativeDef === "'" + charCodes.charAt(0)));
          return !match && 0 < charCodeNdx && (inputmask.caretPos = {
            begin: seekNext(charCodeNdx)
          }), match;
        }
        resetMaskSet(), maskset.tests = {}, initialNdx = opts.radixPoint ? determineNewCaretPosition({
          begin: 0,
          end: 0
        }).begin : 0, maskset.p = initialNdx, inputmask.caretPos = {
          begin: initialNdx
        };
        var staticMatches = [],
          prevCaretPos = inputmask.caretPos;
        if ($.each(inputValue, function (ndx, charCode) {
          if (void 0 !== charCode) if (void 0 === maskset.validPositions[ndx] && inputValue[ndx] === getPlaceholder(ndx) && isMask(ndx, !0) && !1 === isValid(ndx, inputValue[ndx], !0, void 0, void 0, !0)) maskset.p++;else {
            var keypress = new $.Event('_checkval');
            keypress.which = charCode.toString().charCodeAt(0), charCodes += charCode;
            var lvp = getLastValidPosition(void 0, !0);
            isTemplateMatch(initialNdx, charCodes) ? result = EventHandlers.keypressEvent.call(input, keypress, !0, !1, strict, lvp + 1) : (result = EventHandlers.keypressEvent.call(input, keypress, !0, !1, strict, inputmask.caretPos.begin), result && (initialNdx = inputmask.caretPos.begin + 1, charCodes = '')), result ? (void 0 !== result.pos && maskset.validPositions[result.pos] && !0 === maskset.validPositions[result.pos].match.static && void 0 === maskset.validPositions[result.pos].alternation && (staticMatches.push(result.pos), isRTL || (result.forwardPosition = result.pos + 1)), writeBuffer(void 0, getBuffer(), result.forwardPosition, keypress, !1), inputmask.caretPos = {
              begin: result.forwardPosition,
              end: result.forwardPosition
            }, prevCaretPos = inputmask.caretPos) : inputmask.caretPos = prevCaretPos;
          }
        }), 0 < staticMatches.length) {
          var sndx,
            validPos,
            nextValid = seekNext(-1, void 0, !1);
          if (!isComplete(getBuffer()) && staticMatches.length <= nextValid || isComplete(getBuffer()) && 0 < staticMatches.length && staticMatches.length !== nextValid && 0 === staticMatches[0]) for (var nextSndx = nextValid; void 0 !== (sndx = staticMatches.shift());) {
            var keypress = new $.Event('_checkval');
            if (validPos = maskset.validPositions[sndx], validPos.generatedInput = !0, keypress.which = validPos.input.charCodeAt(0), result = EventHandlers.keypressEvent.call(input, keypress, !0, !1, strict, nextSndx), result && void 0 !== result.pos && result.pos !== sndx && maskset.validPositions[result.pos] && !0 === maskset.validPositions[result.pos].match.static) staticMatches.push(result.pos);else if (!result) break;
            nextSndx++;
          } else for (; sndx = staticMatches.pop();) validPos = maskset.validPositions[sndx], validPos && (validPos.generatedInput = !0);
        }
        if (writeOut) for (var vndx in writeBuffer(input, getBuffer(), result ? result.forwardPosition : void 0, initiatingEvent || new $.Event('checkval'), initiatingEvent && 'input' === initiatingEvent.type), maskset.validPositions) !0 !== maskset.validPositions[vndx].match.generated && delete maskset.validPositions[vndx].generatedInput;
      }
      function unmaskedvalue(input) {
        if (input) {
          if (void 0 === input.inputmask) return input.value;
          input.inputmask && input.inputmask.refreshValue && applyInputValue(input, input.inputmask._valueGet(!0));
        }
        var umValue = [],
          vps = maskset.validPositions;
        for (var pndx in vps) vps[pndx] && vps[pndx].match && 1 != vps[pndx].match.static && umValue.push(vps[pndx].input);
        var unmaskedValue = 0 === umValue.length ? '' : (isRTL ? umValue.reverse() : umValue).join('');
        if ($.isFunction(opts.onUnMask)) {
          var bufferValue = (isRTL ? getBuffer().slice().reverse() : getBuffer()).join('');
          unmaskedValue = opts.onUnMask.call(inputmask, bufferValue, unmaskedValue, opts);
        }
        return unmaskedValue;
      }
      function translatePosition(pos) {
        return !isRTL || 'number' != typeof pos || opts.greedy && '' === opts.placeholder || !el || (pos = el.inputmask._valueGet().length - pos), pos;
      }
      function caret(input, begin, end, notranslate, isDelete) {
        var range;
        if (void 0 === begin) return 'selectionStart' in input && 'selectionEnd' in input ? (begin = input.selectionStart, end = input.selectionEnd) : window.getSelection ? (range = window.getSelection().getRangeAt(0), range.commonAncestorContainer.parentNode !== input && range.commonAncestorContainer !== input || (begin = range.startOffset, end = range.endOffset)) : document.selection && document.selection.createRange && (range = document.selection.createRange(), begin = 0 - range.duplicate().moveStart('character', -input.inputmask._valueGet().length), end = begin + range.text.length), {
          begin: notranslate ? begin : translatePosition(begin),
          end: notranslate ? end : translatePosition(end)
        };
        if ($.isArray(begin) && (end = isRTL ? begin[0] : begin[1], begin = isRTL ? begin[1] : begin[0]), void 0 !== begin.begin && (end = isRTL ? begin.begin : begin.end, begin = isRTL ? begin.end : begin.begin), 'number' == typeof begin) {
          begin = notranslate ? begin : translatePosition(begin), end = notranslate ? end : translatePosition(end), end = 'number' == typeof end ? end : begin;
          var scrollCalc = parseInt(((input.ownerDocument.defaultView || window).getComputedStyle ? (input.ownerDocument.defaultView || window).getComputedStyle(input, null) : input.currentStyle).fontSize) * end;
          if (input.scrollLeft = scrollCalc > input.scrollWidth ? scrollCalc : 0, input.inputmask.caretPos = {
            begin: begin,
            end: end
          }, opts.insertModeVisual && !1 === opts.insertMode && begin === end && (isDelete || end++), input === (input.inputmask.shadowRoot || document).activeElement) if ('setSelectionRange' in input) input.setSelectionRange(begin, end);else if (window.getSelection) {
            if (range = document.createRange(), void 0 === input.firstChild || null === input.firstChild) {
              var textNode = document.createTextNode('');
              input.appendChild(textNode);
            }
            range.setStart(input.firstChild, begin < input.inputmask._valueGet().length ? begin : input.inputmask._valueGet().length), range.setEnd(input.firstChild, end < input.inputmask._valueGet().length ? end : input.inputmask._valueGet().length), range.collapse(!0);
            var sel = window.getSelection();
            sel.removeAllRanges(), sel.addRange(range);
          } else input.createTextRange && (range = input.createTextRange(), range.collapse(!0), range.moveEnd('character', end), range.moveStart('character', begin), range.select());
        }
      }
      function determineLastRequiredPosition(returnDefinition) {
        var buffer = getMaskTemplate(!0, getLastValidPosition(), !0, !0),
          bl = buffer.length,
          pos,
          lvp = getLastValidPosition(),
          positions = {},
          lvTest = maskset.validPositions[lvp],
          ndxIntlzr = void 0 !== lvTest ? lvTest.locator.slice() : void 0,
          testPos;
        for (pos = lvp + 1; pos < buffer.length; pos++) testPos = getTestTemplate(pos, ndxIntlzr, pos - 1), ndxIntlzr = testPos.locator.slice(), positions[pos] = $.extend(!0, {}, testPos);
        var lvTestAlt = lvTest && void 0 !== lvTest.alternation ? lvTest.locator[lvTest.alternation] : void 0;
        for (pos = bl - 1; lvp < pos && (testPos = positions[pos], (testPos.match.optionality || testPos.match.optionalQuantifier && testPos.match.newBlockMarker || lvTestAlt && (lvTestAlt !== positions[pos].locator[lvTest.alternation] && 1 != testPos.match.static || !0 === testPos.match.static && testPos.locator[lvTest.alternation] && checkAlternationMatch(testPos.locator[lvTest.alternation].toString().split(','), lvTestAlt.toString().split(',')) && '' !== getTests(pos)[0].def)) && buffer[pos] === getPlaceholder(pos, testPos.match)); pos--) bl--;
        return returnDefinition ? {
          l: bl,
          def: positions[bl] ? positions[bl].match : void 0
        } : bl;
      }
      function clearOptionalTail(buffer) {
        buffer.length = 0;
        for (var template = getMaskTemplate(!0, 0, !0, void 0, !0), lmnt; void 0 !== (lmnt = template.shift());) buffer.push(lmnt);
        return buffer;
      }
      function isComplete(buffer) {
        if ($.isFunction(opts.isComplete)) return opts.isComplete(buffer, opts);
        if ('*' !== opts.repeat) {
          var complete = !1,
            lrp = determineLastRequiredPosition(!0),
            aml = seekPrevious(lrp.l);
          if (void 0 === lrp.def || lrp.def.newBlockMarker || lrp.def.optionality || lrp.def.optionalQuantifier) {
            complete = !0;
            for (var i = 0; i <= aml; i++) {
              var test = getTestTemplate(i).match;
              if (!0 !== test.static && void 0 === maskset.validPositions[i] && !0 !== test.optionality && !0 !== test.optionalQuantifier || !0 === test.static && buffer[i] !== getPlaceholder(i, test)) {
                complete = !1;
                break;
              }
            }
          }
          return complete;
        }
      }
      function handleRemove(input, k, pos, strict, fromIsValid) {
        if ((opts.numericInput || isRTL) && (k === keyCode.BACKSPACE ? k = keyCode.DELETE : k === keyCode.DELETE && (k = keyCode.BACKSPACE), isRTL)) {
          var pend = pos.end;
          pos.end = pos.begin, pos.begin = pend;
        }
        var offset;
        if (k === keyCode.BACKSPACE ? pos.end - pos.begin < 1 && (pos.begin = seekPrevious(pos.begin)) : k === keyCode.DELETE && pos.begin === pos.end && (pos.end = isMask(pos.end, !0, !0) ? pos.end + 1 : seekNext(pos.end) + 1), !1 !== (offset = revalidateMask(pos))) {
          if (!0 !== strict && !1 !== opts.keepStatic || null !== opts.regex && -1 !== getTest(pos.begin).match.def.indexOf('|')) {
            var result = alternate(!0);
            if (result) {
              var newPos = void 0 !== result.caret ? result.caret : result.pos ? seekNext(result.pos.begin ? result.pos.begin : result.pos) : getLastValidPosition(-1, !0);
              (k !== keyCode.DELETE || pos.begin > newPos) && pos.begin;
            }
          }
          !0 !== strict && (maskset.p = k === keyCode.DELETE ? pos.begin + offset : pos.begin);
        }
      }
      function applyInputValue(input, value) {
        input.inputmask.refreshValue = !1, $.isFunction(opts.onBeforeMask) && (value = opts.onBeforeMask.call(inputmask, value, opts) || value), value = value.toString().split(''), checkVal(input, !0, !1, value), undoValue = getBuffer().join(''), (opts.clearMaskOnLostFocus || opts.clearIncomplete) && input.inputmask._valueGet() === getBufferTemplate().join('') && -1 === getLastValidPosition() && input.inputmask._valueSet('');
      }
      function mask(elem) {
        function isElementTypeSupported(input, opts) {
          function patchValueProperty(npt) {
            var valueGet, valueSet;
            function patchValhook(type) {
              if ($.valHooks && (void 0 === $.valHooks[type] || !0 !== $.valHooks[type].inputmaskpatch)) {
                var valhookGet = $.valHooks[type] && $.valHooks[type].get ? $.valHooks[type].get : function (elem) {
                    return elem.value;
                  },
                  valhookSet = $.valHooks[type] && $.valHooks[type].set ? $.valHooks[type].set : function (elem, value) {
                    return elem.value = value, elem;
                  };
                $.valHooks[type] = {
                  get: function get(elem) {
                    if (elem.inputmask) {
                      if (elem.inputmask.opts.autoUnmask) return elem.inputmask.unmaskedvalue();
                      var result = valhookGet(elem);
                      return -1 !== getLastValidPosition(void 0, void 0, elem.inputmask.maskset.validPositions) || !0 !== opts.nullable ? result : '';
                    }
                    return valhookGet(elem);
                  },
                  set: function set(elem, value) {
                    var result = valhookSet(elem, value);
                    return elem.inputmask && applyInputValue(elem, value), result;
                  },
                  inputmaskpatch: !0
                };
              }
            }
            function getter() {
              return this.inputmask ? this.inputmask.opts.autoUnmask ? this.inputmask.unmaskedvalue() : -1 !== getLastValidPosition() || !0 !== opts.nullable ? (this.inputmask.shadowRoot || document.activeElement) === this && opts.clearMaskOnLostFocus ? (isRTL ? clearOptionalTail(getBuffer().slice()).reverse() : clearOptionalTail(getBuffer().slice())).join('') : valueGet.call(this) : '' : valueGet.call(this);
            }
            function setter(value) {
              valueSet.call(this, value), this.inputmask && applyInputValue(this, value);
            }
            function installNativeValueSetFallback(npt) {
              EventRuler.on(npt, 'mouseenter', function () {
                var input = this,
                  value = this.inputmask._valueGet(!0);
                value !== (isRTL ? getBuffer().reverse() : getBuffer()).join('') && applyInputValue(this, value);
              });
            }
            if (!npt.inputmask.__valueGet) {
              if (!0 !== opts.noValuePatching) {
                if (Object.getOwnPropertyDescriptor) {
                  'function' != typeof Object.getPrototypeOf && (Object.getPrototypeOf = 'object' === _typeof('test'.__proto__) ? function (object) {
                    return object.__proto__;
                  } : function (object) {
                    return object.constructor.prototype;
                  });
                  var valueProperty = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(npt), 'value') : void 0;
                  valueProperty && valueProperty.get && valueProperty.set ? (valueGet = valueProperty.get, valueSet = valueProperty.set, Object.defineProperty(npt, 'value', {
                    get: getter,
                    set: setter,
                    configurable: !0
                  })) : 'input' !== npt.tagName.toLowerCase() && (valueGet = function valueGet() {
                    return this.textContent;
                  }, valueSet = function valueSet(value) {
                    this.textContent = value;
                  }, Object.defineProperty(npt, 'value', {
                    get: getter,
                    set: setter,
                    configurable: !0
                  }));
                } else document.__lookupGetter__ && npt.__lookupGetter__('value') && (valueGet = npt.__lookupGetter__('value'), valueSet = npt.__lookupSetter__('value'), npt.__defineGetter__('value', getter), npt.__defineSetter__('value', setter));
                npt.inputmask.__valueGet = valueGet, npt.inputmask.__valueSet = valueSet;
              }
              npt.inputmask._valueGet = function (overruleRTL) {
                return isRTL && !0 !== overruleRTL ? valueGet.call(this.el).split('').reverse().join('') : valueGet.call(this.el);
              }, npt.inputmask._valueSet = function (value, overruleRTL) {
                valueSet.call(this.el, null == value ? '' : !0 !== overruleRTL && isRTL ? value.split('').reverse().join('') : value);
              }, void 0 === valueGet && (valueGet = function valueGet() {
                return this.value;
              }, valueSet = function valueSet(value) {
                this.value = value;
              }, patchValhook(npt.type), installNativeValueSetFallback(npt));
            }
          }
          'textarea' !== input.tagName.toLowerCase() && opts.ignorables.push(keyCode.ENTER);
          var elementType = input.getAttribute('type'),
            isSupported = 'input' === input.tagName.toLowerCase() && -1 !== $.inArray(elementType, opts.supportsInputType) || input.isContentEditable || 'textarea' === input.tagName.toLowerCase();
          if (!isSupported) if ('input' === input.tagName.toLowerCase()) {
            var el = document.createElement('input');
            el.setAttribute('type', elementType), isSupported = 'text' === el.type, el = null;
          } else isSupported = 'partial';
          return !1 !== isSupported ? patchValueProperty(input) : input.inputmask = void 0, isSupported;
        }
        EventRuler.off(elem);
        var isSupported = isElementTypeSupported(elem, opts);
        if (!1 !== isSupported) {
          el = elem, $el = $(el), originalPlaceholder = el.placeholder, maxLength = void 0 !== el ? el.maxLength : void 0, -1 === maxLength && (maxLength = void 0), 'inputMode' in el && null === el.getAttribute('inputmode') && (el.inputMode = opts.inputmode, el.setAttribute('inputmode', opts.inputmode)), !0 === isSupported && (opts.showMaskOnFocus = opts.showMaskOnFocus && -1 === ['cc-number', 'cc-exp'].indexOf(el.autocomplete), iphone && (opts.insertModeVisual = !1), EventRuler.on(el, 'submit', EventHandlers.submitEvent), EventRuler.on(el, 'reset', EventHandlers.resetEvent), EventRuler.on(el, 'blur', EventHandlers.blurEvent), EventRuler.on(el, 'focus', EventHandlers.focusEvent), EventRuler.on(el, 'invalid', EventHandlers.invalidEvent), EventRuler.on(el, 'click', EventHandlers.clickEvent), EventRuler.on(el, 'mouseleave', EventHandlers.mouseleaveEvent), EventRuler.on(el, 'mouseenter', EventHandlers.mouseenterEvent), EventRuler.on(el, 'paste', EventHandlers.pasteEvent), EventRuler.on(el, 'cut', EventHandlers.cutEvent), EventRuler.on(el, 'complete', opts.oncomplete), EventRuler.on(el, 'incomplete', opts.onincomplete), EventRuler.on(el, 'cleared', opts.oncleared), mobile || !0 === opts.inputEventOnly ? el.removeAttribute('maxLength') : (EventRuler.on(el, 'keydown', EventHandlers.keydownEvent), EventRuler.on(el, 'keypress', EventHandlers.keypressEvent)), EventRuler.on(el, 'input', EventHandlers.inputFallBackEvent), EventRuler.on(el, 'compositionend', EventHandlers.compositionendEvent)), EventRuler.on(el, 'setvalue', EventHandlers.setValueEvent), undoValue = getBufferTemplate().join('');
          var activeElement = (el.inputmask.shadowRoot || document).activeElement;
          if ('' !== el.inputmask._valueGet(!0) || !1 === opts.clearMaskOnLostFocus || activeElement === el) {
            applyInputValue(el, el.inputmask._valueGet(!0), opts);
            var buffer = getBuffer().slice();
            !1 === isComplete(buffer) && opts.clearIncomplete && resetMaskSet(), opts.clearMaskOnLostFocus && activeElement !== el && (-1 === getLastValidPosition() ? buffer = [] : clearOptionalTail(buffer)), (!1 === opts.clearMaskOnLostFocus || opts.showMaskOnFocus && activeElement === el || '' !== el.inputmask._valueGet(!0)) && writeBuffer(el, buffer), activeElement === el && caret(el, seekNext(getLastValidPosition()));
          }
        }
      }
      if (void 0 !== actionObj) switch (actionObj.action) {
        case 'isComplete':
          return el = actionObj.el, isComplete(getBuffer());
        case 'unmaskedvalue':
          return void 0 !== el && void 0 === actionObj.value || (valueBuffer = actionObj.value, valueBuffer = ($.isFunction(opts.onBeforeMask) && opts.onBeforeMask.call(inputmask, valueBuffer, opts) || valueBuffer).split(''), checkVal.call(this, void 0, !1, !1, valueBuffer), $.isFunction(opts.onBeforeWrite) && opts.onBeforeWrite.call(inputmask, void 0, getBuffer(), 0, opts)), unmaskedvalue(el);
        case 'mask':
          mask(el);
          break;
        case 'format':
          return valueBuffer = ($.isFunction(opts.onBeforeMask) && opts.onBeforeMask.call(inputmask, actionObj.value, opts) || actionObj.value).split(''), checkVal.call(this, void 0, !0, !1, valueBuffer), actionObj.metadata ? {
            value: isRTL ? getBuffer().slice().reverse().join('') : getBuffer().join(''),
            metadata: maskScope.call(this, {
              action: 'getmetadata'
            }, maskset, opts)
          } : isRTL ? getBuffer().slice().reverse().join('') : getBuffer().join('');
        case 'isValid':
          actionObj.value ? (valueBuffer = ($.isFunction(opts.onBeforeMask) && opts.onBeforeMask.call(inputmask, actionObj.value, opts) || actionObj.value).split(''), checkVal.call(this, void 0, !0, !1, valueBuffer)) : actionObj.value = isRTL ? getBuffer().slice().reverse().join('') : getBuffer().join('');
          for (var buffer = getBuffer(), rl = determineLastRequiredPosition(), lmib = buffer.length - 1; rl < lmib && !isMask(lmib); lmib--);
          return buffer.splice(rl, lmib + 1 - rl), isComplete(buffer) && actionObj.value === (isRTL ? getBuffer().slice().reverse().join('') : getBuffer().join(''));
        case 'getemptymask':
          return getBufferTemplate().join('');
        case 'remove':
          if (el && el.inputmask) {
            $.data(el, '_inputmask_opts', null), $el = $(el);
            var cv = opts.autoUnmask ? unmaskedvalue(el) : el.inputmask._valueGet(opts.autoUnmask),
              valueProperty;
            cv !== getBufferTemplate().join('') ? el.inputmask._valueSet(cv, opts.autoUnmask) : el.inputmask._valueSet(''), EventRuler.off(el), Object.getOwnPropertyDescriptor && Object.getPrototypeOf ? (valueProperty = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(el), 'value'), valueProperty && el.inputmask.__valueGet && Object.defineProperty(el, 'value', {
              get: el.inputmask.__valueGet,
              set: el.inputmask.__valueSet,
              configurable: !0
            })) : document.__lookupGetter__ && el.__lookupGetter__('value') && el.inputmask.__valueGet && (el.__defineGetter__('value', el.inputmask.__valueGet), el.__defineSetter__('value', el.inputmask.__valueSet)), el.inputmask = void 0;
          }
          return el;
        case 'getmetadata':
          if ($.isArray(maskset.metadata)) {
            var maskTarget = getMaskTemplate(!0, 0, !1).join('');
            return $.each(maskset.metadata, function (ndx, mtdt) {
              if (mtdt.mask === maskTarget) return maskTarget = mtdt, !1;
            }), maskTarget;
          }
          return maskset.metadata;
      }
    };
  }, function (module, exports, __nested_webpack_require_123475__) {
    'use strict';

    function _typeof(obj) {
      return _typeof = 'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator ? function _typeof(obj) {
        return typeof obj;
      } : function _typeof(obj) {
        return obj && 'function' == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
      }, _typeof(obj);
    }
    var Inputmask = __nested_webpack_require_123475__(1),
      $ = Inputmask.dependencyLib,
      keyCode = __nested_webpack_require_123475__(0),
      formatCode = {
        d: ['[1-9]|[12][0-9]|3[01]', Date.prototype.setDate, 'day', Date.prototype.getDate],
        dd: ['0[1-9]|[12][0-9]|3[01]', Date.prototype.setDate, 'day', function () {
          return pad(Date.prototype.getDate.call(this), 2);
        }],
        ddd: [''],
        dddd: [''],
        m: ['[1-9]|1[012]', Date.prototype.setMonth, 'month', function () {
          return Date.prototype.getMonth.call(this) + 1;
        }],
        mm: ['0[1-9]|1[012]', Date.prototype.setMonth, 'month', function () {
          return pad(Date.prototype.getMonth.call(this) + 1, 2);
        }],
        mmm: [''],
        mmmm: [''],
        yy: ['[0-9]{2}', Date.prototype.setFullYear, 'year', function () {
          return pad(Date.prototype.getFullYear.call(this), 2);
        }],
        yyyy: ['[0-9]{4}', Date.prototype.setFullYear, 'year', function () {
          return pad(Date.prototype.getFullYear.call(this), 4);
        }],
        h: ['[1-9]|1[0-2]', Date.prototype.setHours, 'hours', Date.prototype.getHours],
        hh: ['0[1-9]|1[0-2]', Date.prototype.setHours, 'hours', function () {
          return pad(Date.prototype.getHours.call(this), 2);
        }],
        hx: [function (x) {
          return '[0-9]{'.concat(x, '}');
        }, Date.prototype.setHours, 'hours', function (x) {
          return Date.prototype.getHours;
        }],
        H: ['1?[0-9]|2[0-3]', Date.prototype.setHours, 'hours', Date.prototype.getHours],
        HH: ['0[0-9]|1[0-9]|2[0-3]', Date.prototype.setHours, 'hours', function () {
          return pad(Date.prototype.getHours.call(this), 2);
        }],
        Hx: [function (x) {
          return '[0-9]{'.concat(x, '}');
        }, Date.prototype.setHours, 'hours', function (x) {
          return function () {
            return pad(Date.prototype.getHours.call(this), x);
          };
        }],
        M: ['[1-5]?[0-9]', Date.prototype.setMinutes, 'minutes', Date.prototype.getMinutes],
        MM: ['0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]', Date.prototype.setMinutes, 'minutes', function () {
          return pad(Date.prototype.getMinutes.call(this), 2);
        }],
        s: ['[1-5]?[0-9]', Date.prototype.setSeconds, 'seconds', Date.prototype.getSeconds],
        ss: ['0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]', Date.prototype.setSeconds, 'seconds', function () {
          return pad(Date.prototype.getSeconds.call(this), 2);
        }],
        l: ['[0-9]{3}', Date.prototype.setMilliseconds, 'milliseconds', function () {
          return pad(Date.prototype.getMilliseconds.call(this), 3);
        }],
        L: ['[0-9]{2}', Date.prototype.setMilliseconds, 'milliseconds', function () {
          return pad(Date.prototype.getMilliseconds.call(this), 2);
        }],
        t: ['[ap]'],
        tt: ['[ap]m'],
        T: ['[AP]'],
        TT: ['[AP]M'],
        Z: [''],
        o: [''],
        S: ['']
      },
      formatAlias = {
        isoDate: 'yyyy-mm-dd',
        isoTime: 'HH:MM:ss',
        isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
        isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
      };
    function formatcode(match) {
      var dynMatches = new RegExp('\\d+$').exec(match[0]);
      if (dynMatches && void 0 !== dynMatches[0]) {
        var fcode = formatCode[match[0][0] + 'x'].slice('');
        return fcode[0] = fcode[0](dynMatches[0]), fcode[3] = fcode[3](dynMatches[0]), fcode;
      }
      if (formatCode[match[0]]) return formatCode[match[0]];
    }
    function getTokenizer(opts) {
      if (!opts.tokenizer) {
        var tokens = [],
          dyntokens = [];
        for (var ndx in formatCode) if (/\.*x$/.test(ndx)) {
          var dynToken = ndx[0] + '\\d+';
          -1 === dyntokens.indexOf(dynToken) && dyntokens.push(dynToken);
        } else -1 === tokens.indexOf(ndx[0]) && tokens.push(ndx[0]);
        opts.tokenizer = '(' + (0 < dyntokens.length ? dyntokens.join('|') + '|' : '') + tokens.join('+|') + ')+?|.', opts.tokenizer = new RegExp(opts.tokenizer, 'g');
      }
      return opts.tokenizer;
    }
    function isValidDate(dateParts, currentResult) {
      return (!isFinite(dateParts.rawday) || '29' == dateParts.day && !isFinite(dateParts.rawyear) || new Date(dateParts.date.getFullYear(), isFinite(dateParts.rawmonth) ? dateParts.month : dateParts.date.getMonth() + 1, 0).getDate() >= dateParts.day) && currentResult;
    }
    function isDateInRange(dateParts, opts) {
      var result = !0;
      if (opts.min) {
        if (dateParts.rawyear) {
          var rawYear = dateParts.rawyear.replace(/[^0-9]/g, ''),
            minYear = opts.min.year.substr(0, rawYear.length);
          result = minYear <= rawYear;
        }
        dateParts.year === dateParts.rawyear && opts.min.date.getTime() == opts.min.date.getTime() && (result = opts.min.date.getTime() <= dateParts.date.getTime());
      }
      return result && opts.max && opts.max.date.getTime() == opts.max.date.getTime() && (result = opts.max.date.getTime() >= dateParts.date.getTime()), result;
    }
    function parse(format, dateObjValue, opts, raw) {
      var mask = '',
        match,
        fcode;
      for (getTokenizer(opts).lastIndex = 0; match = getTokenizer(opts).exec(format);) if (void 0 === dateObjValue) {
        if (fcode = formatcode(match)) mask += '(' + fcode[0] + ')';else switch (match[0]) {
          case '[':
            mask += '(';
            break;
          case ']':
            mask += ')?';
            break;
          default:
            mask += Inputmask.escapeRegex(match[0]);
        }
      } else if (fcode = formatcode(match)) {
        if (!0 !== raw && fcode[3]) {
          var getFn = fcode[3];
          mask += getFn.call(dateObjValue.date);
        } else fcode[2] ? mask += dateObjValue['raw' + fcode[2]] : mask += match[0];
      } else mask += match[0];
      return mask;
    }
    function pad(val, len) {
      for (val = String(val), len = len || 2; val.length < len;) val = '0' + val;
      return val;
    }
    function analyseMask(maskString, format, opts) {
      var dateObj = {
          date: new Date(1, 0, 1)
        },
        targetProp,
        mask = maskString,
        match,
        dateOperation;
      function extendProperty(value) {
        var correctedValue = value.replace(/[^0-9]/g, '0');
        return correctedValue;
      }
      function setValue(dateObj, value, opts) {
        dateObj[targetProp] = extendProperty(value), dateObj['raw' + targetProp] = value, void 0 !== dateOperation && dateOperation.call(dateObj.date, 'month' == targetProp ? parseInt(dateObj[targetProp]) - 1 : dateObj[targetProp]);
      }
      if ('string' == typeof mask) {
        for (getTokenizer(opts).lastIndex = 0; match = getTokenizer(opts).exec(format);) {
          var value = mask.slice(0, match[0].length);
          formatCode.hasOwnProperty(match[0]) && (targetProp = formatCode[match[0]][2], dateOperation = formatCode[match[0]][1], setValue(dateObj, value, opts)), mask = mask.slice(value.length);
        }
        return dateObj;
      }
      if (mask && 'object' === _typeof(mask) && mask.hasOwnProperty('date')) return mask;
    }
    function importDate(dateObj, opts) {
      var match,
        date = '';
      for (getTokenizer(opts).lastIndex = 0; match = getTokenizer(opts).exec(opts.inputFormat);) 'd' === match[0].charAt(0) ? date += pad(dateObj.getDate(), match[0].length) : 'm' === match[0].charAt(0) ? date += pad(dateObj.getMonth() + 1, match[0].length) : 'yyyy' === match[0] ? date += dateObj.getFullYear().toString() : 'y' === match[0].charAt(0) && (date += pad(dateObj.getYear(), match[0].length));
      return date;
    }
    function getTokenMatch(pos, opts) {
      var calcPos = 0,
        targetMatch,
        match;
      for (getTokenizer(opts).lastIndex = 0; match = getTokenizer(opts).exec(opts.inputFormat);) if (calcPos += match[0].length, pos <= calcPos) {
        targetMatch = match, match = getTokenizer(opts).exec(opts.inputFormat);
        break;
      }
      return {
        nextMatch: match,
        targetMatch: targetMatch
      };
    }
    Inputmask.extendAliases({
      datetime: {
        mask: function mask(opts) {
          return opts.numericInput = !1, formatCode.S = opts.i18n.ordinalSuffix.join('|'), opts.inputFormat = formatAlias[opts.inputFormat] || opts.inputFormat, opts.displayFormat = formatAlias[opts.displayFormat] || opts.displayFormat || opts.inputFormat, opts.outputFormat = formatAlias[opts.outputFormat] || opts.outputFormat || opts.inputFormat, opts.placeholder = '' !== opts.placeholder ? opts.placeholder : opts.inputFormat.replace(/[[\]]/, ''), opts.regex = parse(opts.inputFormat, void 0, opts), opts.min = analyseMask(opts.min, opts.inputFormat, opts), opts.max = analyseMask(opts.max, opts.inputFormat, opts), null;
        },
        placeholder: '',
        inputFormat: 'isoDateTime',
        displayFormat: void 0,
        outputFormat: void 0,
        min: null,
        max: null,
        skipOptionalPartCharacter: '',
        i18n: {
          dayNames: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'],
          monthNames: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec', 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
          ordinalSuffix: ['st', 'nd', 'rd', 'th']
        },
        preValidation: function preValidation(buffer, pos, c, isSelection, opts, maskset, caretPos, strict) {
          if (strict) return !0;
          if (isNaN(c) && buffer[pos] !== c) {
            var tokenMatch = getTokenMatch(pos, opts);
            if (tokenMatch.nextMatch && tokenMatch.nextMatch[0] === c && 1 < tokenMatch.targetMatch[0].length) {
              var validator = formatCode[tokenMatch.targetMatch[0]][0];
              if (new RegExp(validator).test('0' + buffer[pos - 1])) return buffer[pos] = buffer[pos - 1], buffer[pos - 1] = '0', {
                fuzzy: !0,
                buffer: buffer,
                refreshFromBuffer: {
                  start: pos - 1,
                  end: pos + 1
                },
                pos: pos + 1
              };
            }
          }
          return !0;
        },
        postValidation: function postValidation(buffer, pos, c, currentResult, opts, maskset, strict) {
          if (strict) return !0;
          var tokenMatch;
          if (!1 === currentResult) {
            if (tokenMatch = getTokenMatch(pos + 1, opts), tokenMatch.targetMatch && tokenMatch.targetMatch.index === pos && 1 < tokenMatch.targetMatch[0].length && void 0 !== formatCode[tokenMatch.targetMatch[0]]) {
              var validator = formatCode[tokenMatch.targetMatch[0]][0];
              if (new RegExp(validator).test('0' + c)) return {
                insert: [{
                  pos: pos,
                  c: '0'
                }, {
                  pos: pos + 1,
                  c: c
                }],
                pos: pos + 1
              };
            }
            return currentResult;
          }
          if (currentResult.fuzzy && (buffer = currentResult.buffer, pos = currentResult.pos), tokenMatch = getTokenMatch(pos, opts), tokenMatch.targetMatch && tokenMatch.targetMatch[0] && void 0 !== formatCode[tokenMatch.targetMatch[0]]) {
            var validator = formatCode[tokenMatch.targetMatch[0]][0],
              part = buffer.slice(tokenMatch.targetMatch.index, tokenMatch.targetMatch.index + tokenMatch.targetMatch[0].length);
            !1 === new RegExp(validator).test(part.join('')) && 2 === tokenMatch.targetMatch[0].length && maskset.validPositions[tokenMatch.targetMatch.index] && maskset.validPositions[tokenMatch.targetMatch.index + 1] && (maskset.validPositions[tokenMatch.targetMatch.index + 1].input = '0');
          }
          var result = currentResult,
            dateParts = analyseMask(buffer.join(''), opts.inputFormat, opts);
          return result && dateParts.date.getTime() == dateParts.date.getTime() && (result = isValidDate(dateParts, result), result = result && isDateInRange(dateParts, opts)), pos && result && currentResult.pos !== pos ? {
            buffer: parse(opts.inputFormat, dateParts, opts).split(''),
            refreshFromBuffer: {
              start: pos,
              end: currentResult.pos
            }
          } : result;
        },
        onKeyDown: function onKeyDown(e, buffer, caretPos, opts) {
          var input = this;
          e.ctrlKey && e.keyCode === keyCode.RIGHT && (this.inputmask._valueSet(importDate(new Date(), opts)), $(this).trigger('setvalue'));
        },
        onUnMask: function onUnMask(maskedValue, unmaskedValue, opts) {
          return unmaskedValue ? parse(opts.outputFormat, analyseMask(maskedValue, opts.inputFormat, opts), opts, !0) : unmaskedValue;
        },
        casing: function casing(elem, test, pos, validPositions) {
          return 0 == test.nativeDef.indexOf('[ap]') ? elem.toLowerCase() : 0 == test.nativeDef.indexOf('[AP]') ? elem.toUpperCase() : elem;
        },
        onBeforeMask: function onBeforeMask(initialValue, opts) {
          return '[object Date]' === Object.prototype.toString.call(initialValue) && (initialValue = importDate(initialValue, opts)), initialValue;
        },
        insertMode: !1,
        shiftPositions: !1,
        keepStatic: !1,
        inputmode: 'numeric'
      }
    }), module.exports = Inputmask;
  }, function (module, exports, __nested_webpack_require_137530__) {
    'use strict';

    var Inputmask = __nested_webpack_require_137530__(1),
      $ = Inputmask.dependencyLib,
      keyCode = __nested_webpack_require_137530__(0);
    function autoEscape(txt, opts) {
      for (var escapedTxt = '', i = 0; i < txt.length; i++) Inputmask.prototype.definitions[txt.charAt(i)] || opts.definitions[txt.charAt(i)] || opts.optionalmarker[0] === txt.charAt(i) || opts.optionalmarker[1] === txt.charAt(i) || opts.quantifiermarker[0] === txt.charAt(i) || opts.quantifiermarker[1] === txt.charAt(i) || opts.groupmarker[0] === txt.charAt(i) || opts.groupmarker[1] === txt.charAt(i) || opts.alternatormarker === txt.charAt(i) ? escapedTxt += '\\' + txt.charAt(i) : escapedTxt += txt.charAt(i);
      return escapedTxt;
    }
    function alignDigits(buffer, digits, opts, force) {
      if (0 < digits && (!opts.digitsOptional || force)) {
        var radixPosition = $.inArray(opts.radixPoint, buffer);
        -1 === radixPosition && (buffer.push(opts.radixPoint), radixPosition = buffer.length - 1);
        for (var i = 1; i <= digits; i++) isFinite(buffer[radixPosition + i]) || (buffer[radixPosition + i] = '0');
      }
      return buffer;
    }
    function findValidator(symbol, maskset) {
      var posNdx = 0;
      if ('+' === symbol) {
        for (posNdx in maskset.validPositions);
        posNdx = parseInt(posNdx);
      }
      for (var tstNdx in maskset.tests) if (tstNdx = parseInt(tstNdx), posNdx <= tstNdx) for (var ndx = 0, ndxl = maskset.tests[tstNdx].length; ndx < ndxl; ndx++) if ((void 0 === maskset.validPositions[tstNdx] || '-' === symbol) && maskset.tests[tstNdx][ndx].match.def === symbol) return tstNdx + (void 0 !== maskset.validPositions[tstNdx] && '-' !== symbol ? 1 : 0);
      return posNdx;
    }
    function findValid(symbol, maskset) {
      var ret = -1;
      return $.each(maskset.validPositions, function (ndx, tst) {
        if (tst && tst.match.def === symbol) return ret = parseInt(ndx), !1;
      }), ret;
    }
    function parseMinMaxOptions(opts) {
      void 0 === opts.parseMinMaxOptions && (null !== opts.min && (opts.min = opts.min.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), 'g'), ''), ',' === opts.radixPoint && (opts.min = opts.min.replace(opts.radixPoint, '.')), opts.min = isFinite(opts.min) ? parseFloat(opts.min) : NaN, isNaN(opts.min) && (opts.min = Number.MIN_VALUE)), null !== opts.max && (opts.max = opts.max.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), 'g'), ''), ',' === opts.radixPoint && (opts.max = opts.max.replace(opts.radixPoint, '.')), opts.max = isFinite(opts.max) ? parseFloat(opts.max) : NaN, isNaN(opts.max) && (opts.max = Number.MAX_VALUE)), opts.parseMinMaxOptions = 'done');
    }
    function genMask(opts) {
      opts.repeat = 0, opts.groupSeparator === opts.radixPoint && opts.digits && '0' !== opts.digits && ('.' === opts.radixPoint ? opts.groupSeparator = ',' : ',' === opts.radixPoint ? opts.groupSeparator = '.' : opts.groupSeparator = ''), ' ' === opts.groupSeparator && (opts.skipOptionalPartCharacter = void 0), 1 < opts.placeholder.length && (opts.placeholder = opts.placeholder.charAt(0)), 'radixFocus' === opts.positionCaretOnClick && '' === opts.placeholder && (opts.positionCaretOnClick = 'lvp');
      var decimalDef = '0',
        radixPointDef = opts.radixPoint;
      !0 === opts.numericInput && void 0 === opts.__financeInput ? (decimalDef = '1', opts.positionCaretOnClick = 'radixFocus' === opts.positionCaretOnClick ? 'lvp' : opts.positionCaretOnClick, opts.digitsOptional = !1, isNaN(opts.digits) && (opts.digits = 2), opts._radixDance = !1, radixPointDef = ',' === opts.radixPoint ? '?' : '!', '' !== opts.radixPoint && void 0 === opts.definitions[radixPointDef] && (opts.definitions[radixPointDef] = {}, opts.definitions[radixPointDef].validator = '[' + opts.radixPoint + ']', opts.definitions[radixPointDef].placeholder = opts.radixPoint, opts.definitions[radixPointDef].static = !0, opts.definitions[radixPointDef].generated = !0)) : (opts.__financeInput = !1, opts.numericInput = !0);
      var mask = '[+]',
        altMask;
      if (mask += autoEscape(opts.prefix, opts), '' !== opts.groupSeparator ? (void 0 === opts.definitions[opts.groupSeparator] && (opts.definitions[opts.groupSeparator] = {}, opts.definitions[opts.groupSeparator].validator = '[' + opts.groupSeparator + ']', opts.definitions[opts.groupSeparator].placeholder = opts.groupSeparator, opts.definitions[opts.groupSeparator].static = !0, opts.definitions[opts.groupSeparator].generated = !0), mask += opts._mask(opts)) : mask += '9{+}', void 0 !== opts.digits && 0 !== opts.digits) {
        var dq = opts.digits.toString().split(',');
        isFinite(dq[0]) && dq[1] && isFinite(dq[1]) ? mask += radixPointDef + decimalDef + '{' + opts.digits + '}' : (isNaN(opts.digits) || 0 < parseInt(opts.digits)) && (opts.digitsOptional ? (altMask = mask + radixPointDef + decimalDef + '{0,' + opts.digits + '}', opts.keepStatic = !0) : mask += radixPointDef + decimalDef + '{' + opts.digits + '}');
      }
      return mask += autoEscape(opts.suffix, opts), mask += '[-]', altMask && (mask = [altMask + autoEscape(opts.suffix, opts) + '[-]', mask]), opts.greedy = !1, parseMinMaxOptions(opts), mask;
    }
    function hanndleRadixDance(pos, c, radixPos, maskset, opts) {
      return opts._radixDance && opts.numericInput && c !== opts.negationSymbol.back && pos <= radixPos && (0 < radixPos || c == opts.radixPoint) && (void 0 === maskset.validPositions[pos - 1] || maskset.validPositions[pos - 1].input !== opts.negationSymbol.back) && (pos -= 1), pos;
    }
    function decimalValidator(chrs, maskset, pos, strict, opts) {
      var radixPos = maskset.buffer ? maskset.buffer.indexOf(opts.radixPoint) : -1,
        result = -1 !== radixPos && new RegExp('[0-9\uff11-\uff19]').test(chrs);
      return opts._radixDance && result && null == maskset.validPositions[radixPos] ? {
        insert: {
          pos: radixPos === pos ? radixPos + 1 : radixPos,
          c: opts.radixPoint
        },
        pos: pos
      } : result;
    }
    function checkForLeadingZeroes(buffer, opts) {
      var numberMatches = new RegExp('(^' + ('' !== opts.negationSymbol.front ? Inputmask.escapeRegex(opts.negationSymbol.front) + '?' : '') + Inputmask.escapeRegex(opts.prefix) + ')(.*)(' + Inputmask.escapeRegex(opts.suffix) + ('' != opts.negationSymbol.back ? Inputmask.escapeRegex(opts.negationSymbol.back) + '?' : '') + '$)').exec(buffer.slice().reverse().join('')),
        number = numberMatches ? numberMatches[2] : '',
        leadingzeroes = !1;
      return number && (number = number.split(opts.radixPoint.charAt(0))[0], leadingzeroes = new RegExp('^[0' + opts.groupSeparator + ']*').exec(number)), !(!leadingzeroes || !(1 < leadingzeroes[0].length || 0 < leadingzeroes[0].length && leadingzeroes[0].length < number.length)) && leadingzeroes;
    }
    Inputmask.extendAliases({
      numeric: {
        mask: genMask,
        _mask: function _mask(opts) {
          return '(' + opts.groupSeparator + '999){+|1}';
        },
        digits: '*',
        digitsOptional: !0,
        enforceDigitsOnBlur: !1,
        radixPoint: '.',
        positionCaretOnClick: 'radixFocus',
        _radixDance: !0,
        groupSeparator: '',
        allowMinus: !0,
        negationSymbol: {
          front: '-',
          back: ''
        },
        prefix: '',
        suffix: '',
        min: null,
        max: null,
        step: 1,
        unmaskAsNumber: !1,
        roundingFN: Math.round,
        inputmode: 'numeric',
        shortcuts: {
          k: '000',
          m: '000000'
        },
        placeholder: '0',
        greedy: !1,
        rightAlign: !0,
        insertMode: !0,
        autoUnmask: !1,
        skipOptionalPartCharacter: '',
        definitions: {
          0: {
            validator: decimalValidator
          },
          1: {
            validator: decimalValidator,
            definitionSymbol: '9'
          },
          '+': {
            validator: function validator(chrs, maskset, pos, strict, opts) {
              return opts.allowMinus && ('-' === chrs || chrs === opts.negationSymbol.front);
            }
          },
          '-': {
            validator: function validator(chrs, maskset, pos, strict, opts) {
              return opts.allowMinus && chrs === opts.negationSymbol.back;
            }
          }
        },
        preValidation: function preValidation(buffer, pos, c, isSelection, opts, maskset, caretPos, strict) {
          if (!1 !== opts.__financeInput && c === opts.radixPoint) return !1;
          var pattern;
          if (pattern = opts.shortcuts && opts.shortcuts[c]) {
            if (1 < pattern.length) for (var inserts = [], i = 0; i < pattern.length; i++) inserts.push({
              pos: pos + i,
              c: pattern[i],
              strict: !1
            });
            return {
              insert: inserts
            };
          }
          var radixPos = $.inArray(opts.radixPoint, buffer),
            initPos = pos;
          if (pos = hanndleRadixDance(pos, c, radixPos, maskset, opts), '-' === c || c === opts.negationSymbol.front) {
            if (!0 !== opts.allowMinus) return !1;
            var isNegative = !1,
              front = findValid('+', maskset),
              back = findValid('-', maskset);
            return -1 !== front && (isNegative = [front, back]), !1 !== isNegative ? {
              remove: isNegative,
              caret: initPos
            } : {
              insert: [{
                pos: findValidator('+', maskset),
                c: opts.negationSymbol.front,
                fromIsValid: !0
              }, {
                pos: findValidator('-', maskset),
                c: opts.negationSymbol.back,
                fromIsValid: void 0
              }],
              caret: initPos + opts.negationSymbol.back.length
            };
          }
          if (strict) return !0;
          if (-1 !== radixPos && !0 === opts._radixDance && !1 === isSelection && c === opts.radixPoint && void 0 !== opts.digits && (isNaN(opts.digits) || 0 < parseInt(opts.digits)) && radixPos !== pos) return {
            caret: opts._radixDance && pos === radixPos - 1 ? radixPos + 1 : radixPos
          };
          if (!1 === opts.__financeInput) if (isSelection) {
            if (opts.digitsOptional) return {
              rewritePosition: caretPos.end
            };
            if (!opts.digitsOptional) {
              if (caretPos.begin > radixPos && caretPos.end <= radixPos) return c === opts.radixPoint ? {
                insert: {
                  pos: radixPos + 1,
                  c: '0',
                  fromIsValid: !0
                },
                rewritePosition: radixPos
              } : {
                rewritePosition: radixPos + 1
              };
              if (caretPos.begin < radixPos) return {
                rewritePosition: caretPos.begin - 1
              };
            }
          } else if (!opts.showMaskOnHover && !opts.showMaskOnFocus && !opts.digitsOptional && 0 < opts.digits && '' === this.inputmask.__valueGet.call(this)) return {
            rewritePosition: radixPos
          };
          return {
            rewritePosition: pos
          };
        },
        postValidation: function postValidation(buffer, pos, c, currentResult, opts, maskset, strict) {
          if (!1 === currentResult) return currentResult;
          if (strict) return !0;
          if (null !== opts.min || null !== opts.max) {
            var unmasked = opts.onUnMask(buffer.slice().reverse().join(''), void 0, $.extend({}, opts, {
              unmaskAsNumber: !0
            }));
            if (null !== opts.min && unmasked < opts.min && (unmasked.toString().length >= opts.min.toString().length || unmasked < 0)) return !1;
            if (null !== opts.max && unmasked > opts.max) return !1;
          }
          return currentResult;
        },
        onUnMask: function onUnMask(maskedValue, unmaskedValue, opts) {
          if ('' === unmaskedValue && !0 === opts.nullable) return unmaskedValue;
          var processValue = maskedValue.replace(opts.prefix, '');
          return processValue = processValue.replace(opts.suffix, ''), processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), 'g'), ''), '' !== opts.placeholder.charAt(0) && (processValue = processValue.replace(new RegExp(opts.placeholder.charAt(0), 'g'), '0')), opts.unmaskAsNumber ? ('' !== opts.radixPoint && -1 !== processValue.indexOf(opts.radixPoint) && (processValue = processValue.replace(Inputmask.escapeRegex.call(this, opts.radixPoint), '.')), processValue = processValue.replace(new RegExp('^' + Inputmask.escapeRegex(opts.negationSymbol.front)), '-'), processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + '$'), ''), Number(processValue)) : processValue;
        },
        isComplete: function isComplete(buffer, opts) {
          var maskedValue = (opts.numericInput ? buffer.slice().reverse() : buffer).join('');
          return maskedValue = maskedValue.replace(new RegExp('^' + Inputmask.escapeRegex(opts.negationSymbol.front)), '-'), maskedValue = maskedValue.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + '$'), ''), maskedValue = maskedValue.replace(opts.prefix, ''), maskedValue = maskedValue.replace(opts.suffix, ''), maskedValue = maskedValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator) + '([0-9]{3})', 'g'), '$1'), ',' === opts.radixPoint && (maskedValue = maskedValue.replace(Inputmask.escapeRegex(opts.radixPoint), '.')), isFinite(maskedValue);
        },
        onBeforeMask: function onBeforeMask(initialValue, opts) {
          var radixPoint = opts.radixPoint || ',';
          isFinite(opts.digits) && (opts.digits = parseInt(opts.digits)), 'number' != typeof initialValue && 'number' !== opts.inputType || '' === radixPoint || (initialValue = initialValue.toString().replace('.', radixPoint));
          var valueParts = initialValue.split(radixPoint),
            integerPart = valueParts[0].replace(/[^\-0-9]/g, ''),
            decimalPart = 1 < valueParts.length ? valueParts[1].replace(/[^0-9]/g, '') : '',
            forceDigits = 1 < valueParts.length;
          initialValue = integerPart + ('' !== decimalPart ? radixPoint + decimalPart : decimalPart);
          var digits = 0;
          if ('' !== radixPoint && (digits = opts.digitsOptional ? opts.digits < decimalPart.length ? opts.digits : decimalPart.length : opts.digits, '' !== decimalPart || !opts.digitsOptional)) {
            var digitsFactor = Math.pow(10, digits || 1);
            initialValue = initialValue.replace(Inputmask.escapeRegex(radixPoint), '.'), isFinite(initialValue) && (initialValue = (opts.roundingFN(parseFloat(initialValue) * digitsFactor) / digitsFactor).toFixed(digits)), initialValue = initialValue.toString().replace('.', radixPoint);
          }
          if (0 === opts.digits && -1 !== initialValue.indexOf(radixPoint) && (initialValue = initialValue.substring(0, initialValue.indexOf(radixPoint))), null !== opts.min || null !== opts.max) {
            var numberValue = initialValue.toString().replace(radixPoint, '.');
            null !== opts.min && numberValue < opts.min ? initialValue = opts.min.toString().replace('.', radixPoint) : null !== opts.max && numberValue > opts.max && (initialValue = opts.max.toString().replace('.', radixPoint));
          }
          return alignDigits(initialValue.toString().split(''), digits, opts, forceDigits).join('');
        },
        onBeforeWrite: function onBeforeWrite(e, buffer, caretPos, opts) {
          function stripBuffer(buffer, stripRadix) {
            if (!1 !== opts.__financeInput || stripRadix) {
              var position = $.inArray(opts.radixPoint, buffer);
              -1 !== position && buffer.splice(position, 1);
            }
            if ('' !== opts.groupSeparator) for (; -1 !== (position = buffer.indexOf(opts.groupSeparator));) buffer.splice(position, 1);
            return buffer;
          }
          var result,
            leadingzeroes = checkForLeadingZeroes(buffer, opts);
          if (leadingzeroes) {
            var buf = buffer.slice().reverse(),
              caretNdx = buf.join('').indexOf(leadingzeroes[0]);
            buf.splice(caretNdx, leadingzeroes[0].length);
            var newCaretPos = buf.length - caretNdx;
            stripBuffer(buf), result = {
              refreshFromBuffer: !0,
              buffer: buf.reverse(),
              caret: caretPos < newCaretPos ? caretPos : newCaretPos
            };
          }
          if (e) switch (e.type) {
            case 'blur':
            case 'checkval':
              if (null !== opts.min) {
                var unmasked = opts.onUnMask(buffer.slice().reverse().join(''), void 0, $.extend({}, opts, {
                  unmaskAsNumber: !0
                }));
                if (null !== opts.min && unmasked < opts.min) return {
                  refreshFromBuffer: !0,
                  buffer: alignDigits(opts.min.toString().replace('.', opts.radixPoint).split(''), opts.digits, opts).reverse()
                };
              }
              if (buffer[buffer.length - 1] === opts.negationSymbol.front) {
                var nmbrMtchs = new RegExp('(^' + ('' != opts.negationSymbol.front ? Inputmask.escapeRegex(opts.negationSymbol.front) + '?' : '') + Inputmask.escapeRegex(opts.prefix) + ')(.*)(' + Inputmask.escapeRegex(opts.suffix) + ('' != opts.negationSymbol.back ? Inputmask.escapeRegex(opts.negationSymbol.back) + '?' : '') + '$)').exec(stripBuffer(buffer.slice(), !0).reverse().join('')),
                  number = nmbrMtchs ? nmbrMtchs[2] : '';
                0 == number && (result = {
                  refreshFromBuffer: !0,
                  buffer: [0]
                });
              } else '' !== opts.radixPoint && buffer[0] === opts.radixPoint && (result && result.buffer ? result.buffer.shift() : (buffer.shift(), result = {
                refreshFromBuffer: !0,
                buffer: stripBuffer(buffer)
              }));
              if (opts.enforceDigitsOnBlur) {
                result = result || {};
                var bffr = result && result.buffer || buffer.slice().reverse();
                result.refreshFromBuffer = !0, result.buffer = alignDigits(bffr, opts.digits, opts, !0).reverse();
              }
          }
          return result;
        },
        onKeyDown: function onKeyDown(e, buffer, caretPos, opts) {
          var $input = $(this),
            bffr;
          if (e.ctrlKey) switch (e.keyCode) {
            case keyCode.UP:
              return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) + parseInt(opts.step)), $input.trigger('setvalue'), !1;
            case keyCode.DOWN:
              return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) - parseInt(opts.step)), $input.trigger('setvalue'), !1;
          }
          if (!e.shiftKey && (e.keyCode === keyCode.DELETE || e.keyCode === keyCode.BACKSPACE || e.keyCode === keyCode.BACKSPACE_SAFARI) && caretPos.begin !== buffer.length) {
            if (buffer[e.keyCode === keyCode.DELETE ? caretPos.begin - 1 : caretPos.end] === opts.negationSymbol.front) return bffr = buffer.slice().reverse(), '' !== opts.negationSymbol.front && bffr.shift(), '' !== opts.negationSymbol.back && bffr.pop(), $input.trigger('setvalue', [bffr.join(''), caretPos.begin]), !1;
            if (!0 === opts._radixDance) {
              var radixPos = $.inArray(opts.radixPoint, buffer);
              if (opts.digitsOptional) {
                if (0 === radixPos) return bffr = buffer.slice().reverse(), bffr.pop(), $input.trigger('setvalue', [bffr.join(''), caretPos.begin >= bffr.length ? bffr.length : caretPos.begin]), !1;
              } else if (-1 !== radixPos && (caretPos.begin < radixPos || caretPos.end < radixPos || e.keyCode === keyCode.DELETE && caretPos.begin === radixPos)) return caretPos.begin !== caretPos.end || e.keyCode !== keyCode.BACKSPACE && e.keyCode !== keyCode.BACKSPACE_SAFARI || caretPos.begin++, bffr = buffer.slice().reverse(), bffr.splice(bffr.length - caretPos.begin, caretPos.begin - caretPos.end + 1), bffr = alignDigits(bffr, opts.digits, opts).join(''), $input.trigger('setvalue', [bffr, caretPos.begin >= bffr.length ? radixPos + 1 : caretPos.begin]), !1;
            }
          }
        }
      },
      currency: {
        prefix: '',
        groupSeparator: ',',
        alias: 'numeric',
        digits: 2,
        digitsOptional: !1
      },
      decimal: {
        alias: 'numeric'
      },
      integer: {
        alias: 'numeric',
        digits: 0
      },
      percentage: {
        alias: 'numeric',
        min: 0,
        max: 100,
        suffix: ' %',
        digits: 0,
        allowMinus: !1
      },
      indianns: {
        alias: 'numeric',
        _mask: function _mask(opts) {
          return '(' + opts.groupSeparator + '99){*|1}(' + opts.groupSeparator + '999){1|1}';
        },
        groupSeparator: ',',
        radixPoint: '.',
        placeholder: '0',
        digits: 2,
        digitsOptional: !1
      }
    }), module.exports = Inputmask;
  }, function (module, exports, __nested_webpack_require_158869__) {
    'use strict';

    var _inputmask = _interopRequireDefault(__nested_webpack_require_158869__(1));
    function _typeof(obj) {
      return _typeof = 'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator ? function _typeof(obj) {
        return typeof obj;
      } : function _typeof(obj) {
        return obj && 'function' == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
      }, _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError('Cannot call a class as a function');
    }
    function _possibleConstructorReturn(self, call) {
      return !call || 'object' !== _typeof(call) && 'function' != typeof call ? _assertThisInitialized(self) : call;
    }
    function _assertThisInitialized(self) {
      if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _inherits(subClass, superClass) {
      if ('function' != typeof superClass && null !== superClass) throw new TypeError('Super expression must either be null or a function');
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _wrapNativeSuper(Class) {
      var _cache = 'function' == typeof Map ? new Map() : void 0;
      return _wrapNativeSuper = function _wrapNativeSuper(Class) {
        if (null === Class || !_isNativeFunction(Class)) return Class;
        if ('function' != typeof Class) throw new TypeError('Super expression must either be null or a function');
        if ('undefined' != typeof _cache) {
          if (_cache.has(Class)) return _cache.get(Class);
          _cache.set(Class, Wrapper);
        }
        function Wrapper() {
          return _construct(Class, arguments, _getPrototypeOf(this).constructor);
        }
        return Wrapper.prototype = Object.create(Class.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: !1,
            writable: !0,
            configurable: !0
          }
        }), _setPrototypeOf(Wrapper, Class);
      }, _wrapNativeSuper(Class);
    }
    function isNativeReflectConstruct() {
      if ('undefined' == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ('function' == typeof Proxy) return !0;
      try {
        return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;
      } catch (e) {
        return !1;
      }
    }
    function _construct(Parent, args, Class) {
      return _construct = isNativeReflectConstruct() ? Reflect.construct : function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a),
          instance = new Constructor();
        return Class && _setPrototypeOf(instance, Class.prototype), instance;
      }, _construct.apply(null, arguments);
    }
    function _isNativeFunction(fn) {
      return -1 !== Function.toString.call(fn).indexOf('[native code]');
    }
    function _setPrototypeOf(o, p) {
      return _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        return o.__proto__ = p, o;
      }, _setPrototypeOf(o, p);
    }
    function _getPrototypeOf(o) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      }, _getPrototypeOf(o);
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    if (document.head.createShadowRoot || document.head.attachShadow) {
      var InputmaskElement = function (_HTMLElement) {
        function InputmaskElement() {
          var _this;
          _classCallCheck(this, InputmaskElement), _this = _possibleConstructorReturn(this, _getPrototypeOf(InputmaskElement).call(this));
          var attributeNames = _this.getAttributeNames(),
            shadow = _this.attachShadow({
              mode: 'closed'
            }),
            input = document.createElement('input');
          for (var attr in input.type = 'text', shadow.appendChild(input), attributeNames) Object.prototype.hasOwnProperty.call(attributeNames, attr) && input.setAttribute('data-inputmask-' + attributeNames[attr], _this.getAttribute(attributeNames[attr]));
          return new _inputmask.default().mask(input), input.inputmask.shadowRoot = shadow, _this;
        }
        return _inherits(InputmaskElement, _HTMLElement), InputmaskElement;
      }(_wrapNativeSuper(HTMLElement));
      customElements.define('input-mask', InputmaskElement);
    }
  }], installedModules = {}, __nested_webpack_require_165406__.m = modules, __nested_webpack_require_165406__.c = installedModules, __nested_webpack_require_165406__.d = function (exports, name, getter) {
    __nested_webpack_require_165406__.o(exports, name) || Object.defineProperty(exports, name, {
      enumerable: !0,
      get: getter
    });
  }, __nested_webpack_require_165406__.r = function (exports) {
    'undefined' != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {
      value: 'Module'
    }), Object.defineProperty(exports, '__esModule', {
      value: !0
    });
  }, __nested_webpack_require_165406__.t = function (value, mode) {
    if (1 & mode && (value = __nested_webpack_require_165406__(value)), 8 & mode) return value;
    if (4 & mode && 'object' == typeof value && value && value.__esModule) return value;
    var ns = Object.create(null);
    if (__nested_webpack_require_165406__.r(ns), Object.defineProperty(ns, 'default', {
      enumerable: !0,
      value: value
    }), 2 & mode && 'string' != typeof value) for (var key in value) __nested_webpack_require_165406__.d(ns, key, function (key) {
      return value[key];
    }.bind(null, key));
    return ns;
  }, __nested_webpack_require_165406__.n = function (module) {
    var getter = module && module.__esModule ? function getDefault() {
      return module.default;
    } : function getModuleExports() {
      return module;
    };
    return __nested_webpack_require_165406__.d(getter, 'a', getter), getter;
  }, __nested_webpack_require_165406__.o = function (object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  }, __nested_webpack_require_165406__.p = '', __nested_webpack_require_165406__(__nested_webpack_require_165406__.s = 5);
  function __nested_webpack_require_165406__(moduleId) {
    if (installedModules[moduleId]) return installedModules[moduleId].exports;
    var module = installedModules[moduleId] = {
      i: moduleId,
      l: !1,
      exports: {}
    };
    return modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_165406__), module.l = !0, module.exports;
  }
  var modules, installedModules;
});

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!************************!*\
  !*** ./src/js/main.js ***!
  \************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _components_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_components.js */ "./src/js/_components.js");
/* harmony import */ var _scripts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scripts.js */ "./src/js/scripts.js");
 // то, что пишется шаблонно
 // то, что пишется своими ручками
})();

/******/ })()
;
//# sourceMappingURL=main.min.js.map